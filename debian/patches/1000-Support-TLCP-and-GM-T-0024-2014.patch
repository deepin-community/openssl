From 062bebe9fefba970a09d17df5c10be815c6df4ab Mon Sep 17 00:00:00 2001
From: jishengli <jishengli@uniontech.com>
Date: Thu, 27 Feb 2025 09:12:09 +0800
Subject: [PATCH] 1000-Support-TLCP-and-GM-T-0024-2014

---
 Configure                                                |    2 
 apps/ca.c                                                |   64 
 apps/include/apps.h                                      |   13 
 apps/include/s_apps.h                                    |    6 
 apps/lib/apps.c                                          |   79 
 apps/lib/s_cb.c                                          |   86 
 apps/pkeyutl.c                                           |   28 
 apps/req.c                                               |   68 
 apps/s_client.c                                          |  149 
 apps/s_server.c                                          |  166 
 apps/verify.c                                            |   43 
 apps/x509.c                                              |   64 
 crypto/asn1/a_verify.c                                   |   54 
 crypto/asn1/i2d_evp.c                                    |    3 
 crypto/err/openssl.txt                                   |    2 
 crypto/objects/obj_dat.h                                 |   15 
 crypto/objects/obj_mac.num                               |    3 
 crypto/objects/objects.txt                               |    3 
 crypto/sm2/build.info                                    |    2 
 crypto/sm2/sm2_err.c                                     |    1 
 crypto/sm2/sm2_kmeth.c                                   |  255 +
 crypto/sm2/sm2_sign.c                                    |    7 
 crypto/sm4/sm4.c                                         |    1 
 doc/man1/openssl-ca.pod.in                               |   17 
 doc/man1/openssl-req.pod.in                              |   17 
 doc/man1/openssl-s_client.pod.in                         |   36 
 doc/man1/openssl-s_server.pod.in                         |   54 
 doc/man1/openssl-verify.pod.in                           |   17 
 doc/man1/openssl-x509.pod.in                             |   17 
 doc/man3/BIO_get_ex_new_index.pod                        |   25 
 doc/man3/ERR_print_errors.pod                            |   12 
 doc/man3/SSL_CIPHER_get_name.pod                         |   35 
 doc/man3/SSL_CTX_new.pod                                 |   13 
 doc/man3/SSL_CTX_set_alpn_select_cb.pod                  |   15 
 doc/man3/SSL_CTX_set_cert_cb.pod                         |   27 
 doc/man3/SSL_CTX_set_client_hello_cb.pod                 |   13 
 doc/man3/SSL_CTX_set_tlsext_status_cb.pod                |   17 
 doc/man3/SSL_CTX_use_certificate.pod                     |   71 
 doc/man3/SSL_get_certificate.pod                         |   25 
 doc/man3/SSL_get_client_random.pod                       |   13 
 doc/man3/SSL_get_rbio.pod                                |   10 
 doc/man3/SSL_get_version.pod                             |   22 
 include/crypto/sm2.h                                     |   10 
 include/crypto/sm2err.h                                  |    1 
 include/internal/tlsgroups.h                             |    3 
 include/openssl/core_names.h.in                          |   11 
 include/openssl/ntls.h                                   |   92 
 include/openssl/obj_mac.h                                |   14 
 include/openssl/prov_ssl.h                               |    1 
 include/openssl/ssl.h.in                                 |  144 
 include/openssl/sslerr.h                                 |    2 
 include/openssl/tls1.h                                   |    3 
 include/openssl/x509.h.in                                |    8 
 providers/common/capabilities.c                          |    6 
 providers/defltprov.c                                    |    4 
 providers/implementations/ciphers/ciphercommon_block.c   |    3 
 providers/implementations/exchange/build.info            |    5 
 providers/implementations/exchange/sm2dh_exch.c          |  478 ++
 providers/implementations/include/prov/implementations.h |    4 
 providers/implementations/include/prov/names.h           |    2 
 providers/implementations/keymgmt/ec_kmgmt.c             |    2 
 ssl/build.info                                           |    9 
 ssl/methods.c                                            |   37 
 ssl/record/methods/recmethod_local.h                     |    8 
 ssl/record/methods/tls_common.c                          |    9 
 ssl/s3_lib.c                                             |  149 
 ssl/ssl_asn1.c                                           |    3 
 ssl/ssl_cert.c                                           |   21 
 ssl/ssl_cert_table.h                                     |    9 
 ssl/ssl_ciph.c                                           |   83 
 ssl/ssl_conf.c                                           |  144 
 ssl/ssl_err.c                                            |    2 
 ssl/ssl_lib.c                                            |  384 ++
 ssl/ssl_local.h                                          |   83 
 ssl/ssl_rsa.c                                            |  635 +++
 ssl/ssl_sess.c                                           |    3 
 ssl/ssl_stat.c                                           |   30 
 ssl/statem/statem.c                                      |   28 
 ssl/statem/statem_lib.c                                  |   55 
 ssl/statem/statem_local.h                                |   11 
 ssl/statem_ntls/README.md                                |   58 
 ssl/statem_ntls/ntls_extensions.c                        | 1435 ++++++++
 ssl/statem_ntls/ntls_extensions_clnt.c                   | 1610 +++++++++
 ssl/statem_ntls/ntls_extensions_cust.c                   |  528 +++
 ssl/statem_ntls/ntls_extensions_srvr.c                   | 1645 +++++++++
 ssl/statem_ntls/ntls_ssl_local.h                         |   77 
 ssl/statem_ntls/ntls_statem.c                            |  928 +++++
 ssl/statem_ntls/ntls_statem.h                            |  128 
 ssl/statem_ntls/ntls_statem_clnt.c                       | 2406 ++++++++++++++
 ssl/statem_ntls/ntls_statem_lib.c                        | 2127 ++++++++++++
 ssl/statem_ntls/ntls_statem_local.h                      |  456 ++
 ssl/statem_ntls/ntls_statem_srvr.c                       | 2518 +++++++++++++++
 ssl/t1_enc.c                                             |   78 
 ssl/t1_lib.c                                             |  139 
 ssl/t1_trce.c                                            |   41 
 test/babasslapitest.c                                    |  538 +++
 test/build.info                                          |   14 
 test/certs/client-rsa-enc-expired.crt                    |   19 
 test/certs/client-rsa-enc-expired.key                    |   28 
 test/certs/client-rsa-enc.crt                            |   19 
 test/certs/client-rsa-enc.key                            |   28 
 test/certs/client-rsa-sign-expired.crt                   |   19 
 test/certs/client-rsa-sign-expired.key                   |   28 
 test/certs/client-rsa-sign.crt                           |   19 
 test/certs/client-rsa-sign.key                           |   28 
 test/certs/server-rsa-enc.crt                            |   19 
 test/certs/server-rsa-enc.key                            |   28 
 test/certs/server-rsa-sign.crt                           |   19 
 test/certs/server-rsa-sign.key                           |   28 
 test/certs/sm2/chain-ca.crt                              |   26 
 test/certs/sm2/client_enc.crt                            |   13 
 test/certs/sm2/client_enc.key                            |    5 
 test/certs/sm2/client_enc_expire.crt                     |   13 
 test/certs/sm2/client_sign.crt                           |   13 
 test/certs/sm2/client_sign.key                           |    5 
 test/certs/sm2/client_sign_expire.crt                    |   13 
 test/certs/sm2/server_enc.crt                            |   13 
 test/certs/sm2/server_enc.key                            |    5 
 test/certs/sm2/server_enc_expire.crt                     |   13 
 test/certs/sm2/server_sign.crt                           |   13 
 test/certs/sm2/server_sign.key                           |    5 
 test/certs/sm2/server_sign_expire.crt                    |   13 
 test/ciphername_test.c                                   |    8 
 test/helpers/handshake.c                                 |    2 
 test/helpers/ssl_test_ctx.c                              |    9 
 test/helpers/ssl_test_ctx.h                              |    5 
 test/recipes/20-test_pkeyutl.t                           |    4 
 test/recipes/25-test_req.t                               |   24 
 test/recipes/25-test_verify.t                            |    6 
 test/recipes/25-test_x509.t                              |   52 
 test/recipes/80-test_ca.t                                |   29 
 test/recipes/80-test_sign_sm2.t                          |  249 +
 test/recipes/80-test_sign_sm2_data/ca.cnf                |  135 
 test/recipes/80-test_sign_sm2_data/subca.cnf             |  150 
 test/recipes/80-test_ssl_new.t                           |   16 
 test/recipes/88-test_ssl_ntls_api.t                      |   32 
 test/recipes/90-test_babasslapi.t                        |   21 
 test/ssl-tests/31-ntls.cnf                               |  580 +++
 test/ssl-tests/31-ntls.cnf.in                            |  408 ++
 test/ssl-tests/39-ntls-sni-ticket.cnf                    |  971 +++++
 test/ssl-tests/39-ntls-sni-ticket.cnf.in                 |  123 
 test/ssl-tests/40-ntls_client_auth.cnf                   |  836 ++++
 test/ssl-tests/40-ntls_client_auth.cnf.in                |  608 +++
 test/ssl-tests/41-ntls-alpn.cnf                          |  783 ++++
 test/ssl-tests/41-ntls-alpn.cnf.in                       |  510 +++
 test/ssl-tests/ssltests_base.pm                          |   14 
 test/ssl_cert_table_internal_test.c                      |   12 
 test/ssl_ntls_api_test.c                                 |  623 +++
 test/ssl_test.c                                          |   28 
 util/libssl.num                                          |   48 
 util/other.syms                                          |   22 
 util/perl/OpenSSL/Test.pm                                |   28 
 152 files changed, 25464 insertions(+), 96 deletions(-)
 create mode 100644 crypto/sm2/sm2_kmeth.c
 create mode 100644 include/openssl/ntls.h
 create mode 100644 providers/implementations/exchange/sm2dh_exch.c
 create mode 100644 ssl/statem_ntls/README.md
 create mode 100644 ssl/statem_ntls/ntls_extensions.c
 create mode 100644 ssl/statem_ntls/ntls_extensions_clnt.c
 create mode 100644 ssl/statem_ntls/ntls_extensions_cust.c
 create mode 100644 ssl/statem_ntls/ntls_extensions_srvr.c
 create mode 100644 ssl/statem_ntls/ntls_ssl_local.h
 create mode 100644 ssl/statem_ntls/ntls_statem.c
 create mode 100644 ssl/statem_ntls/ntls_statem.h
 create mode 100644 ssl/statem_ntls/ntls_statem_clnt.c
 create mode 100644 ssl/statem_ntls/ntls_statem_lib.c
 create mode 100644 ssl/statem_ntls/ntls_statem_local.h
 create mode 100644 ssl/statem_ntls/ntls_statem_srvr.c
 create mode 100644 test/babasslapitest.c
 create mode 100644 test/certs/client-rsa-enc-expired.crt
 create mode 100644 test/certs/client-rsa-enc-expired.key
 create mode 100644 test/certs/client-rsa-enc.crt
 create mode 100644 test/certs/client-rsa-enc.key
 create mode 100644 test/certs/client-rsa-sign-expired.crt
 create mode 100644 test/certs/client-rsa-sign-expired.key
 create mode 100644 test/certs/client-rsa-sign.crt
 create mode 100644 test/certs/client-rsa-sign.key
 create mode 100644 test/certs/server-rsa-enc.crt
 create mode 100644 test/certs/server-rsa-enc.key
 create mode 100644 test/certs/server-rsa-sign.crt
 create mode 100644 test/certs/server-rsa-sign.key
 create mode 100644 test/certs/sm2/chain-ca.crt
 create mode 100644 test/certs/sm2/client_enc.crt
 create mode 100644 test/certs/sm2/client_enc.key
 create mode 100644 test/certs/sm2/client_enc_expire.crt
 create mode 100644 test/certs/sm2/client_sign.crt
 create mode 100644 test/certs/sm2/client_sign.key
 create mode 100644 test/certs/sm2/client_sign_expire.crt
 create mode 100644 test/certs/sm2/server_enc.crt
 create mode 100644 test/certs/sm2/server_enc.key
 create mode 100644 test/certs/sm2/server_enc_expire.crt
 create mode 100644 test/certs/sm2/server_sign.crt
 create mode 100644 test/certs/sm2/server_sign.key
 create mode 100644 test/certs/sm2/server_sign_expire.crt
 create mode 100644 test/recipes/80-test_sign_sm2.t
 create mode 100644 test/recipes/80-test_sign_sm2_data/ca.cnf
 create mode 100644 test/recipes/80-test_sign_sm2_data/subca.cnf
 create mode 100644 test/recipes/88-test_ssl_ntls_api.t
 create mode 100644 test/recipes/90-test_babasslapi.t
 create mode 100644 test/ssl-tests/31-ntls.cnf
 create mode 100644 test/ssl-tests/31-ntls.cnf.in
 create mode 100644 test/ssl-tests/39-ntls-sni-ticket.cnf
 create mode 100644 test/ssl-tests/39-ntls-sni-ticket.cnf.in
 create mode 100644 test/ssl-tests/40-ntls_client_auth.cnf
 create mode 100644 test/ssl-tests/40-ntls_client_auth.cnf.in
 create mode 100644 test/ssl-tests/41-ntls-alpn.cnf
 create mode 100644 test/ssl-tests/41-ntls-alpn.cnf.in
 create mode 100644 test/ssl_ntls_api_test.c

Index: b/Configure
===================================================================
--- a/Configure
+++ b/Configure
@@ -475,6 +475,7 @@ my @disablables = (
     "msan",
     "multiblock",
     "nextprotoneg",
+    "ntls",
     "ocb",
     "ocsp",
     "padlockeng",
@@ -571,6 +572,7 @@ our %disabled = ( # "what"         => "c
                   "ktls"                => "default",
                   "md2"                 => "default",
                   "msan"                => "default",
+                  "ntls"                => "default",
                   "rc5"                 => "default",
                   "sctp"                => "default",
                   "ssl3"                => "default",
Index: b/apps/include/s_apps.h
===================================================================
--- a/apps/include/s_apps.h
+++ b/apps/include/s_apps.h
@@ -31,6 +31,12 @@ int set_cert_stuff(SSL_CTX *ctx, char *c
 int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
                        STACK_OF(X509) *chain, int build_chain);
 int ssl_print_sigalgs(BIO *out, SSL *s);
+#ifndef OPENSSL_NO_NTLS
+int set_enc_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+                           STACK_OF(X509) *chain, int build_chain);
+int set_sign_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+                            STACK_OF(X509) *chain, int build_chain);
+#endif
 int ssl_print_point_formats(BIO *out, SSL *s);
 int ssl_print_groups(BIO *out, SSL *s, int noshared);
 int ssl_print_tmp_key(BIO *out, SSL *s);
Index: b/apps/lib/s_cb.c
===================================================================
--- a/apps/lib/s_cb.c
+++ b/apps/lib/s_cb.c
@@ -191,6 +191,87 @@ int set_cert_key_stuff(SSL_CTX *ctx, X50
     return 1;
 }
 
+#ifndef OPENSSL_NO_NTLS
+int set_sign_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+                            STACK_OF(X509) *chain, int build_chain)
+{
+    int chflags = chain ? SSL_BUILD_CHAIN_FLAG_CHECK : 0;
+    if (cert == NULL)
+        return 1;
+    if (SSL_CTX_use_sign_certificate(ctx, cert) <= 0) {
+        BIO_printf(bio_err, "error setting sign certificate\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+
+    if (SSL_CTX_use_sign_PrivateKey(ctx, key) <= 0) {
+        BIO_printf(bio_err, "error setting sign private key\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+
+    /*
+     * Now we know that a key and cert have been set against the SSL context
+     */
+    if (!SSL_CTX_check_private_key(ctx)) {
+        BIO_printf(bio_err,
+                   "Private key does not match the certificate public key\n");
+        return 0;
+    }
+    if (chain && !SSL_CTX_set1_chain(ctx, chain)) {
+        BIO_printf(bio_err, "error setting certificate chain\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+    if (build_chain && !SSL_CTX_build_cert_chain(ctx, chflags)) {
+        BIO_printf(bio_err, "error building certificate chain\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+    return 1;
+}
+
+int set_enc_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+                           STACK_OF(X509) *chain, int build_chain)
+{
+    int chflags = chain ? SSL_BUILD_CHAIN_FLAG_CHECK : 0;
+
+    if (cert == NULL)
+        return 1;
+    if (SSL_CTX_use_enc_certificate(ctx, cert) <= 0) {
+        BIO_printf(bio_err, "error setting enc certificate\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+
+    if (SSL_CTX_use_enc_PrivateKey(ctx, key) <= 0) {
+        BIO_printf(bio_err, "error setting enc private key\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+
+    /*
+     * Now we know that a key and cert have been set against the SSL context
+     */
+    if (!SSL_CTX_check_private_key(ctx)) {
+        BIO_printf(bio_err,
+                   "Private key does not match the certificate public key\n");
+        return 0;
+    }
+    if (chain && !SSL_CTX_set1_chain(ctx, chain)) {
+        BIO_printf(bio_err, "error setting certificate chain\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+    if (build_chain && !SSL_CTX_build_cert_chain(ctx, chflags)) {
+        BIO_printf(bio_err, "error building certificate chain\n");
+        ERR_print_errors(bio_err);
+        return 0;
+    }
+    return 1;
+}
+#endif
+
 static STRINT_PAIR cert_type_list[] = {
     {"RSA sign", TLS_CT_RSA_SIGN},
     {"DSA sign", TLS_CT_DSS_SIGN},
@@ -239,6 +320,11 @@ static const char *get_sigtype(int nid)
     case EVP_PKEY_DSA:
         return "DSA";
 
+# ifndef OPENSSL_NO_SM2
+    case EVP_PKEY_SM2:
+        return "SM2";
+# endif
+
     case EVP_PKEY_EC:
         return "ECDSA";
 
Index: b/apps/s_client.c
===================================================================
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -477,6 +477,9 @@ typedef enum OPTION_choice {
     OPT_4, OPT_6, OPT_HOST, OPT_PORT, OPT_CONNECT, OPT_BIND, OPT_UNIX,
     OPT_XMPPHOST, OPT_VERIFY, OPT_NAMEOPT,
     OPT_CERT, OPT_CRL, OPT_CRL_DOWNLOAD, OPT_SESS_OUT, OPT_SESS_IN,
+#ifndef OPENSSL_NO_NTLS
+    OPT_SIGN_CERT, OPT_SIGN_KEY, OPT_ENC_CERT, OPT_ENC_KEY,
+#endif
     OPT_CERTFORM, OPT_CRLFORM, OPT_VERIFY_RET_ERROR, OPT_VERIFY_QUIET,
     OPT_BRIEF, OPT_PREXIT, OPT_NO_INTERACTIVE, OPT_CRLF, OPT_QUIET, OPT_NBIO,
     OPT_SSL_CLIENT_ENGINE, OPT_IGN_EOF, OPT_NO_IGN_EOF,
@@ -490,6 +493,12 @@ typedef enum OPTION_choice {
 #endif
     OPT_SSL3, OPT_SSL_CONFIG,
     OPT_TLS1_3, OPT_TLS1_2, OPT_TLS1_1, OPT_TLS1, OPT_DTLS, OPT_DTLS1,
+#ifndef OPENSSL_NO_NTLS
+    OPT_NTLS, OPT_ENABLE_NTLS,
+#endif
+#ifndef OPENSSL_NO_SM2
+    OPT_ENABLE_SM_TLS13_STRICT,
+#endif
     OPT_DTLS1_2, OPT_QUIC, OPT_SCTP, OPT_TIMEOUT, OPT_MTU, OPT_KEYFORM,
     OPT_PASS, OPT_CERT_CHAIN, OPT_KEY, OPT_RECONNECT, OPT_BUILD_CHAIN,
     OPT_NEXTPROTONEG, OPT_ALPN,
@@ -564,12 +573,25 @@ const OPTIONS s_client_options[] = {
     {"fallback_scsv", OPT_FALLBACKSCSV, '-', "Send the fallback SCSV"},
 
     OPT_SECTION("Identity"),
+#ifndef OPENSSL_NO_NTLS
+    {"cert", OPT_CERT, '<',
+     "Certificate file or NTLS signing certificate to use, PEM format assumed"},
+    {"sign_cert", OPT_SIGN_CERT, '<',
+     "NTLS signing certificate file to use, PEM format assumed"},
+    {"enc_cert", OPT_ENC_CERT, '<',
+     "NTLS encryption certificate file to use, PEM format assumed"},
+#else
     {"cert", OPT_CERT, '<', "Client certificate file to use"},
+#endif
     {"certform", OPT_CERTFORM, 'F',
      "Client certificate file format (PEM/DER/P12); has no effect"},
     {"cert_chain", OPT_CERT_CHAIN, '<',
      "Client certificate chain file (in PEM format)"},
     {"build_chain", OPT_BUILD_CHAIN, '-', "Build client certificate chain"},
+#ifndef OPENSSL_NO_NTLS
+    {"sign_key", OPT_SIGN_KEY, 's', "NTLS signing private key file to use"},
+    {"enc_key", OPT_ENC_KEY, 's', "NTLS encryption private key file to use"},
+#endif
     {"key", OPT_KEY, 's', "Private key file to use; default: -cert file"},
     {"keyform", OPT_KEYFORM, 'E', "Key format (ENGINE, other values ignored)"},
     {"pass", OPT_PASS, 's', "Private key and cert file pass phrase source"},
@@ -682,6 +704,13 @@ const OPTIONS s_client_options[] = {
 #ifndef OPENSSL_NO_TLS1_3
     {"tls1_3", OPT_TLS1_3, '-', "Just use TLSv1.3"},
 #endif
+#ifndef OPENSSL_NO_NTLS
+    {"ntls", OPT_NTLS, '-', "Just use NTLS"},
+    {"enable_ntls", OPT_ENABLE_NTLS, '-', "enable ntls"},
+#endif
+#if OPENSSL_NO_SM2
+    {"enable_sm_tls13_strict", OPT_ENABLE_SM_TLS13_STRICT, '-', "enable sm tls13 strict"},
+#endif
 #ifndef OPENSSL_NO_DTLS
     {"dtls", OPT_DTLS, '-', "Use any version of DTLS"},
     {"quic", OPT_QUIC, '-', "Use QUIC"},
@@ -794,10 +823,17 @@ static const OPT_PAIR services[] = {
  (o == OPT_4 || o == OPT_6 || o == OPT_HOST || o == OPT_PORT || o == OPT_CONNECT)
 #define IS_UNIX_FLAG(o) (o == OPT_UNIX)
 
+#ifndef OPENSSL_NO_NTLS
+# define IS_PROT_FLAG(o) \
+ (o == OPT_SSL3 || o == OPT_TLS1 || o == OPT_TLS1_1 || o == OPT_TLS1_2 \
+  || o == OPT_TLS1_3 || o == OPT_DTLS || o == OPT_DTLS1 || o == OPT_DTLS1_2 \
+  || o == OPT_QUIC || o == OPT_NTLS)
+#else
 #define IS_PROT_FLAG(o) \
  (o == OPT_SSL3 || o == OPT_TLS1 || o == OPT_TLS1_1 || o == OPT_TLS1_2 \
   || o == OPT_TLS1_3 || o == OPT_DTLS || o == OPT_DTLS1 || o == OPT_DTLS1_2 \
   || o == OPT_QUIC)
+#endif
 
 /* Free |*dest| and optionally set it to a copy of |source|. */
 static void freeandcopy(char **dest, const char *source)
@@ -844,10 +880,18 @@ int s_client_main(int argc, char **argv)
 {
     BIO *sbio;
     EVP_PKEY *key = NULL;
+#ifndef OPENSSL_NO_NTLS
+    EVP_PKEY *enc_key = NULL;
+    EVP_PKEY *sign_key = NULL;
+#endif
     SSL *con = NULL;
     SSL_CTX *ctx = NULL;
     STACK_OF(X509) *chain = NULL;
     X509 *cert = NULL;
+#ifndef OPENSSL_NO_NTLS
+    X509 *enc_cert = NULL;
+    X509 *sign_cert = NULL;
+#endif
     X509_VERIFY_PARAM *vpm = NULL;
     SSL_EXCERT *exc = NULL;
     SSL_CONF_CTX *cctx = NULL;
@@ -863,6 +907,14 @@ int s_client_main(int argc, char **argv)
     char *proxypassarg = NULL, *proxypass = NULL;
     char *connectstr = NULL, *bindstr = NULL;
     char *cert_file = NULL, *key_file = NULL, *chain_file = NULL;
+#ifndef OPENSSL_NO_NTLS
+    char *enc_cert_file = NULL, *enc_key_file = NULL;
+    char *sign_cert_file = NULL, *sign_key_file = NULL;
+    int enable_ntls = 0;
+#endif
+#ifndef OPENSSL_NO_SM2
+    int enable_sm_tls13_strict = 0;
+#endif
     char *chCApath = NULL, *chCAfile = NULL, *chCAstore = NULL, *host = NULL;
     char *thost = NULL, *tport = NULL;
     char *port = NULL;
@@ -1087,6 +1139,14 @@ int s_client_main(int argc, char **argv)
             if (!set_nameopt(opt_arg()))
                 goto end;
             break;
+#ifndef OPENSSL_NO_NTLS
+        case OPT_SIGN_CERT:
+            sign_cert_file = opt_arg();
+            break;
+        case OPT_ENC_CERT:
+            enc_cert_file = opt_arg();
+            break;
+#endif
         case OPT_CRL:
             crl_file = opt_arg();
             break;
@@ -1323,6 +1383,19 @@ int s_client_main(int argc, char **argv)
 #endif
             isquic = 0;
             break;
+#ifndef OPENSSL_NO_NTLS
+        case OPT_NTLS:
+            meth = NTLS_client_method();
+            break;
+        case OPT_ENABLE_NTLS:
+            enable_ntls = 1;
+            break;
+#endif
+#ifndef OPENSSL_NO_SM2
+        case OPT_ENABLE_SM_TLS13_STRICT:
+            enable_sm_tls13_strict = 1;
+            break;
+#endif
         case OPT_DTLS:
 #ifndef OPENSSL_NO_DTLS
             meth = DTLS_client_method();
@@ -1399,6 +1472,14 @@ int s_client_main(int argc, char **argv)
         case OPT_KEY:
             key_file = opt_arg();
             break;
+#ifndef OPENSSL_NO_NTLS
+        case OPT_SIGN_KEY:
+            sign_key_file = opt_arg();
+            break;
+        case OPT_ENC_KEY:
+            enc_key_file = opt_arg();
+            break;
+#endif
         case OPT_RECONNECT:
             reconnect = 5;
             break;
@@ -1757,6 +1838,46 @@ int s_client_main(int argc, char **argv)
             goto end;
     }
 
+#ifndef OPENSSL_NO_NTLS
+    /* XXX: don't support cert-key bundle at current stage */
+    /* TODO: fix the key format stuff and password stuffs */
+    if (sign_key_file) {
+        sign_key = load_key(sign_key_file, FORMAT_PEM, 0, pass, e,
+                       "NTLS client signing certificate private key file");
+        if (sign_key == NULL) {
+            ERR_print_errors(bio_err);
+            goto end;
+        }
+    }
+
+    if (sign_cert_file) {
+        sign_cert = load_cert(sign_cert_file, FORMAT_PEM,
+                             "NTLS client signing certificate file");
+        if (sign_cert == NULL) {
+            ERR_print_errors(bio_err);
+            goto end;
+        }
+    }
+
+    if (enc_key_file) {
+        enc_key = load_key(enc_key_file, FORMAT_PEM, 0, pass, e,
+                       "NTLS client encryption certificate private key file");
+        if (enc_key == NULL) {
+            ERR_print_errors(bio_err);
+            goto end;
+        }
+    }
+
+    if (enc_cert_file) {
+        enc_cert = load_cert(enc_cert_file, FORMAT_PEM,
+                             "NTLS client encryption certificate file");
+        if (enc_cert == NULL) {
+            ERR_print_errors(bio_err);
+            goto end;
+        }
+    }
+#endif
+
     if (chain_file != NULL) {
         if (!load_certs(chain_file, 0, &chain, pass, "client certificate chain"))
             goto end;
@@ -1811,6 +1932,16 @@ int s_client_main(int argc, char **argv)
         goto end;
     }
 
+#ifndef OPENSSL_NO_NTLS
+    if (enable_ntls) {
+        SSL_CTX_enable_ntls(ctx);
+    }
+#endif
+#ifndef OPENSSL_NO_SM2
+    if (enable_sm_tls13_strict)
+        SSL_CTX_enable_sm_tls13_strict(ctx);
+#endif
+
     SSL_CTX_clear_mode(ctx, SSL_MODE_AUTO_RETRY);
 
     if (sdebug)
@@ -2032,6 +2163,16 @@ int s_client_main(int argc, char **argv)
     if (!set_cert_key_stuff(ctx, cert, key, chain, build_chain))
         goto end;
 
+#ifndef OPENSSL_NO_NTLS
+    if (sign_cert != NULL && sign_key != NULL)
+        if (!set_sign_cert_key_stuff(ctx, sign_cert, sign_key, NULL, 0))
+            goto end;
+
+    if (enc_cert != NULL && enc_key != NULL)
+        if (!set_enc_cert_key_stuff(ctx, enc_cert, enc_key, NULL, 0))
+            goto end;
+#endif
+
     if (!noservername) {
         tlsextcbp.biodebug = bio_err;
         SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
@@ -3325,8 +3466,16 @@ int s_client_main(int argc, char **argv)
     SSL_CTX_free(ctx);
     set_keylog_file(NULL, NULL);
     X509_free(cert);
+#ifndef OPENSSL_NO_NTLS
+    X509_free(enc_cert);
+    X509_free(sign_cert);
+#endif
     sk_X509_CRL_pop_free(crls, X509_CRL_free);
     EVP_PKEY_free(key);
+#ifndef OPENSSL_NO_NTLS
+    EVP_PKEY_free(enc_key);
+    EVP_PKEY_free(sign_key);
+#endif
     OSSL_STACK_OF_X509_free(chain);
     OPENSSL_free(pass);
 #ifndef OPENSSL_NO_SRP
Index: b/apps/s_server.c
===================================================================
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -714,6 +714,14 @@ typedef enum OPTION_choice {
     OPT_UPPER_WWW, OPT_HTTP, OPT_ASYNC, OPT_SSL_CONFIG,
     OPT_MAX_SEND_FRAG, OPT_SPLIT_SEND_FRAG, OPT_MAX_PIPELINES, OPT_READ_BUF,
     OPT_SSL3, OPT_TLS1_3, OPT_TLS1_2, OPT_TLS1_1, OPT_TLS1, OPT_DTLS, OPT_DTLS1,
+#ifndef OPENSSL_NO_NTLS
+    OPT_NTLS, OPT_ENC_CERT, OPT_ENC_KEY, OPT_SIGN_CERT, OPT_SIGN_KEY,
+    OPT_ENABLE_NTLS, OPT_ENC_CERTFORM, OPT_SIGN_CERTFORM,
+    OPT_ENC_KEYFORM, OPT_SIGN_KEYFORM,
+#endif
+#ifndef OPENSSL_NO_SM2
+    OPT_ENABLE_SM_TLS13_STRICT,
+#endif
     OPT_DTLS1_2, OPT_SCTP, OPT_TIMEOUT, OPT_MTU, OPT_LISTEN, OPT_STATELESS,
     OPT_ID_PREFIX, OPT_SERVERNAME, OPT_SERVERNAME_FATAL,
     OPT_CERT2, OPT_KEY2, OPT_NEXTPROTONEG, OPT_ALPN, OPT_SENDFILE,
@@ -793,6 +801,22 @@ const OPTIONS s_server_options[] = {
     {"pass", OPT_PASS, 's', "Private key and cert file pass phrase source"},
     {"dcert", OPT_DCERT, '<',
      "Second server certificate file to use (usually for DSA)"},
+#ifndef OPENSSL_NO_NTLS
+    {"enc_cert", OPT_ENC_CERT, '<',
+     "NTLS encryption certificate file to use, PEM format assumed"},
+    {"sign_cert", OPT_SIGN_CERT, '<',
+     "NTLS signing certificate file to use, PEM format assumed"},
+    {"enc_key", OPT_ENC_KEY, 's', "NTLS encryption private key file to use"},
+    {"sign_key", OPT_SIGN_KEY, 's', "NTLS signing private key file to use"},
+    {"enc_certform", OPT_ENC_CERTFORM, 'F',
+     "Enc Certificate format (PEM or DER) PEM default"},
+    {"sign_certform", OPT_SIGN_CERTFORM, 'F',
+     "Sign Certificate format (PEM or DER) PEM default"},
+    {"enc_keyform", OPT_ENC_KEYFORM, 'f',
+     "Enc Key format (PEM, DER or ENGINE) PEM default"},
+    {"sign_keyform", OPT_SIGN_KEYFORM, 'f',
+     "Sign Key format (PEM, DER or ENGINE) PEM default"},
+#endif
     {"dcertform", OPT_DCERTFORM, 'F',
      "Second server certificate file format (PEM/DER/P12); has no effect"},
     {"dcert_chain", OPT_DCERT_CHAIN, '<',
@@ -945,6 +969,13 @@ const OPTIONS s_server_options[] = {
 #ifndef OPENSSL_NO_TLS1_3
     {"tls1_3", OPT_TLS1_3, '-', "just talk TLSv1.3"},
 #endif
+#ifndef OPENSSL_NO_NTLS
+    {"ntls", OPT_NTLS, '-', "Just talk NTLS"},
+    {"enable_ntls", OPT_ENABLE_NTLS, '-', "enable ntls"},
+#endif
+#ifndef OPENSSL_NO_SM2
+    {"enable_sm_tls13_strict", OPT_ENABLE_SM_TLS13_STRICT, '-', "enable sm tls13 strict"},
+#endif
 #ifndef OPENSSL_NO_DTLS
     {"dtls", OPT_DTLS, '-', "Use any DTLS version"},
     {"listen", OPT_LISTEN, '-',
@@ -986,9 +1017,15 @@ const OPTIONS s_server_options[] = {
     {NULL}
 };
 
-#define IS_PROT_FLAG(o) \
+#ifndef OPENSSL_NO_NTLS
+# define IS_PROT_FLAG(o) \
+ (o == OPT_SSL3 || o == OPT_TLS1 || o == OPT_TLS1_1 || o == OPT_TLS1_2 \
+  || o == OPT_TLS1_3 || o == OPT_DTLS || o == OPT_DTLS1 || o == OPT_DTLS1_2 || o == OPT_NTLS)
+#else
+# define IS_PROT_FLAG(o) \
  (o == OPT_SSL3 || o == OPT_TLS1 || o == OPT_TLS1_1 || o == OPT_TLS1_2 \
   || o == OPT_TLS1_3 || o == OPT_DTLS || o == OPT_DTLS1 || o == OPT_DTLS1_2)
+#endif
 
 int s_server_main(int argc, char *argv[])
 {
@@ -1055,6 +1092,22 @@ int s_server_main(int argc, char *argv[]
     const char *s_cert_file = TEST_CERT, *s_key_file = NULL, *s_chain_file = NULL;
     const char *s_cert_file2 = TEST_CERT2, *s_key_file2 = NULL;
     char *s_dcert_file = NULL, *s_dkey_file = NULL, *s_dchain_file = NULL;
+#ifndef OPENSSL_NO_NTLS
+    char *s_enc_cert_file = NULL, *s_enc_key_file = NULL;
+    char *s_sign_cert_file = NULL, *s_sign_key_file = NULL;
+    EVP_PKEY *s_enc_key = NULL;
+    EVP_PKEY *s_sign_key = NULL;
+    X509 *s_enc_cert = NULL;
+    X509 *s_sign_cert = NULL;
+    int s_enc_cert_format = FORMAT_PEM;
+    int s_sign_cert_format = FORMAT_PEM;
+    int s_enc_key_format = FORMAT_PEM;
+    int s_sign_key_format = FORMAT_PEM;
+    int enable_ntls = 0;
+#endif
+#ifndef OPENSSL_NO_SM2
+    int enable_sm_tls13_strict = 0;
+#endif
 #ifndef OPENSSL_NO_OCSP
     int s_tlsextstatus = 0;
 #endif
@@ -1257,6 +1310,36 @@ int s_server_main(int argc, char *argv[]
         case OPT_DCERT:
             s_dcert_file = opt_arg();
             break;
+#ifndef OPENSSL_NO_NTLS
+        case OPT_ENC_CERT:
+            s_enc_cert_file = opt_arg();
+            break;
+        case OPT_ENC_KEY:
+            s_enc_key_file = opt_arg();
+            break;
+        case OPT_SIGN_CERT:
+            s_sign_cert_file = opt_arg();
+            break;
+        case OPT_SIGN_KEY:
+            s_sign_key_file = opt_arg();
+            break;
+        case OPT_ENC_CERTFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &s_enc_cert_format))
+                goto opthelp;
+            break;
+        case OPT_SIGN_CERTFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &s_sign_cert_format))
+                goto opthelp;
+            break;
+        case OPT_ENC_KEYFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_enc_key_format))
+                goto opthelp;
+            break;
+        case OPT_SIGN_KEYFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_sign_key_format))
+                goto opthelp;
+            break;
+#endif
         case OPT_DKEYFORM:
             if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_dkey_format))
                 goto opthelp;
@@ -1540,6 +1623,19 @@ int s_server_main(int argc, char *argv[]
             socket_type = SOCK_DGRAM;
 #endif
             break;
+#ifndef OPENSSL_NO_NTLS
+        case OPT_NTLS:
+            meth = NTLS_server_method();
+            break;
+        case OPT_ENABLE_NTLS:
+            enable_ntls = 1;
+            break;
+#endif
+#ifndef OPENSSL_NO_SM2
+        case OPT_ENABLE_SM_TLS13_STRICT:
+            enable_sm_tls13_strict = 1;
+            break;
+#endif
         case OPT_SCTP:
 #ifndef OPENSSL_NO_SCTP
             protocol = IPPROTO_SCTP;
@@ -1787,6 +1883,49 @@ int s_server_main(int argc, char *argv[]
         goto end;
 
     if (nocert == 0) {
+#ifndef OPENSSL_NO_NTLS
+        /* XXX: don't support cert-key bundle at current stage */
+        if (s_enc_key_file) {
+            s_enc_key = load_key(s_enc_key_file, s_enc_key_format, 0, pass, engine,
+                                 "NTLS server encryption certificate private key file");
+            if (s_enc_key == NULL) {
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+        }
+
+        if (s_enc_cert_file) {
+            s_enc_cert = load_cert(s_enc_cert_file, s_enc_cert_format,
+                                   "NTLS server encryption certificate file");
+            if (s_enc_cert == NULL) {
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+        }
+
+        if (s_sign_key_file) {
+            s_sign_key = load_key(s_sign_key_file, s_sign_key_format, 0, pass, engine,
+                                  "NTLS server signing certificate private key file");
+            if (s_sign_key == NULL) {
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+        }
+
+        if (s_sign_cert_file) {
+            s_sign_cert = load_cert(s_sign_cert_file, s_sign_cert_format,
+                                    "NTLS server signing certificate file");
+            if (s_sign_cert == NULL) {
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+        }
+
+        if (s_sign_cert_file != NULL && !strcmp(s_cert_file, TEST_CERT)) {
+            /* Don't try to load the default cert if NTLS certs are load */
+            goto skip;
+        }
+#endif
         s_key = load_key(s_key_file, s_key_format, 0, pass, engine,
                          "server certificate private key");
         if (s_key == NULL)
@@ -1797,6 +1936,9 @@ int s_server_main(int argc, char *argv[]
 
         if (s_cert == NULL)
             goto end;
+#ifndef OPENSSL_NO_NTLS
+skip:
+#endif
         if (s_chain_file != NULL) {
             if (!load_certs(s_chain_file, 0, &s_chain, NULL,
                             "server certificate chain"))
@@ -1901,6 +2043,14 @@ int s_server_main(int argc, char *argv[]
         ERR_print_errors(bio_err);
         goto end;
     }
+#ifndef OPENSSL_NO_NTLS
+    if (enable_ntls)
+        SSL_CTX_enable_ntls(ctx);
+#endif
+#ifndef OPENSSL_NO_SM2
+    if (enable_sm_tls13_strict)
+        SSL_CTX_enable_sm_tls13_strict(ctx);
+#endif
 
     SSL_CTX_clear_mode(ctx, SSL_MODE_AUTO_RETRY);
 
@@ -2158,6 +2308,14 @@ int s_server_main(int argc, char *argv[]
     if (!set_cert_key_stuff(ctx, s_cert, s_key, s_chain, build_chain))
         goto end;
 
+#ifndef OPENSSL_NO_NTLS
+    if (!set_sign_cert_key_stuff(ctx, s_sign_cert, s_sign_key, NULL, 0))
+        goto end;
+
+    if (!set_enc_cert_key_stuff(ctx, s_enc_cert, s_enc_key, s_chain, build_chain))
+        goto end;
+#endif
+
     if (s_serverinfo_file != NULL
         && !SSL_CTX_use_serverinfo_file(ctx, s_serverinfo_file)) {
         ERR_print_errors(bio_err);
@@ -2329,6 +2487,12 @@ int s_server_main(int argc, char *argv[]
     X509_free(s_dcert);
     EVP_PKEY_free(s_key);
     EVP_PKEY_free(s_dkey);
+#ifndef OPENSSL_NO_NTLS
+    X509_free(s_sign_cert);
+    X509_free(s_enc_cert);
+    EVP_PKEY_free(s_enc_key);
+    EVP_PKEY_free(s_sign_key);
+#endif
     OSSL_STACK_OF_X509_free(s_chain);
     OSSL_STACK_OF_X509_free(s_dchain);
     OPENSSL_free(pass);
Index: b/crypto/asn1/i2d_evp.c
===================================================================
--- a/crypto/asn1/i2d_evp.c
+++ b/crypto/asn1/i2d_evp.c
@@ -138,6 +138,9 @@ int i2d_PublicKey(const EVP_PKEY *a, uns
         return i2d_DSAPublicKey(EVP_PKEY_get0_DSA(a), pp);
 #endif
 #ifndef OPENSSL_NO_EC
+# ifndef OPENSSL_NO_SM2
+    case EVP_PKEY_SM2:
+# endif
     case EVP_PKEY_EC:
         return i2o_ECPublicKey(EVP_PKEY_get0_EC_KEY(a), pp);
 #endif
Index: b/crypto/err/openssl.txt
===================================================================
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -1285,6 +1285,7 @@ SM2_R_INVALID_ENCODING:104:invalid encod
 SM2_R_INVALID_FIELD:105:invalid field
 SM2_R_INVALID_PRIVATE_KEY:113:invalid private key
 SM2_R_NO_PARAMETERS_SET:109:no parameters set
+SM2_R_POINT_ARITHMETIC_FAILURE:114:point arithmetic failure
 SM2_R_USER_ID_TOO_LARGE:106:user id too large
 SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY:291:\
 	application data after close notify
@@ -1438,6 +1439,7 @@ SSL_R_LIBRARY_HAS_NO_CIPHERS:161:library
 SSL_R_MAXIMUM_ENCRYPTED_PKTS_REACHED:395:maximum encrypted pkts reached
 SSL_R_MISSING_DSA_SIGNING_CERT:165:missing dsa signing cert
 SSL_R_MISSING_ECDSA_SIGNING_CERT:381:missing ecdsa signing cert
+SSL_R_MISSING_ENC_CERTIFICATE:412:missing encryption certificate
 SSL_R_MISSING_FATAL:256:missing fatal
 SSL_R_MISSING_PARAMETERS:290:missing parameters
 SSL_R_MISSING_PSK_KEX_MODES_EXTENSION:310:missing psk kex modes extension
Index: b/crypto/objects/objects.txt
===================================================================
--- a/crypto/objects/objects.txt
+++ b/crypto/objects/objects.txt
@@ -1791,6 +1791,8 @@ id-pkinit 5                     : pkInit
                             : KxGOST       : kx-gost
                             : KxGOST18     : kx-gost18
                             : KxANY        : kx-any
+                            : KxSM2        : kx-sm2
+                            : KxSM2DHE     : kx-sm2dhe
 
 # NIDs for cipher authentication
                             : AuthRSA      : auth-rsa
@@ -1802,6 +1804,7 @@ id-pkinit 5                     : pkInit
                             : AuthSRP      : auth-srp
                             : AuthNULL     : auth-null
                             : AuthANY      : auth-any
+                            : AuthSM2      : auth-sm2
 # NID for Poly1305
                             : Poly1305     : poly1305
 # NID for SipHash
Index: b/crypto/sm2/build.info
===================================================================
--- a/crypto/sm2/build.info
+++ b/crypto/sm2/build.info
@@ -1,5 +1,5 @@
 LIBS=../../libcrypto
 SOURCE[../../libcrypto]=\
-        sm2_sign.c sm2_crypt.c sm2_err.c sm2_key.c
+        sm2_sign.c sm2_crypt.c sm2_err.c sm2_key.c sm2_kmeth.c
 
 
Index: b/crypto/sm2/sm2_kmeth.c
===================================================================
--- /dev/null
+++ b/crypto/sm2/sm2_kmeth.c
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2022-2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.apache.org/licenses/LICENSE-2.0
+ */
+
+#include "internal/deprecated.h"
+
+#include "internal/cryptlib.h"
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+#include <openssl/bn.h>
+#include "crypto/sm2.h"
+#include "crypto/ec.h" /* ecdh_KDF_X9_63() */
+#include "crypto/sm2err.h"
+
+
+int SM2_compute_key(void *out, size_t outlen, int initiator,
+                    const uint8_t *peer_id, size_t peer_id_len,
+                    const uint8_t *self_id, size_t self_id_len,
+                    const EC_KEY *peer_ecdhe_key, const EC_KEY *self_ecdhe_key,
+                    const EC_KEY *peer_pub_key, const EC_KEY *self_eckey,
+                    const EVP_MD *md, OSSL_LIB_CTX *libctx,
+                    const char *propq)
+{
+    BN_CTX *ctx = NULL;
+    EC_POINT *UorV = NULL;
+    const EC_POINT *Rs, *Rp;
+    BIGNUM *Xuv = NULL, *Yuv = NULL, *Xs = NULL, *Xp = NULL;
+    BIGNUM *h = NULL, *t = NULL, *two_power_w = NULL, *order = NULL;
+    const BIGNUM *priv_key, *r;
+    const EC_GROUP *group;
+    int w;
+    int ret = 0;
+    size_t buflen = 0, md_len;
+    unsigned char *buf = NULL;
+    size_t field_len, idx = 0;
+
+    if (peer_id == NULL || self_id == NULL || peer_ecdhe_key == NULL
+            || self_ecdhe_key == NULL || peer_pub_key == NULL
+            || self_eckey == NULL || md == NULL) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (outlen > INT_MAX) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    priv_key = EC_KEY_get0_private_key(self_eckey);
+    if (priv_key == NULL) {
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_PRIVATE_KEY);
+        return 0;
+    }
+
+    Rs = EC_KEY_get0_public_key(self_ecdhe_key);
+    Rp = EC_KEY_get0_public_key(peer_ecdhe_key);
+    r = EC_KEY_get0_private_key(self_ecdhe_key);
+
+    if (Rs == NULL || Rp == NULL || r == NULL) {
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_PRIVATE_KEY);
+        return 0;
+    }
+
+    ctx = BN_CTX_new_ex(libctx);
+    if (ctx == NULL) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    BN_CTX_start(ctx);
+    Xuv = BN_CTX_get(ctx);
+    Yuv = BN_CTX_get(ctx);
+    Xs = BN_CTX_get(ctx);
+    Xp = BN_CTX_get(ctx);
+    h = BN_CTX_get(ctx);
+    t = BN_CTX_get(ctx);
+    two_power_w = BN_CTX_get(ctx);
+    order = BN_CTX_get(ctx);
+
+    if (order == NULL) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    group = EC_KEY_get0_group(self_eckey);
+
+    if (!EC_GROUP_get_order(group, order, ctx)
+            || !EC_GROUP_get_cofactor(group, h, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    w = (BN_num_bits(order) + 1) / 2 - 1;
+    if (!BN_lshift(two_power_w, BN_value_one(), w)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    /*Third: Caculate -- X =  2 ^ w + (x & (2 ^ w - 1)) = 2 ^ w + (x mod 2 ^ w)*/
+    UorV = EC_POINT_new(group);
+    if (UorV == NULL) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    /* Test peer public key On curve */
+    if (!EC_POINT_is_on_curve(group, Rp, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    /* Get x */
+    if (!EC_POINT_get_affine_coordinates(group, Rs, Xs, NULL, ctx)
+            || !EC_POINT_get_affine_coordinates(group, Rp, Xp, NULL, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    /*x mod 2 ^ w*/
+    /*Caculate Self x*/
+    if (!BN_nnmod(Xs, Xs, two_power_w, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    if (!BN_add(Xs, Xs, two_power_w)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    /*Caculate Peer x*/
+    if (!BN_nnmod(Xp, Xp, two_power_w, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    if (!BN_add(Xp, Xp, two_power_w)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    /*Forth: Caculate t*/
+    if (!BN_mod_mul(t, Xs, r, order, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    if (!BN_mod_add(t, t, priv_key, order, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    /*Fifth: Caculate V or U*/
+    if (!BN_mul(t, t, h, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    /* [x]R */
+    if (!EC_POINT_mul(group, UorV, NULL, Rp, Xp, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    /* P + [x]R */
+    if (!EC_POINT_add(group, UorV, UorV,
+                      EC_KEY_get0_public_key(peer_pub_key), ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    if (!EC_POINT_mul(group, UorV, NULL, UorV, t, ctx)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    if (EC_POINT_is_at_infinity(group, UorV)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    /*Sixth: Caculate Key -- Need Xuorv, Yuorv, Z_A, Z_B, klen*/
+    if (!EC_POINT_get_affine_coordinates(group, UorV, Xuv, Yuv, ctx)) {
+        ERR_raise(ERR_LIB_SM2, SM2_R_POINT_ARITHMETIC_FAILURE);
+        goto err;
+    }
+
+    field_len = ((size_t)EC_GROUP_get_degree(group) + 7) / 8;
+    md_len = EVP_MD_size(md);
+
+    /* Xuorv || Yuorv || Z_A || Z_B */
+    buflen = field_len * 2 + md_len * 2 ;
+
+    buf = OPENSSL_secure_malloc(buflen);
+    if (buf == NULL) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    /*1 : Get public key for UorV, Notice: the first byte is a tag, not a valid char*/
+    if (BN_bn2binpad(Xuv, buf, field_len) < 0
+            || BN_bn2binpad(Yuv, buf + field_len, field_len) < 0) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto err;
+    }
+
+    idx += field_len * 2;
+
+    if (initiator) {
+        if (!ossl_sm2_compute_z_digest((uint8_t *)(buf + idx), md,
+                                       self_id, self_id_len,
+                                       self_eckey))
+            goto err;
+
+        idx += md_len;
+    }
+
+    if (!ossl_sm2_compute_z_digest((uint8_t *)(buf + idx), md,
+                                   peer_id, peer_id_len,
+                                   peer_pub_key))
+        goto err;
+
+    idx += md_len;
+
+    if (!initiator) {
+        if (!ossl_sm2_compute_z_digest((uint8_t *)(buf + idx), md,
+                                       self_id, self_id_len,
+                                       self_eckey))
+            goto err;
+
+        idx += md_len;
+    }
+
+    if (!ossl_ecdh_kdf_X9_63(out, outlen, buf, idx, NULL, 0, md, libctx,
+                             propq)) {
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    ret = outlen;
+
+ err:
+    EC_POINT_free(UorV);
+    OPENSSL_secure_clear_free(buf, buflen);
+    if (ctx != NULL)
+        BN_CTX_end(ctx);
+    BN_CTX_free(ctx);
+
+    return ret;
+}
Index: b/crypto/sm4/sm4.c
===================================================================
--- a/crypto/sm4/sm4.c
+++ b/crypto/sm4/sm4.c
@@ -220,6 +220,7 @@ static uint32_t SM4_SBOX_T3[256] = {
     0x4C353579, 0x208080A0, 0x78E5E59D, 0xEDBBBB56, 0x5E7D7D23, 0x3EF8F8C6,
     0xD45F5F8B, 0xC82F2FE7, 0x39E4E4DD, 0x49212168};
 
+
 static ossl_inline uint32_t rotl(uint32_t a, uint8_t n)
 {
     return (a << n) | (a >> (32 - n));
Index: b/doc/man1/openssl-s_client.pod.in
===================================================================
--- a/doc/man1/openssl-s_client.pod.in
+++ b/doc/man1/openssl-s_client.pod.in
@@ -30,6 +30,8 @@ B<openssl> B<s_client>
 [B<-verifyCApath> I<dir>]
 [B<-verifyCAstore> I<uri>]
 [B<-cert> I<filename>]
+[B<-sign_cert> I<filename>]
+[B<-enc_cert> I<filename>]
 [B<-certform> B<DER>|B<PEM>|B<P12>]
 [B<-cert_chain> I<filename>]
 [B<-build_chain>]
@@ -37,6 +39,8 @@ B<openssl> B<s_client>
 [B<-CRLform> B<DER>|B<PEM>]
 [B<-crl_download>]
 [B<-key> I<filename>|I<uri>]
+[B<-sign_key> I<filename>]
+[B<-enc_key> I<filename>]
 [B<-keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>]
 [B<-pass> I<arg>]
 [B<-chainCAfile> I<filename>]
@@ -65,6 +69,8 @@ B<openssl> B<s_client>
 [B<-keymatexportlen> I<len>]
 [B<-msgfile> I<filename>]
 [B<-nbio_test>]
+[B<-ntls>]
+[B<-enable_ntls>]
 [B<-state>]
 [B<-nbio>]
 [B<-crlf>]
@@ -251,6 +257,20 @@ The default is not to use a certificate.
 
 The chain for the client certificate may be specified using B<-cert_chain>.
 
+=item B<-sign_cert> I<filename>
+
+The client signature certificate to use. Except SM2DHE key exchange, client
+signature cert is required if one is requested by the server, the default is
+not to use a certificate. For SM2DHE key exchange, client must send signature
+and encryption certificates as required.
+
+=item B<-enc_cert> I<filename>
+
+The client encryption certificate to use. Except SM2DHE key exchange, client
+encryption cert is required if one is requested by the server, the default is
+not to use a certificate. For SM2DHE key exchange, client must send signature
+and encryption certificate as required.
+
 =item B<-certform> B<DER>|B<PEM>|B<P12>
 
 The client certificate file format to use; unspecified by default.
@@ -287,6 +307,14 @@ of CRL is limited by L<X509_CRL_load_htt
 The client private key to use.
 If not specified then the certificate file will be used to read also the key.
 
+=item B<-sign_key> I<filename>
+
+The signature private key to use.
+
+=item B<-enc_key> I<filename>
+
+The encryption private key to use.
+
 =item B<-keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>
 
 The key format; unspecified by default.
@@ -448,6 +476,14 @@ established.
 
 This flag can be used to run the client in a non-interactive mode.
 
+=item B<-ntls>
+
+Just talk NTLS protocol.
+
+=item B<-enable_ntls>
+
+Enable NTLS protocol.
+
 =item B<-state>
 
 Prints out the SSL session states.
Index: b/doc/man1/openssl-s_server.pod.in
===================================================================
--- a/doc/man1/openssl-s_server.pod.in
+++ b/doc/man1/openssl-s_server.pod.in
@@ -20,13 +20,21 @@ B<openssl> B<s_server>
 [B<-Verify> I<int>]
 [B<-cert> I<infile>]
 [B<-cert2> I<infile>]
+[B<-sign_cert> I<infile>]
+[B<-enc_cert> I<infile>]
 [B<-certform> B<DER>|B<PEM>|B<P12>]
+[B<-sign_certform> B<DER>|B<PEM>|B<P12>]
+[B<-enc_certform> B<DER>|B<PEM>|B<P12>]
 [B<-cert_chain> I<infile>]
 [B<-build_chain>]
 [B<-serverinfo> I<val>]
 [B<-key> I<filename>|I<uri>]
 [B<-key2> I<filename>|I<uri>]
+[B<-sign_key> I<filename>]
+[B<-enc_key> I<filename>]
 [B<-keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>]
+[B<-sign_keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>]
+[B<-enc_keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>]
 [B<-pass> I<val>]
 [B<-dcert> I<infile>]
 [B<-dcertform> B<DER>|B<PEM>|B<P12>]
@@ -39,6 +47,8 @@ B<openssl> B<s_server>
 [B<-debug>]
 [B<-msg>]
 [B<-msgfile> I<outfile>]
+[B<-ntls>]
+[B<-enable_ntls>]
 [B<-state>]
 [B<-nocert>]
 [B<-quiet>]
@@ -226,11 +236,29 @@ for example the DSS cipher suites requir
 
 The certificate file to use for servername; default is C<server2.pem>.
 
+=item B<-sign_cert> I<infile>
+
+The signature certificate to use.
+
+=item B<-enc_cert> I<infile>
+
+The encryption certificate to use.
+
 =item B<-certform> B<DER>|B<PEM>|B<P12>
 
 The server certificate file format; unspecified by default.
 See L<openssl-format-options(1)> for details.
 
+=item B<-sign_certform> B<DER>|B<PEM>|B<P12>
+
+The server signature certificate file format; unspecified by default.
+See L<openssl-format-options(1)> for details.
+
+=item B<-enc_certform> B<DER>|B<PEM>|B<P12>
+
+The server encryption certificate file format; unspecified by default.
+See L<openssl-format-options(1)> for details.
+
 =item B<-cert_chain>
 
 A file or URI of untrusted certificates to use when attempting to build the
@@ -259,11 +287,29 @@ be used.
 
 The private Key file to use for servername if not given via B<-cert2>.
 
+=item B<-sign_key> I<filename>
+
+The signature private key to use.
+
+=item B<-enc_key> I<filename>
+
+The encryption private key to use.
+
 =item B<-keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>
 
 The key format; unspecified by default.
 See L<openssl-format-options(1)> for details.
 
+=item B<-sign_keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>
+
+The format of signature key; unspecified by default.
+See L<openssl-format-options(1)> for details.
+
+=item B<-enc_keyform> B<DER>|B<PEM>|B<P12>|B<ENGINE>
+
+The format of encryption key; unspecified by default.
+See L<openssl-format-options(1)> for details.
+
 =item B<-pass> I<val>
 
 The private key and certificate file password source.
@@ -332,6 +378,14 @@ Show all protocol messages with hex dump
 
 File to send output of B<-msg> or B<-trace> to, default standard output.
 
+=item B<-ntls>
+
+Only use NTLS protocol.
+
+=item B<-enable_ntls>
+
+Enable NTLS protocol, including TLCP and GM/T 0024-2014.
+
 =item B<-state>
 
 Prints the SSL session states.
Index: b/doc/man3/BIO_get_ex_new_index.pod
===================================================================
--- a/doc/man3/BIO_get_ex_new_index.pod
+++ b/doc/man3/BIO_get_ex_new_index.pod
@@ -22,7 +22,9 @@ UI_set_app_data, UI_get_app_data,
 X509_STORE_CTX_get_ex_new_index, X509_STORE_CTX_set_ex_data, X509_STORE_CTX_get_ex_data,
 X509_STORE_CTX_set_app_data, X509_STORE_CTX_get_app_data,
 X509_STORE_get_ex_new_index, X509_STORE_set_ex_data, X509_STORE_get_ex_data,
-X509_get_ex_new_index, X509_set_ex_data, X509_get_ex_data
+X509_get_ex_new_index, X509_set_ex_data, X509_get_ex_data,
+SSL_SESSION_get_ref, BABASSL_SESSION_get_ref,
+SSL_set_SESSION_CTX, BABASSL_set_SESSION_CTX
 - application-specific data
 
 =head1 SYNOPSIS
@@ -70,6 +72,14 @@ see L<openssl_user_macros(7)>:
  int ENGINE_set_ex_data(ENGINE *type, int idx, void *arg);
  void *ENGINE_get_ex_data(ENGINE *type, int idx);
 
+ #include <openssl/ssl.h>
+
+ #define SSL_SESSION_get_ref BABASSL_SESSION_get_ref
+ int BABASSL_SESSION_get_ref(SSL_SESSION *sess);
+
+ #define SSL_set_SESSION_CTX BABASSL_set_SESSION_CTX
+ SSL_CTX *BABASSL_set_SESSION_CTX(SSL *ssl, SSL_CTX *ctx);
+
 =head1 DESCRIPTION
 
 In the description here, I<TYPE> is used a placeholder
@@ -102,6 +112,14 @@ B<idx> set to zero.
 TYPE_get_app_data() is a macro that invokes TYPE_get_ex_data() with
 B<idx> set to zero.
 
+SSL_SESSION_get_ref() is a macro that invokes BABASSL_SESSION_get_ref() with
+the SSL_SESSION B<sess>.
+
+SSL_set_SESSION_CTX() is a macro that invokes BABASSL_set_SESSION_CTX() with
+B<ctx> set to session context within B<ssl>. If B<ctx> and the session context
+on the B<ssl> are the same, nothing is done. If B<ctx> is NULL, the current
+session context is returned, otherwise B<ctx> is returned.
+
 =head1 RETURN VALUES
 
 TYPE_get_ex_new_index() returns a new index on success or -1 on error.
@@ -110,6 +128,11 @@ TYPE_set_ex_data() returns 1 on success
 
 TYPE_get_ex_data() returns the application data or NULL if an error occurred.
 
+SSL_SESSION_get_ref() returns the reference count of the session.
+
+SSL_set_SESSION_CTX() returns the session context which has been set if B<ctx>
+is not NULL, or the current session context if B<ctx> is NULL.
+
 =head1 SEE ALSO
 
 L<CRYPTO_get_ex_new_index(3)>.
Index: b/doc/man3/ERR_print_errors.pod
===================================================================
--- a/doc/man3/ERR_print_errors.pod
+++ b/doc/man3/ERR_print_errors.pod
@@ -2,7 +2,8 @@
 
 =head1 NAME
 
-ERR_print_errors, ERR_print_errors_fp, ERR_print_errors_cb
+ERR_print_errors, ERR_print_errors_fp, ERR_print_errors_cb,
+SSL_debug, BABASSL_debug
 - print error messages
 
 =head1 SYNOPSIS
@@ -14,6 +15,10 @@ ERR_print_errors, ERR_print_errors_fp, E
  void ERR_print_errors_cb(int (*cb)(const char *str, size_t len, void *u),
                           void *u);
 
+ #include <openssl/ssl.h>
+ #define SSL_debug BABASSL_debug
+ void BABASSL_debug(SSL *s, unsigned char *str, int len);
+
 =head1 DESCRIPTION
 
 ERR_print_errors() is a convenience function that prints the error
@@ -38,10 +43,15 @@ text message> if one was set for the res
 If there is no text string registered for the given error code,
 the error string will contain the numeric code.
 
+SSL_debug() is a macro that calls BABASSL_debug(), prints B<str> with the
+length B<len>.
+
 =head1 RETURN VALUES
 
 ERR_print_errors() and ERR_print_errors_fp() return no values.
 
+SSL_debug() returns no value.
+
 =head1 SEE ALSO
 
 L<ERR_error_string(3)>,
Index: b/doc/man3/SSL_CIPHER_get_name.pod
===================================================================
--- a/doc/man3/SSL_CIPHER_get_name.pod
+++ b/doc/man3/SSL_CIPHER_get_name.pod
@@ -16,7 +16,15 @@ SSL_CIPHER_get_auth_nid,
 SSL_CIPHER_is_aead,
 SSL_CIPHER_find,
 SSL_CIPHER_get_id,
-SSL_CIPHER_get_protocol_id
+SSL_CIPHER_get_protocol_id,
+SSL_CIPHER_get_mkey,
+SSL_CIPHER_get_auth,
+SSL_CIPHER_get_enc,
+SSL_CIPHER_get_mac,
+BABASSL_CIPHER_get_mkey,
+BABASSL_CIPHER_get_auth,
+BABASSL_CIPHER_get_enc,
+BABASSL_CIPHER_get_mac
 - get SSL_CIPHER properties
 
 =head1 SYNOPSIS
@@ -39,6 +47,16 @@ SSL_CIPHER_get_protocol_id
  uint32_t SSL_CIPHER_get_id(const SSL_CIPHER *c);
  uint32_t SSL_CIPHER_get_protocol_id(const SSL_CIPHER *c);
 
+ #define SSL_CIPHER_get_mkey BABASSL_CIPHER_get_mkey
+ #define SSL_CIPHER_get_auth BABASSL_CIPHER_get_auth
+ #define SSL_CIPHER_get_enc  BABASSL_CIPHER_get_enc
+ #define SSL_CIPHER_get_mac  BABASSL_CIPHER_get_mac
+
+ unsigned long BABASSL_CIPHER_get_mkey(const SSL_CIPHER *c);
+ unsigned long BABASSL_CIPHER_get_auth(const SSL_CIPHER *c);
+ unsigned long BABASSL_CIPHER_get_enc(const SSL_CIPHER *c);
+ unsigned long BABASSL_CIPHER_get_mac(const SSL_CIPHER *c);
+
 =head1 DESCRIPTION
 
 SSL_CIPHER_get_name() returns a pointer to the name of B<cipher>. If the
@@ -107,6 +125,17 @@ not the same as the IANA-specific ID.
 SSL_CIPHER_get_protocol_id() returns the two-byte ID used in the TLS protocol of the given
 cipher B<c>.
 
+BABASSL_CIPHER_get_mkey() returns the key exchange algorithm of the given
+cipher B<c>.
+
+BABASSL_CIPHER_get_auth() returns the authentication algorithm of the given
+cipher B<c>.
+
+BABASSL_CIPHER_get_enc() returns the symmetric encryption algorithm of the
+given cipher B<c>.
+
+BABASSL_CIPHER_get_mac() return the MAC algorithm of the given cipher B<c>.
+
 SSL_CIPHER_description() returns a textual description of the cipher used
 into the buffer B<buf> of length B<len> provided.  If B<buf> is provided, it
 must be at least 128 bytes. If B<buf> is NULL it will be allocated using
@@ -180,6 +209,10 @@ SSL_CIPHER_get_id() returns a 4-byte int
 SSL_CIPHER_get_protocol_id() returns a 2-byte integer representing the TLS
 protocol-specific ID.
 
+BABASSL_CIPHER_get_mkey(), BABASSL_CIPHER_get_auth(),
+BABASSL_CIPHER_get_enc() and BABASSL_CIPHER_get_mkey() return a unsigned long
+integer representing the algorithm respectively.
+
 =head1 SEE ALSO
 
 L<ssl(7)>, L<SSL_get_current_cipher(3)>,
Index: b/doc/man3/SSL_CTX_new.pod
===================================================================
--- a/doc/man3/SSL_CTX_new.pod
+++ b/doc/man3/SSL_CTX_new.pod
@@ -10,7 +10,7 @@ TLSv1_1_client_method, TLS_method, TLS_s
 SSLv23_method, SSLv23_server_method, SSLv23_client_method, DTLS_method,
 DTLS_server_method, DTLS_client_method, DTLSv1_method, DTLSv1_server_method,
 DTLSv1_client_method, DTLSv1_2_method, DTLSv1_2_server_method,
-DTLSv1_2_client_method
+DTLSv1_2_client_method, NTLS_method, NTLS_client_method, NTLS_server_method
 - create a new SSL_CTX object as framework for TLS/SSL or DTLS enabled
 functions
 
@@ -27,6 +27,12 @@ functions
  const SSL_METHOD *TLS_server_method(void);
  const SSL_METHOD *TLS_client_method(void);
 
+ #ifndef OPENSSL_NO_NTLS
+ const SSL_METHOD *NTLS_method(void);
+ const SSL_METHOD *NTLS_server_method(void);
+ const SSL_METHOD *NTLS_client_method(void);
+ #endif
+
  const SSL_METHOD *SSLv23_method(void);
  const SSL_METHOD *SSLv23_server_method(void);
  const SSL_METHOD *SSLv23_client_method(void);
@@ -129,6 +135,11 @@ The supported protocols are SSLv3, TLSv1
 Applications should use these methods, and avoid the version-specific
 methods described below, which are deprecated.
 
+=item NTLS_method(), NTLS_client_method(), NTLS_server_method()
+
+These are the general-purpose I<version-flexible> NTLS methods. But now there
+is only NTLSv1.1, corresponding to TLCPv1.1 and GM/T 0024-2014.
+
 =item SSLv23_method(), SSLv23_server_method(), SSLv23_client_method()
 
 These functions do not exist anymore, they have been renamed to
Index: b/doc/man3/SSL_CTX_set_alpn_select_cb.pod
===================================================================
--- a/doc/man3/SSL_CTX_set_alpn_select_cb.pod
+++ b/doc/man3/SSL_CTX_set_alpn_select_cb.pod
@@ -4,7 +4,8 @@
 
 SSL_CTX_set_alpn_protos, SSL_set_alpn_protos, SSL_CTX_set_alpn_select_cb,
 SSL_CTX_set_next_proto_select_cb, SSL_CTX_set_next_protos_advertised_cb,
-SSL_select_next_proto, SSL_get0_alpn_selected, SSL_get0_next_proto_negotiated
+SSL_select_next_proto, SSL_get0_alpn_selected, SSL_get0_next_proto_negotiated,
+SSL_get0_alpn_proposed, BABASSL_get0_alpn_proposed
 - handle application layer protocol negotiation (ALPN)
 
 =head1 SYNOPSIS
@@ -47,6 +48,10 @@ SSL_select_next_proto, SSL_get0_alpn_sel
  void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
                              unsigned *len);
 
+ #define SSL_get0_alpn_proposed BABASSL_get0_alpn_proposed
+ void BABASSL_get0_alpn_proposed(const SSL *ssl, const unsigned char **data,
+                                 unsigned *len);
+
 =head1 DESCRIPTION
 
 SSL_CTX_set_alpn_protos() and SSL_set_alpn_protos() are used by the client to
@@ -125,6 +130,12 @@ when using QUIC SSL objects. SSL_CTX_set
 SSL_CTX_set_next_proto_select_cb() have no effect if called on a QUIC SSL
 context.
 
+SSL_get0_alpn_proposed() is a macro that calls BABASSL_get0_alpn_proposed(),
+used by the server to gets the proposed ALPN protocol (if any) from B<ssl>.
+On return it sets B<*data> to point to B<*len> bytes of protocol name,
+not including the leading length-prefix byte. If the server didn't respond
+with a negotiated protocol then B<*len> will be zero.
+
 =head1 NOTES
 
 The protocol-lists must be in wire-format, which is defined as a vector of
@@ -152,6 +163,8 @@ invoked.
 SSL_CTX_set_alpn_protos() and SSL_set_alpn_protos() return 0 on success, and
 non-0 on failure. WARNING: these functions reverse the return value convention.
 
+SSL_get0_alpn_proposed() returns no value.
+
 SSL_select_next_proto() returns one of the following:
 
 =over 4
Index: b/doc/man3/SSL_CTX_set_cert_cb.pod
===================================================================
--- a/doc/man3/SSL_CTX_set_cert_cb.pod
+++ b/doc/man3/SSL_CTX_set_cert_cb.pod
@@ -2,7 +2,13 @@
 
 =head1 NAME
 
-SSL_CTX_set_cert_cb, SSL_set_cert_cb - handle certificate callback function
+SSL_CTX_set_cert_cb, SSL_set_cert_cb,
+SSL_CTX_get_cert_cb, SSL_get_cert_cb,
+SSL_CTX_get_cert_cb_arg, SSL_get_cert_cb_arg,
+BABASSL_CTX_get_cert_cb, BABASSL_get_cert_cb,
+BABASSL_CTX_get_cert_cb_arg, BABASSL_get_cert_cb_arg,
+SSL_cert_cb_fn
+- handle certificate callback function
 
 =head1 SYNOPSIS
 
@@ -12,6 +18,18 @@ SSL_CTX_set_cert_cb, SSL_set_cert_cb - h
                           void *arg);
  void SSL_set_cert_cb(SSL *s, int (*cert_cb)(SSL *ssl, void *arg), void *arg);
 
+ typedef int (*SSL_cert_cb_fn) (SSL *s, void *arg);
+
+ #define SSL_CTX_get_cert_cb BABASSL_CTX_get_cert_cb
+ #define SSL_CTX_get_cert_cb_arg BABASSL_CTX_get_cert_cb_arg
+ SSL_cert_cb_fn BABASSL_CTX_get_cert_cb(SSL_CTX *c);
+ void *BABASSL_CTX_get_cert_cb_arg(SSL_CTX *c);
+
+ #define SSL_get_cert_cb BABASSL_get_cert_cb
+ #define SSL_get_cert_cb_arg BABASSL_get_cert_cb_arg
+ SSL_cert_cb_fn BABASSL_get_cert_cb(SSL *s);
+ void *BABASSL_get_cert_cb_arg(SSL *s);
+
 =head1 DESCRIPTION
 
 SSL_CTX_set_cert_cb() and SSL_set_cert_cb() sets the I<cert_cb> callback,
@@ -19,6 +37,10 @@ I<arg> value is pointer which is passed
 
 When I<cert_cb> is NULL, no callback function is used.
 
+SSL_CTX_get_cert_cb and SSL_get_cert_cb return cert_cb which has been set
+or NULL if no cert_cb has been set.
+SSL_CTX_get_cert_cb_arg and SSL_get_cert_cb_arg return the arg of cert_cb.
+
 I<cert_cb> is the application defined callback. It is called before a
 certificate will be used by a client or server. The callback can then inspect
 the passed I<ssl> structure and set or clear any appropriate certificates. If
@@ -60,6 +82,9 @@ support it will B<not> be used.
 =head1 RETURN VALUES
 
 SSL_CTX_set_cert_cb() and SSL_set_cert_cb() do not return values.
+SSL_CTX_get_cert_cb and SSL_get_cert_cb return cert_cb, maybe NULL, with the
+type of SSL_cert_cb_fn.
+SSL_CTX_get_cert_cb_arg and SSL_get_cert_cb_arg return the arg of cert_cb.
 
 =head1 SEE ALSO
 
Index: b/doc/man3/SSL_CTX_set_client_hello_cb.pod
===================================================================
--- a/doc/man3/SSL_CTX_set_client_hello_cb.pod
+++ b/doc/man3/SSL_CTX_set_client_hello_cb.pod
@@ -2,7 +2,15 @@
 
 =head1 NAME
 
-SSL_CTX_set_client_hello_cb, SSL_client_hello_cb_fn, SSL_client_hello_isv2, SSL_client_hello_get0_legacy_version, SSL_client_hello_get0_random, SSL_client_hello_get0_session_id, SSL_client_hello_get0_ciphers, SSL_client_hello_get0_compression_methods, SSL_client_hello_get1_extensions_present, SSL_client_hello_get_extension_order, SSL_client_hello_get0_ext - callback functions for early server-side ClientHello processing
+SSL_CTX_set_client_hello_cb, SSL_client_hello_cb_fn, SSL_client_hello_isv2,
+SSL_client_hello_get0_legacy_version, SSL_client_hello_get0_random,
+SSL_client_hello_get0_session_id, SSL_client_hello_get0_ciphers,
+SSL_client_hello_get0_compression_methods,
+SSL_client_hello_get1_extensions_present,
+SSL_client_hello_get0_ext,
+SSL_client_hello_get1_extensions,
+BABASSL_client_hello_get1_extensions
+- callback functions for early server-side ClientHello processing
 
 =head1 SYNOPSIS
 
@@ -23,6 +31,9 @@ SSL_CTX_set_client_hello_cb, SSL_client_
  int SSL_client_hello_get0_ext(SSL *s, unsigned int type, const unsigned char **out,
                                size_t *outlen);
 
+ # define SSL_client_hello_get1_extensions BABASSL_client_hello_get1_extensions
+ int BABASSL_client_hello_get1_extensions(SSL *s, int **out, size_t *outlen);
+
 =head1 DESCRIPTION
 
 SSL_CTX_set_client_hello_cb() sets the callback function, which is automatically
Index: b/doc/man3/SSL_CTX_set_tlsext_status_cb.pod
===================================================================
--- a/doc/man3/SSL_CTX_set_tlsext_status_cb.pod
+++ b/doc/man3/SSL_CTX_set_tlsext_status_cb.pod
@@ -11,7 +11,9 @@ SSL_CTX_get_tlsext_status_type,
 SSL_set_tlsext_status_type,
 SSL_get_tlsext_status_type,
 SSL_get_tlsext_status_ocsp_resp,
-SSL_set_tlsext_status_ocsp_resp
+SSL_set_tlsext_status_ocsp_resp,
+OPENSSL_CHECK_TLSEXT_STATUS,
+SSL_check_tlsext_status, BABASSL_check_tlsext_status
 - OCSP Certificate Status Request functions
 
 =head1 SYNOPSIS
@@ -33,6 +35,12 @@ SSL_set_tlsext_status_ocsp_resp
  long SSL_get_tlsext_status_ocsp_resp(ssl, unsigned char **resp);
  long SSL_set_tlsext_status_ocsp_resp(ssl, unsigned char *resp, int len);
 
+ #include <openssl/ssl.h>
+
+ #define OPENSSL_CHECK_TLSEXT_STATUS 1
+ #define SSL_check_tlsext_status BABASSL_check_tlsext_status
+ int BABASSL_check_tlsext_status(SSL *s);
+
 =head1 DESCRIPTION
 
 A client application may request that a server send back an OCSP status response
@@ -80,6 +88,10 @@ calling SSL_set_tlsext_status_ocsp_resp(
 be provided in the B<resp> argument, and the length of that data should be in
 the B<len> argument.
 
+SSL_check_tlsext_status() is a macro that calls BABASSL_check_tlsext_status(),
+checks whether the status type and callback are set, returns 1 if both are
+set. Otherwise 0 is returned.
+
 =head1 RETURN VALUES
 
 The callback when used on the client side should return a negative value on
@@ -106,6 +118,9 @@ SSL_get_tlsext_status_type() returns B<T
 side if SSL_set_tlsext_status_type() was previously called, or on the server
 side if the client requested OCSP stapling. Otherwise -1 is returned.
 
+SSL_check_tlsext_status() returns 1 if both the status type and callback are
+set. Otherwise 0 is returned.
+
 =head1 SEE ALSO
 
 L<ssl(7)>
Index: b/doc/man3/SSL_CTX_use_certificate.pod
===================================================================
--- a/doc/man3/SSL_CTX_use_certificate.pod
+++ b/doc/man3/SSL_CTX_use_certificate.pod
@@ -12,7 +12,16 @@ SSL_CTX_use_RSAPrivateKey_ASN1, SSL_CTX_
 SSL_use_PrivateKey_file, SSL_use_PrivateKey_ASN1, SSL_use_PrivateKey,
 SSL_use_RSAPrivateKey, SSL_use_RSAPrivateKey_ASN1,
 SSL_use_RSAPrivateKey_file, SSL_CTX_check_private_key, SSL_check_private_key,
-SSL_CTX_use_cert_and_key, SSL_use_cert_and_key
+SSL_CTX_use_cert_and_key, SSL_use_cert_and_key,
+SSL_use_sign_certificate, SSL_use_sign_certificate_file,
+SSL_use_sign_PrivateKey, SSL_use_sign_PrivateKey_file,
+SSL_use_enc_certificate, SSL_use_enc_certificate_file,
+SSL_use_enc_PrivateKey, SSL_use_enc_PrivateKey_file,
+SSL_CTX_use_sign_certificate, SSL_CTX_use_sign_certificate_file,
+SSL_CTX_use_sign_PrivateKey, SSL_CTX_use_sign_PrivateKey_file,
+SSL_CTX_use_enc_certificate, SSL_CTX_use_enc_certificate_file,
+SSL_CTX_use_enc_PrivateKey, SSL_CTX_use_enc_PrivateKey_file,
+SSL_CTX_certs_clear, BABASSL_CTX_certs_clear
 - load certificate and key data
 
 =head1 SYNOPSIS
@@ -49,6 +58,29 @@ SSL_CTX_use_cert_and_key, SSL_use_cert_a
  int SSL_CTX_use_cert_and_key(SSL_CTX *ctx, X509 *x, EVP_PKEY *pkey, STACK_OF(X509) *chain, int override);
  int SSL_use_cert_and_key(SSL *ssl, X509 *x, EVP_PKEY *pkey, STACK_OF(X509) *chain, int override);
 
+ #ifndef OPENSSL_NO_NTLS
+ int SSL_use_sign_certificate(SSL *ssl, X509 *x);
+ int SSL_use_sign_certificate_file(SSL *ssl, const char *file, int type);
+ int SSL_use_enc_certificate(SSL *ssl, X509 *x);
+ int SSL_use_enc_certificate_file(SSL *ssl, const char *file, int type);
+ int SSL_use_sign_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
+ int SSL_use_sign_PrivateKey_file(SSL *ssl, const char *file, int type);
+ int SSL_use_enc_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
+ int SSL_use_enc_PrivateKey_file(SSL *ssl, const char *file, int type);
+
+ int SSL_CTX_use_sign_certificate(SSL_CTX *ctx, X509 *x);
+ int SSL_CTX_use_sign_certificate_file(SSL_CTX *ctx, const char *file, int type);
+ int SSL_CTX_use_enc_certificate(SSL_CTX *ctx, X509 *x);
+ int SSL_CTX_use_enc_certificate_file(SSL_CTX *ctx, const char *file, int type);
+ int SSL_CTX_use_sign_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+ int SSL_CTX_use_sign_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
+ int SSL_CTX_use_enc_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+ int SSL_CTX_use_enc_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
+ #endif
+
+ #define SSL_CTX_certs_clear BABASSL_CTX_certs_clear
+ void BABASSL_CTX_certs_clear(SSL_CTX *ctx);
+
 =head1 DESCRIPTION
 
 These functions load the certificates and private keys into the SSL_CTX
@@ -70,6 +102,11 @@ specified using the
 L<SSL_CTX_add_extra_chain_cert(3)>
 function. On success the reference counter of the B<x> is incremented.
 
+SSL_CTX_use_sign_certificate() loads the signature certificate B<x> into
+B<ctx>, SSL_use_sign_certificate() loads B<x> into B<ssl>.
+SSL_CTX_use_enc_certificate() loads the encryption certificate B<x> into
+B<ctx>, SSL_use_enc_certificate() loads B<x> into B<ssl>.
+
 SSL_CTX_use_certificate_ASN1() loads the ASN1 encoded certificate from
 the memory location B<d> (with length B<len>) into B<ctx>,
 SSL_use_certificate_ASN1() loads the ASN1 encoded certificate into B<ssl>.
@@ -81,6 +118,18 @@ SSL_use_certificate_file() loads the cer
 See the NOTES section on why SSL_CTX_use_certificate_chain_file()
 should be preferred.
 
+SSL_CTX_use_sign_certificate_file() loads the first certificate stored in
+B<file> into B<ctx>. The formatting B<type> of the signature certificate must
+be specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.
+SSL_use_sign_certificate_file() loads the signature certificate from B<file>
+into B<ssl>.
+
+SSL_CTX_use_enc_certificate_file() loads the first certificate stored in
+B<file> into B<ctx>. The formatting B<type> of the encryption certificate must
+be specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.
+SSL_use_enc_certificate_file() loads the encryption certificate from B<file>
+into B<ssl>.
+
 SSL_CTX_use_certificate_chain_file() loads a certificate chain from
 B<file> into B<ctx>. The certificates must be in PEM format and must
 be sorted starting with the subject's certificate (actual client or server
@@ -99,6 +148,11 @@ SSL_CTX_use_certificate() before setting
 SSL_CTX_use_PrivateKey() or SSL_use_PrivateKey().
 On success the reference counter of the B<pkey>/B<rsa> is incremented.
 
+SSL_CTX_use_sign_PrivateKey() adds B<pkey> as signature private key to B<ctx>.
+SSL_use_sign_PrivateKey() adds B<pkey> as signature private key to B<ssl>.
+SSL_CTX_use_enc_PrivateKey() adds B<pkey> as encryption private key to B<ctx>.
+SSL_use_enc_PrivateKey() adds B<pkey> as encryption private key to B<ssl>.
+
 SSL_CTX_use_cert_and_key() and SSL_use_cert_and_key() assign the X.509
 certificate B<x>, private key B<key>, and certificate B<chain> onto the
 corresponding B<ssl> or B<ctx>. The B<pkey> argument must be the private
@@ -128,6 +182,14 @@ B<file> to B<ctx>. SSL_use_PrivateKey_fi
 in B<file> to B<ssl>; SSL_use_RSAPrivateKey_file() adds the first private
 RSA key found to B<ssl>.
 
+SSL_CTX_use_sign_PrivateKey_file() adds the first private key found in
+B<file> to B<ctx>. The formatting B<type> of the signature private key must be
+specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.
+
+SSL_CTX_use_enc_PrivateKey_file() adds the first private key found in
+B<file> to B<ctx>. The formatting B<type> of the encryption private key must be
+specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.
+
 SSL_CTX_check_private_key() checks the consistency of a private key with
 the corresponding certificate loaded into B<ctx>. If more than one
 key/certificate pair (RSA/DSA) is installed, the last item installed will
@@ -136,6 +198,9 @@ key/certificate pair will be checked. SS
 the same check for B<ssl>. If no key/certificate was explicitly added for
 this B<ssl>, the last item added into B<ctx> will be checked.
 
+SSL_CTX_certs_clear() is a macro that calls BABASSL_CTX_certs_clear(), clears
+all the certificates in SSL_CTX B<ctx>.
+
 =head1 NOTES
 
 The internal certificate store of OpenSSL can hold several private
@@ -181,7 +246,9 @@ private key to confirm that the certific
 
 =head1 RETURN VALUES
 
-On success, the functions return 1.
+SSL_CTX_certs_clear() returns no value.
+
+All other functions return 1 on success, 0 on error.
 Otherwise check out the error stack to find out the reason.
 
 =head1 SEE ALSO
Index: b/doc/man3/SSL_get_certificate.pod
===================================================================
--- a/doc/man3/SSL_get_certificate.pod
+++ b/doc/man3/SSL_get_certificate.pod
@@ -2,7 +2,11 @@
 
 =head1 NAME
 
-SSL_get_certificate, SSL_get_privatekey - retrieve TLS/SSL certificate and
+SSL_get_certificate, SSL_get_privatekey,
+SSL_get_use_certificate, BABASSL_get_use_certificate,
+SSL_get_sign_certificate_ntls, SSL_get_enc_certificate_ntls,
+BABASSL_get_sign_certificate_ntls, BABASSL_get_enc_certificate_ntls
+- retrieve TLS/SSL certificate and
 private key
 
 =head1 SYNOPSIS
@@ -12,11 +16,30 @@ private key
  X509 *SSL_get_certificate(const SSL *s);
  EVP_PKEY *SSL_get_privatekey(const SSL *s);
 
+ #define SSL_get_use_certificate BABASSL_get_use_certificate
+ X509 *BABASSL_get_use_certificate(const SSL *s);
+
+ #ifndef OPENSSL_NO_NTLS
+ #define SSL_get_sign_certificate_ntls BABASSL_get_sign_certificate_ntls
+ #define SSL_get_enc_certificate_ntls BABASSL_get_enc_certificate_ntls
+
+ X509 *BABASSL_get_sign_certificate_ntls(const SSL *s);
+ X509 *BABASSL_get_enc_certificate_ntls(const SSL *s);
+ #endif
+
 =head1 DESCRIPTION
 
 SSL_get_certificate() returns a pointer to an B<X509> object representing a
 certificate used as the local peer's identity.
 
+SSL_get_use_certificate() is a macro that calls BABASSL_get_use_certificate(),
+returns a pointer to an B<X509> object representing the used certificate.
+
+SSL_get_sign_certificate_ntls() returns a pointer to an B<X509> object
+representing the used signature certificate.
+SSL_get_enc_certificate_ntls() returns a pointer to an B<X509> object
+representing the used encryption certificate.
+
 Multiple certificates can be configured; for example, a server might have both
 RSA and ECDSA certificates. The certificate which is returned by
 SSL_get_certificate() is determined as follows:
Index: b/doc/man3/SSL_get_client_random.pod
===================================================================
--- a/doc/man3/SSL_get_client_random.pod
+++ b/doc/man3/SSL_get_client_random.pod
@@ -5,7 +5,8 @@
 SSL_get_client_random,
 SSL_get_server_random,
 SSL_SESSION_get_master_key,
-SSL_SESSION_set1_master_key
+SSL_SESSION_set1_master_key,
+SSL_get_master_key, BABASSL_get_master_key
 - get internal TLS/SSL random values and get/set master key
 
 =head1 SYNOPSIS
@@ -19,6 +20,10 @@ SSL_SESSION_set1_master_key
  int SSL_SESSION_set1_master_key(SSL_SESSION *sess, const unsigned char *in,
                                  size_t len);
 
+ #define SSL_get_master_key BABASSL_get_master_key
+ int BABASSL_get_master_key(SSL *s, unsigned char **master_key,
+                            int *master_key_len);
+
 =head1 DESCRIPTION
 
 SSL_get_client_random() extracts the random value sent from the client
@@ -36,6 +41,10 @@ SSL_SESSION_get_master_key() behaves the
 secret used to guarantee the security of the SSL/TLS session.  This one
 can be dangerous if misused; see NOTES below.
 
+SSL_get_master_key() is a macro that calls BABASSL_get_master_key(), extracts
+the master secret to B<master_key> and bytes of master secret to
+B<master_key_len>. Both B<master_key> and B<master_key_len> can be NULL.
+
 SSL_SESSION_set1_master_key() sets the master key value associated with the
 SSL_SESSION B<sess>. For example, this could be used to set up a session based
 PSK (see L<SSL_CTX_set_psk_use_session_callback(3)>). The master key of length
@@ -79,6 +88,8 @@ values based on their view of the curren
 
 SSL_SESSION_set1_master_key() returns 1 on success or 0 on failure.
 
+SSL_get_master_key() returns 1 on success or 0 on failure.
+
 For the other functions, if B<outlen> is greater than 0 then these functions
 return the number of bytes actually copied, which will be less than or equal to
 B<outlen>. If B<outlen> is 0 then these functions return the maximum number
Index: b/doc/man3/SSL_get_rbio.pod
===================================================================
--- a/doc/man3/SSL_get_rbio.pod
+++ b/doc/man3/SSL_get_rbio.pod
@@ -2,7 +2,9 @@
 
 =head1 NAME
 
-SSL_get_rbio, SSL_get_wbio - get BIO linked to an SSL object
+SSL_get_rbio, SSL_get_wbio,
+SSL_get0_wbio, BABASSL_get0_wbio
+- get BIO linked to an SSL object
 
 =head1 SYNOPSIS
 
@@ -11,12 +13,18 @@ SSL_get_rbio, SSL_get_wbio - get BIO lin
  BIO *SSL_get_rbio(SSL *ssl);
  BIO *SSL_get_wbio(SSL *ssl);
 
+ #define SSL_get0_wbio BABASSL_get0_wbio
+ BIO *BABASSL_get0_wbio(const SSL *s);
+
 =head1 DESCRIPTION
 
 SSL_get_rbio() and SSL_get_wbio() return pointers to the BIOs for the
 read or the write channel, which can be different. The reference count
 of the BIO is not incremented.
 
+SSL_get0_wbio() is a macro that calls BABASSL_get0_wbio(), returns the pointer
+to the wbio. The reference count of the BIO is not incremented.
+
 =head1 RETURN VALUES
 
 The following return values can occur:
Index: b/doc/man3/SSL_get_version.pod
===================================================================
--- a/doc/man3/SSL_get_version.pod
+++ b/doc/man3/SSL_get_version.pod
@@ -2,8 +2,10 @@
 
 =head1 NAME
 
-SSL_client_version, SSL_get_version, SSL_is_dtls, SSL_is_tls, SSL_is_quic,
-SSL_version - get the protocol information of a connection
+SSL_client_version, SSL_get_version, SSL_is_dtls, SSL_version,
+SSL_is_ntls, SSL_enable_ntls, SSL_disable_ntls,
+SSL_CTX_enable_ntls, SSL_CTX_disable_ntls - get the
+ protocol information of a connection
 
 =head1 SYNOPSIS
 
@@ -19,6 +21,15 @@ SSL_version - get the protocol informati
 
  int SSL_version(const SSL *s);
 
+ #ifndef OPENSSL_NO_NTLS
+ int SSL_is_ntls(const SSL *s);
+
+ void SSL_enable_ntls(SSL *s);
+ void SSL_disable_ntls(SSL *s);
+ void SSL_CTX_enable_ntls(SSL_CTX *ctx);
+ void SSL_CTX_disable_ntls(SSL_CTX *ctx);
+ #endif
+
 =head1 DESCRIPTION
 
 For SSL, TLS and DTLS protocols SSL_client_version() returns the numeric
@@ -38,6 +49,13 @@ SSL_is_tls() returns 1 if the connection
 
 SSL_is_quic() returns 1 if the connection is using QUIC or 0 if not.
 
+SSL_is_ntls() returns one if the connection is using NTLS, zero if not.
+
+SSL_enable_ntls() and SSL_CTX_enable_ntls() enable NTLS protocol either for
+a given SSL connection or for all connections that share the given SSL context,
+respectively. SSL_disable_ntls and SSL_CTX_disable_ntls() turn off NTLS
+protocol.
+
 =head1 RETURN VALUES
 
 
Index: b/include/internal/tlsgroups.h
===================================================================
--- a/include/internal/tlsgroups.h
+++ b/include/internal/tlsgroups.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2017-2022 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -51,6 +51,7 @@
 # define OSSL_TLS_GROUP_ID_gc512A           0x0026
 # define OSSL_TLS_GROUP_ID_gc512B           0x0027
 # define OSSL_TLS_GROUP_ID_gc512C           0x0028
+# define OSSL_TLS_GROUP_ID_sm2              0x0029
 # define OSSL_TLS_GROUP_ID_ffdhe2048        0x0100
 # define OSSL_TLS_GROUP_ID_ffdhe3072        0x0101
 # define OSSL_TLS_GROUP_ID_ffdhe4096        0x0102
Index: b/include/openssl/core_names.h.in
===================================================================
--- a/include/openssl/core_names.h.in
+++ b/include/openssl/core_names.h.in
@@ -53,6 +53,17 @@ extern "C" {
 # define OSSL_DIGEST_NAME_KECCAK_KMAC256 "KECCAK-KMAC-256"
 # define OSSL_DIGEST_NAME_SM3            "SM3"
 
+/* SM2DH Exchange parameters */
+#define OSSL_EXCHANGE_PARAM_INITIATOR             "sm2-initiator"
+#define OSSL_EXCHANGE_PARAM_SELF_ID               "self-id"
+#define OSSL_EXCHANGE_PARAM_PEER_ID               "peer-id"
+#define OSSL_EXCHANGE_PARAM_SELF_ENC_KEY          "self-enc-key"
+#define OSSL_EXCHANGE_PARAM_PEER_ENC_KEY          "peer-enc-key"
+
+#define OSSL_EXCHANGE_PARAM_DIGEST                OSSL_PKEY_PARAM_DIGEST
+#define OSSL_EXCHANGE_PARAM_DIGEST_PROPS          "digest-props" /* utf8_string */
+#define OSSL_EXCHANGE_PARAM_OUTLEN                "outlen" /* size_t */
+
 /* Known MAC names */
 # define OSSL_MAC_NAME_BLAKE2BMAC    "BLAKE2BMAC"
 # define OSSL_MAC_NAME_BLAKE2SMAC    "BLAKE2SMAC"
Index: b/include/openssl/ntls.h
===================================================================
--- /dev/null
+++ b/include/openssl/ntls.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#ifndef OPENSSL_NTLS_H
+# define OPENSSL_NTLS_H
+# pragma once
+
+# include <openssl/opensslconf.h>
+# include <openssl/prov_ssl.h>
+
+# ifndef OPENSSL_NO_NTLS
+#  ifdef  __cplusplus
+extern "C" {
+#  endif
+
+/* NTLS version */
+#  define NTLS1_1_VERSION_MAJOR 0x01
+#  define NTLS1_1_VERSION_MINOR 0x01
+#  define NTLS_VERSION          NTLS1_1_VERSION
+#  define NTLS_VERSION_MAJOR    NTLS1_1_VERSION_MAJOR
+#  define NTLS_VERSOIN_MINOR    NTLS1_1_VERSION_MINOR
+/*
+ * This tag is used to replace SSLv3 when use NTLS.
+ * SSLv3 is not used default, so it always be the min protocal version in test,
+ * but when add NTLS, the NTLS becomes the min version, and NTLS is commonly use,
+ * then will cause some problems, so add this tag
+ */
+#  define MIN_VERSION_WITH_NTLS 0x0100
+
+/* Compatible with GM/T 0024-2014 cipher suites name */
+#  define NTLS_TXT_SM2DHE_WITH_SM4_SM3          "ECDHE-SM2-WITH-SM4-SM3"
+#  define NTLS_TXT_SM2_WITH_SM4_SM3             "ECC-SM2-WITH-SM4-SM3"
+
+/* GB/T 38636-2020 TLCP, cipher suites */
+#  define NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3        "ECDHE-SM2-SM4-CBC-SM3"
+#  define NTLS_TXT_ECDHE_SM2_SM4_GCM_SM3        "ECDHE-SM2-SM4-GCM-SM3"
+#  define NTLS_TXT_ECC_SM2_SM4_CBC_SM3          "ECC-SM2-SM4-CBC-SM3"
+#  define NTLS_TXT_ECC_SM2_SM4_GCM_SM3          "ECC-SM2-SM4-GCM-SM3"
+#  define NTLS_TXT_IBSDH_SM9_SM4_CBC_SM3        "IBSDH-SM9-SM4-CBC-SM3"
+#  define NTLS_TXT_IBSDH_SM9_SM4_GCM_SM3        "IBSDH-SM9-SM4-GCM-SM3"
+#  define NTLS_TXT_IBC_SM9_SM4_CBC_SM3          "IBC-SM9-SM4-CBC-SM3"
+#  define NTLS_TXT_IBC_SM9_SM4_GCM_SM3          "IBC-SM9-SM4-GCM-SM3"
+#  define NTLS_TXT_RSA_SM4_CBC_SM3              "RSA-SM4-CBC-SM3"
+#  define NTLS_TXT_RSA_SM4_GCM_SM3              "RSA-SM4-GCM-SM3"
+#  define NTLS_TXT_RSA_SM4_CBC_SHA256           "RSA-SM4-CBC-SHA256"
+#  define NTLS_TXT_RSA_SM4_GCM_SHA256           "RSA-SM4-GCM-SHA256"
+
+#  define NTLS_GB_ECDHE_SM2_SM4_CBC_SM3         "ECDHE_SM4_CBC_SM3"
+#  define NTLS_GB_ECDHE_SM2_SM4_GCM_SM3         "ECDHE_SM4_GCM_SM3"
+#  define NTLS_GB_ECC_SM2_SM4_CBC_SM3           "ECC_SM4_CBC_SM3"
+#  define NTLS_GB_ECC_SM2_SM4_GCM_SM3           "ECC_SM4_GCM_SM3"
+#  define NTLS_GB_IBSDH_SM9_SM4_CBC_SM3         "IBSDH_SM4_CBC_SM3"
+#  define NTLS_GB_IBSDH_SM9_SM4_GCM_SM3         "IBSDH_SM4_GCM_SM3"
+#  define NTLS_GB_IBC_SM9_SM4_CBC_SM3           "IBC_SM4_CBC_SM3"
+#  define NTLS_GB_IBC_SM9_SM4_GCM_SM3           "IBC_SM4_GCM_SM3"
+#  define NTLS_GB_RSA_SM4_CBC_SM3               "RSA_SM4_CBC_SM3"
+#  define NTLS_GB_RSA_SM4_GCM_SM3               "RSA_SM4_GCM_SM3"
+#  define NTLS_GB_RSA_SM4_CBC_SHA256            "RSA_SM4_CBC_SHA256"
+#  define NTLS_GB_RSA_SM4_GCM_SHA256            "RSA_SM4_GCM_SHA256"
+
+#  define NTLS_CK_ECDHE_SM2_SM4_CBC_SM3         0x0300E011
+#  define NTLS_CK_ECDHE_SM2_SM4_GCM_SM3         0x0300E051
+#  define NTLS_CK_ECC_SM2_SM4_CBC_SM3           0x0300E013
+#  define NTLS_CK_ECC_SM2_SM4_GCM_SM3           0x0300E053
+#  define NTLS_CK_IBSDH_SM9_SM4_CBC_SM3         0x0300E015
+#  define NTLS_CK_IBSDH_SM9_SM4_GCM_SM3         0x0300E055
+#  define NTLS_CK_IBC_SM9_SM4_CBC_SM3           0x0300E017
+#  define NTLS_CK_IBC_SM9_SM4_GCM_SM3           0x0300E057
+#  define NTLS_CK_RSA_SM4_CBC_SM3               0x0300E019
+#  define NTLS_CK_RSA_SM4_GCM_SM3               0x0300E059
+#  define NTLS_CK_RSA_SM4_CBC_SHA256            0x0300E01C
+#  define NTLS_CK_RSA_SM4_GCM_SHA256            0x0300E05a
+
+
+#  define NTLS_AD_UNSUPPORTED_SITE2SITE         200
+#  define NTLS_AD_NO_AREA                       201
+#  define NTLS_AD_UNSUPPORTED_AREATYPE          202
+#  define NTLS_AD_BAD_IBCPARAM                  203
+#  define NTLS_AD_UNSUPPORTED_IBCPARAM          204
+#  define NTLS_AD_IDENTITY_NEED                 205
+
+#  ifdef  __cplusplus
+}
+#  endif
+# endif
+#endif
Index: b/include/openssl/ssl.h.in
===================================================================
--- a/include/openssl/ssl.h.in
+++ b/include/openssl/ssl.h.in
@@ -44,6 +44,7 @@ use OpenSSL::stackhash qw(generate_stack
 # include <openssl/ct.h>
 # include <openssl/sslerr.h>
 # include <openssl/prov_ssl.h>
+# include <openssl/ntls.h>
 # ifndef OPENSSL_NO_STDIO
 #  include <stdio.h>
 # endif
@@ -100,6 +101,8 @@ extern "C" {
 # define SSL_TXT_kGOST           "kGOST"
 # define SSL_TXT_kGOST18         "kGOST18"
 # define SSL_TXT_kSRP            "kSRP"
+# define SSL_TXT_kSM2            "kSM2"
+# define SSL_TXT_kSM2DHE         "kSM2DHE"
 
 # define SSL_TXT_aRSA            "aRSA"
 # define SSL_TXT_aDSS            "aDSS"
@@ -112,6 +115,7 @@ extern "C" {
 # define SSL_TXT_aGOST12         "aGOST12"
 # define SSL_TXT_aGOST           "aGOST"
 # define SSL_TXT_aSRP            "aSRP"
+# define SSL_TXT_aSM2            "aSM2"
 
 # define SSL_TXT_DSS             "DSS"
 # define SSL_TXT_DH              "DH"
@@ -126,6 +130,7 @@ extern "C" {
 # define SSL_TXT_ECDSA           "ECDSA"
 # define SSL_TXT_PSK             "PSK"
 # define SSL_TXT_SRP             "SRP"
+# define SSL_TXT_SM2             "SM2"
 
 # define SSL_TXT_DES             "DES"
 # define SSL_TXT_3DES            "3DES"
@@ -150,7 +155,7 @@ extern "C" {
 # define SSL_TXT_ARIA256         "ARIA256"
 # define SSL_TXT_GOST2012_GOST8912_GOST8912 "GOST2012-GOST8912-GOST8912"
 # define SSL_TXT_CBC             "CBC"
-
+# define SSL_TXT_SM4             "SM4"
 # define SSL_TXT_MD5             "MD5"
 # define SSL_TXT_SHA1            "SHA1"
 # define SSL_TXT_SHA             "SHA"/* same as "SHA1" */
@@ -160,11 +165,15 @@ extern "C" {
 # define SSL_TXT_GOST89MAC12     "GOST89MAC12"
 # define SSL_TXT_SHA256          "SHA256"
 # define SSL_TXT_SHA384          "SHA384"
+# define SSL_TXT_SM3             "SM3"
 
 # define SSL_TXT_SSLV3           "SSLv3"
 # define SSL_TXT_TLSV1           "TLSv1"
 # define SSL_TXT_TLSV1_1         "TLSv1.1"
 # define SSL_TXT_TLSV1_2         "TLSv1.2"
+# ifndef OPENSSL_NO_NTLS
+#  define SSL_TXT_NTLSV1_1       "NTLSv1.1"
+# endif
 
 # define SSL_TXT_ALL             "ALL"
 
@@ -222,6 +231,12 @@ extern "C" {
 extern "C" {
 #endif
 
+# ifndef OPENSSL_NO_NTLS
+#  define SSL_NORMAL_CERT                              0
+#  define SSL_SIGN_CERT                                1
+#  define SSL_ENC_CERT                                 2
+# endif
+
 # define SSL_FILETYPE_ASN1       X509_FILETYPE_ASN1
 # define SSL_FILETYPE_PEM        X509_FILETYPE_PEM
 
@@ -405,6 +420,10 @@ typedef int (*SSL_async_callback_fn)(SSL
 # define SSL_OP_NO_TLSv1_1                               SSL_OP_BIT(28)
 # define SSL_OP_NO_TLSv1_3                               SSL_OP_BIT(29)
 # define SSL_OP_NO_DTLSv1                                SSL_OP_BIT(26)
+# ifndef OPENSSL_NO_NTLS
+/* Just use a reserved value, don't conflict with OP TLS */
+#  define SSL_OP_NO_NTLS                                 SSL_OP_BIT(5)
+# endif
 # define SSL_OP_NO_DTLSv1_2                              SSL_OP_BIT(27)
     /* Disallow all renegotiation */
 # define SSL_OP_NO_RENEGOTIATION                         SSL_OP_BIT(30)
@@ -1202,6 +1221,15 @@ DECLARE_PEM_rw(SSL_SESSION, SSL_SESSION)
 /* fatal */
 # define SSL_AD_INAPPROPRIATE_FALLBACK   TLS1_AD_INAPPROPRIATE_FALLBACK
 # define SSL_AD_NO_APPLICATION_PROTOCOL  TLS1_AD_NO_APPLICATION_PROTOCOL
+# ifndef OPENSSL_NO_NTLS
+#  define SSL_AD_UNSUPPORTED_SITE2SITE   NTLS_AD_UNSUPPORTED_SITE2SITE
+#  define SSL_AD_NO_AREA                 NTLS_AD_NO_AREA
+#  define SSL_AD_UNSUPPORTED_AREATYPE    NTLS_AD_UNSUPPORTED_AREATYPE
+#  define SSL_AD_BAD_IBCPARAM            NTLS_AD_BAD_IBCPARAM
+#  define SSL_AD_UNSUPPORTED_IBCPARAM    NTLS_AD_UNSUPPORTED_IBCPARAM
+#  define SSL_AD_IDENTITY_NEED           NTLS_AD_IDENTITY_NEED
+# endif
+
 # define SSL_ERROR_NONE                  0
 # define SSL_ERROR_SSL                   1
 # define SSL_ERROR_WANT_READ             2
@@ -1586,6 +1614,16 @@ __owur int SSL_CIPHER_get_auth_nid(const
 __owur const EVP_MD *SSL_CIPHER_get_handshake_digest(const SSL_CIPHER *c);
 __owur int SSL_CIPHER_is_aead(const SSL_CIPHER *c);
 
+# define SSL_CIPHER_get_mkey BABASSL_CIPHER_get_mkey
+# define SSL_CIPHER_get_auth BABASSL_CIPHER_get_auth
+# define SSL_CIPHER_get_enc  BABASSL_CIPHER_get_enc
+# define SSL_CIPHER_get_mac  BABASSL_CIPHER_get_mac
+
+__owur unsigned long BABASSL_CIPHER_get_mkey(const SSL_CIPHER *c);
+__owur unsigned long BABASSL_CIPHER_get_auth(const SSL_CIPHER *c);
+__owur unsigned long BABASSL_CIPHER_get_enc(const SSL_CIPHER *c);
+__owur unsigned long BABASSL_CIPHER_get_mac(const SSL_CIPHER *c);
+
 __owur int SSL_get_fd(const SSL *s);
 __owur int SSL_get_rfd(const SSL *s);
 __owur int SSL_get_wfd(const SSL *s);
@@ -1604,6 +1642,10 @@ void SSL_set0_wbio(SSL *s, BIO *wbio);
 void SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio);
 __owur BIO *SSL_get_rbio(const SSL *s);
 __owur BIO *SSL_get_wbio(const SSL *s);
+
+# define SSL_get0_wbio BABASSL_get0_wbio
+__owur BIO *BABASSL_get0_wbio(const SSL *s);
+
 __owur int SSL_set_cipher_list(SSL *s, const char *str);
 __owur int SSL_CTX_set_ciphersuites(SSL_CTX *ctx, const char *str);
 __owur int SSL_set_ciphersuites(SSL *s, const char *str);
@@ -1614,6 +1656,15 @@ __owur SSL_verify_cb SSL_get_verify_call
 void SSL_set_verify(SSL *s, int mode, SSL_verify_cb callback);
 void SSL_set_verify_depth(SSL *s, int depth);
 void SSL_set_cert_cb(SSL *s, int (*cb) (SSL *ssl, void *arg), void *arg);
+
+typedef int (*SSL_cert_cb_fn) (SSL *s, void *arg);
+
+# define SSL_get_cert_cb BABASSL_get_cert_cb
+# define SSL_get_cert_cb_arg BABASSL_get_cert_cb_arg
+
+SSL_cert_cb_fn BABASSL_get_cert_cb(SSL *s);
+void *BABASSL_get_cert_cb_arg(SSL *s);
+
 # ifndef OPENSSL_NO_DEPRECATED_3_0
 OSSL_DEPRECATEDIN_3_0 __owur int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);
 OSSL_DEPRECATEDIN_3_0
@@ -1765,6 +1816,12 @@ void SSL_CTX_set_cert_verify_callback(SS
                                       void *arg);
 void SSL_CTX_set_cert_cb(SSL_CTX *c, int (*cb) (SSL *ssl, void *arg),
                          void *arg);
+# define SSL_CTX_get_cert_cb BABASSL_CTX_get_cert_cb
+# define SSL_CTX_get_cert_cb_arg BABASSL_CTX_get_cert_cb_arg
+
+SSL_cert_cb_fn BABASSL_CTX_get_cert_cb(SSL_CTX *c);
+void *BABASSL_CTX_get_cert_cb_arg(SSL_CTX *c);
+
 # ifndef OPENSSL_NO_DEPRECATED_3_0
 OSSL_DEPRECATEDIN_3_0
 __owur int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
@@ -1773,9 +1830,37 @@ __owur int SSL_CTX_use_RSAPrivateKey_ASN
                                           long len);
 # endif
 __owur int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+# ifndef OPENSSL_NO_NTLS
+__owur int SSL_CTX_use_enc_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+__owur int SSL_CTX_use_sign_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+__owur int SSL_CTX_use_enc_PrivateKey_file(SSL_CTX *ctx, const char *file,
+                                           int type);
+__owur int SSL_CTX_use_sign_PrivateKey_file(SSL_CTX *ctx, const char *file,
+                                            int type);
+void SSL_CTX_enable_ntls(SSL_CTX *ctx);
+void SSL_CTX_disable_ntls(SSL_CTX *ctx);
+void SSL_enable_ntls(SSL *s);
+void SSL_disable_ntls(SSL *s);
+# endif
+
+# ifndef OPENSSL_NO_SM2
+void SSL_CTX_enable_sm_tls13_strict(SSL_CTX *ctx);
+void SSL_CTX_disable_sm_tls13_strict(SSL_CTX *ctx);
+void SSL_enable_sm_tls13_strict(SSL *s);
+void SSL_disable_sm_tls13_strict(SSL *s);
+# endif
+
 __owur int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx,
                                        const unsigned char *d, long len);
 __owur int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
+# ifndef OPENSSL_NO_NTLS
+__owur int SSL_CTX_use_enc_certificate(SSL_CTX *ctx, X509 *x);
+__owur int SSL_CTX_use_sign_certificate(SSL_CTX *ctx, X509 *x);
+__owur int SSL_CTX_use_enc_certificate_file(SSL_CTX *ctx, const char *file,
+                                            int type);
+__owur int SSL_CTX_use_sign_certificate_file(SSL_CTX *ctx, const char *file,
+                                             int type);
+# endif
 __owur int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len,
                                         const unsigned char *d);
 __owur int SSL_CTX_use_cert_and_key(SSL_CTX *ctx, X509 *x509, EVP_PKEY *privatekey,
@@ -1799,7 +1884,14 @@ __owur int SSL_CTX_set_session_id_contex
 
 SSL *SSL_new(SSL_CTX *ctx);
 int SSL_up_ref(SSL *s);
+
+# define SSL_SESSION_get_ref BABASSL_SESSION_get_ref
+int BABASSL_SESSION_get_ref(SSL_SESSION *sess);
+
 int SSL_is_dtls(const SSL *s);
+# ifndef OPENSSL_NO_NTLS
+int SSL_is_ntls(const SSL *s);
+# endif
 int SSL_is_tls(const SSL *s);
 int SSL_is_quic(const SSL *s);
 __owur int SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx,
@@ -2015,6 +2107,15 @@ OSSL_DEPRECATEDIN_1_1_0 __owur const SSL
 OSSL_DEPRECATEDIN_1_1_0 __owur const SSL_METHOD *DTLSv1_2_client_method(void);
 #  endif
 # endif
+/*
+ * Have to write like this, because of make update can recognize
+ * this form only
+ */
+# ifndef OPENSSL_NO_NTLS
+__owur const SSL_METHOD *NTLS_method(void); /* NTLSv1.1 */
+__owur const SSL_METHOD *NTLS_server_method(void);
+__owur const SSL_METHOD *NTLS_client_method(void);
+# endif
 
 __owur const SSL_METHOD *DTLS_method(void); /* DTLS 1.0 and 1.2 */
 __owur const SSL_METHOD *DTLS_server_method(void); /* DTLS 1.0 and 1.2 */
@@ -2108,6 +2209,8 @@ __owur SSL_SESSION *SSL_get_session(cons
 __owur SSL_SESSION *SSL_get1_session(SSL *ssl); /* obtain a reference count */
 __owur SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);
 SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx);
+# define SSL_set_SESSION_CTX BABASSL_set_SESSION_CTX
+SSL_CTX *BABASSL_set_SESSION_CTX(SSL *ssl, SSL_CTX *ctx);
 void SSL_set_info_callback(SSL *ssl,
                            void (*cb) (const SSL *ssl, int type, int val));
 void (*SSL_get_info_callback(const SSL *ssl)) (const SSL *ssl, int type,
@@ -2687,6 +2790,45 @@ __owur int SSL_get0_server_cert_type(con
 __owur int SSL_CTX_get0_client_cert_type(const SSL_CTX *ctx, unsigned char **t, size_t *len);
 __owur int SSL_CTX_get0_server_cert_type(const SSL_CTX *s, unsigned char **t, size_t *len);
 
+# define SSL_client_hello_get1_extensions BABASSL_client_hello_get1_extensions
+int BABASSL_client_hello_get1_extensions(SSL *s, int **out, size_t *outlen);
+
+#  define SSL_get_use_certificate BABASSL_get_use_certificate
+X509 *BABASSL_get_use_certificate(const SSL *s);
+# define OPENSSL_GET_ALPN_PROPOSED  1
+# define SSL_get0_alpn_proposed BABASSL_get0_alpn_proposed
+void BABASSL_get0_alpn_proposed(const SSL *ssl, const unsigned char **data,
+                                unsigned *len);
+
+# define SSL_CTX_certs_clear BABASSL_CTX_certs_clear
+void BABASSL_CTX_certs_clear(SSL_CTX *ctx);
+
+# define OPENSSL_CHECK_TLSEXT_STATUS                      1
+# define SSL_check_tlsext_status BABASSL_check_tlsext_status
+int BABASSL_check_tlsext_status(SSL *s);
+
+# define SSL_get_master_key BABASSL_get_master_key
+int BABASSL_get_master_key(SSL *s, unsigned char **master_key,
+                           int *master_key_len);
+
+# define SSL_debug BABASSL_debug
+void BABASSL_debug(SSL *s, unsigned char *str, int len);
+
+# ifndef OPENSSL_NO_NTLS
+#  define SSL_get_sign_certificate_ntls BABASSL_get_sign_certificate_ntls
+#  define SSL_get_enc_certificate_ntls BABASSL_get_enc_certificate_ntls
+X509 *BABASSL_get_sign_certificate_ntls(const SSL *s);
+X509 *BABASSL_get_enc_certificate_ntls(const SSL *s);
+__owur int SSL_use_sign_certificate(SSL *ssl, X509 *x);
+__owur int SSL_use_sign_certificate_file(SSL *ssl, const char *file, int type);
+__owur int SSL_use_enc_certificate(SSL *ssl, X509 *x);
+__owur int SSL_use_enc_certificate_file(SSL *ssl, const char *file, int type);
+__owur int SSL_use_enc_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
+__owur int SSL_use_enc_PrivateKey_file(SSL *ssl, const char *file, int type);
+__owur int SSL_use_sign_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
+__owur int SSL_use_sign_PrivateKey_file(SSL *ssl, const char *file, int type);
+# endif
+
 # ifdef  __cplusplus
 }
 # endif
Index: b/include/openssl/tls1.h
===================================================================
--- a/include/openssl/tls1.h
+++ b/include/openssl/tls1.h
@@ -224,6 +224,9 @@ extern "C" {
 # define TLSEXT_curve_P_256                              23
 # define TLSEXT_curve_P_384                              24
 
+/* defined in RFC 8998 */
+# define TLSEXT_curve_SM2                                41
+
 /* OpenSSL value to disable maximum fragment length extension */
 # define TLSEXT_max_fragment_length_DISABLED    0
 /* Allowed values for max fragment length extension */
Index: b/include/openssl/x509.h.in
===================================================================
--- a/include/openssl/x509.h.in
+++ b/include/openssl/x509.h.in
@@ -585,6 +585,14 @@ ASN1_OCTET_STRING *X509_get0_distinguish
 void X509_REQ_set0_distinguishing_id(X509_REQ *x, ASN1_OCTET_STRING *d_id);
 ASN1_OCTET_STRING *X509_REQ_get0_distinguishing_id(X509_REQ *x);
 
+/* for compattibility usage */
+# ifndef OPENSSL_NO_SM2
+#  define X509_set0_sm2_id X509_set0_distinguishing_id
+#  define X509_get0_sm2_id X509_get0_distinguishing_id
+#  define X509_REQ_set0_sm2_id X509_REQ_set0_distinguishing_id
+#  define X509_REQ_get0_sm2_id X509_REQ_get0_distinguishing_id
+# endif
+
 int X509_alias_set1(X509 *x, const unsigned char *name, int len);
 int X509_keyid_set1(X509 *x, const unsigned char *id, int len);
 unsigned char *X509_alias_get0(X509 *x, int *len);
Index: b/providers/defltprov.c
===================================================================
--- a/providers/defltprov.c
+++ b/providers/defltprov.c
@@ -306,6 +306,7 @@ static const OSSL_ALGORITHM_CAPABLE defl
     ALG(PROV_NAMES_SM4_OFB, ossl_sm4128ofb128_functions),
     ALG(PROV_NAMES_SM4_CFB, ossl_sm4128cfb128_functions),
     ALG(PROV_NAMES_SM4_XTS, ossl_sm4128xts_functions),
+    ALG(PROV_NAMES_SM4_GCM, ossl_sm4128gcm_functions),
 #endif /* OPENSSL_NO_SM4 */
 #ifndef OPENSSL_NO_CHACHA
     ALG(PROV_NAMES_ChaCha20, ossl_chacha20_functions),
@@ -375,6 +376,9 @@ static const OSSL_ALGORITHM deflt_keyexc
     { PROV_NAMES_X448, "provider=default", ossl_x448_keyexch_functions },
 # endif
 #endif
+#ifndef OPENSSL_NO_SM2
+    { PROV_NAMES_SM2DH, "provider=default", ossl_sm2dh_keyexch_functions },
+#endif
     { PROV_NAMES_TLS1_PRF, "provider=default", ossl_kdf_tls1_prf_keyexch_functions },
     { PROV_NAMES_HKDF, "provider=default", ossl_kdf_hkdf_keyexch_functions },
     { PROV_NAMES_SCRYPT, "provider=default",
Index: b/providers/implementations/ciphers/ciphercommon_block.c
===================================================================
--- a/providers/implementations/ciphers/ciphercommon_block.c
+++ b/providers/implementations/ciphers/ciphercommon_block.c
@@ -152,6 +152,9 @@ int ossl_cipher_tlsunpadblock(OSSL_LIB_C
                                                alloced, blocksize, macsize,
                                                libctx);
 
+#ifndef OPENSSL_NO_NTLS
+    case NTLS1_1_VERSION:
+#endif
     case TLS1_2_VERSION:
     case DTLS1_2_VERSION:
     case TLS1_1_VERSION:
Index: b/providers/implementations/exchange/build.info
===================================================================
--- a/providers/implementations/exchange/build.info
+++ b/providers/implementations/exchange/build.info
@@ -5,6 +5,7 @@ $DH_GOAL=../../libdefault.a ../../libfip
 $ECDH_GOAL=../../libdefault.a ../../libfips.a
 $ECX_GOAL=../../libdefault.a ../../libfips.a
 $KDF_GOAL=../../libdefault.a ../../libfips.a
+$SM2DH_GOAL=../../libdefault.a
 
 IF[{- !$disabled{dh} -}]
   SOURCE[$DH_GOAL]=dh_exch.c
@@ -28,4 +29,8 @@ IF[{- !$disabled{ec} -}]
   SOURCE[$ECDH_GOAL]=ecdh_exch.c
 ENDIF
 
+IF[{- !$disabled{sm2} -}]
+  SOURCE[$SM2DH_GOAL]=sm2dh_exch.c
+ENDIF
+
 SOURCE[$KDF_GOAL]=kdf_exch.c
Index: b/providers/implementations/exchange/sm2dh_exch.c
===================================================================
--- /dev/null
+++ b/providers/implementations/exchange/sm2dh_exch.c
@@ -0,0 +1,478 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+/*
+ * SM2DH low level APIs are deprecated for public use, but still ok for
+ * internal use.
+ */
+#include "internal/deprecated.h"
+
+#include <string.h>
+#include <openssl/crypto.h>
+#include <openssl/evp.h>
+#include <openssl/core_dispatch.h>
+#include <openssl/core_names.h>
+#include <openssl/params.h>
+#include <openssl/err.h>
+#include <openssl/proverr.h>
+#include "prov/provider_ctx.h"
+#include "prov/providercommon.h"
+#include "prov/implementations.h"
+#include "prov/securitycheck.h"
+#include "crypto/evp.h"
+#include "crypto/ec.h"
+#include "crypto/sm2.h"
+
+static OSSL_FUNC_keyexch_newctx_fn sm2dh_newctx;
+static OSSL_FUNC_keyexch_init_fn sm2dh_init;
+static OSSL_FUNC_keyexch_set_peer_fn sm2dh_set_peer;
+static OSSL_FUNC_keyexch_derive_fn sm2dh_derive;
+static OSSL_FUNC_keyexch_freectx_fn sm2dh_freectx;
+static OSSL_FUNC_keyexch_dupctx_fn sm2dh_dupctx;
+static OSSL_FUNC_keyexch_set_ctx_params_fn sm2dh_set_ctx_params;
+static OSSL_FUNC_keyexch_settable_ctx_params_fn sm2dh_settable_ctx_params;
+static OSSL_FUNC_keyexch_get_ctx_params_fn sm2dh_get_ctx_params;
+static OSSL_FUNC_keyexch_gettable_ctx_params_fn sm2dh_gettable_ctx_params;
+
+/*
+ * What's passed as an actual key is defined by the KEYMGMT interface.
+ * We happen to know that our KEYMGMT simply passes EC_KEY structures, so
+ * we use that here too.
+ */
+
+typedef struct {
+    OSSL_LIB_CTX *libctx;
+
+    EC_KEY *k;
+    EC_KEY *peerk;
+
+    /* private key in self encryption certificate */
+    EC_KEY *enc_k;
+    /* public key in peer encryption certificate */
+    EC_KEY *enc_peerk;
+
+    uint8_t *id;
+    size_t id_len;
+
+    uint8_t *peer_id;
+    size_t peer_id_len;
+
+    int initiator;
+
+    EVP_MD *md;
+
+    size_t outlen;
+} PROV_SM2DH_CTX;
+
+static
+void *sm2dh_newctx(void *provctx)
+{
+    PROV_SM2DH_CTX *pectx;
+
+    if (!ossl_prov_is_running())
+        return NULL;
+
+    pectx = OPENSSL_zalloc(sizeof(*pectx));
+    if (pectx == NULL)
+        return NULL;
+
+    pectx->libctx = PROV_LIBCTX_OF(provctx);
+
+    return (void *)pectx;
+}
+
+static
+int ecdh_match_params(const EC_KEY *priv, const EC_KEY *peer)
+{
+    int ret;
+    BN_CTX *ctx = NULL;
+    const EC_GROUP *group_priv = EC_KEY_get0_group(priv);
+    const EC_GROUP *group_peer = EC_KEY_get0_group(peer);
+
+    ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(priv));
+    if (ctx == NULL) {
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    ret = group_priv != NULL
+          && group_peer != NULL
+          && EC_GROUP_cmp(group_priv, group_peer, ctx) == 0;
+    if (!ret)
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISMATCHING_DOMAIN_PARAMETERS);
+    BN_CTX_free(ctx);
+    return ret;
+}
+
+static
+int sm2dh_init(void *vpecdhctx, void *vecdh, const OSSL_PARAM params[])
+{
+    PROV_SM2DH_CTX *pecdhctx = (PROV_SM2DH_CTX *)vpecdhctx;
+
+    if (!ossl_prov_is_running()
+            || pecdhctx == NULL
+            || vecdh == NULL
+            || !EC_KEY_up_ref(vecdh))
+        return 0;
+
+    EC_KEY_free(pecdhctx->k);
+    pecdhctx->k = vecdh;
+
+    return sm2dh_set_ctx_params(pecdhctx, params)
+           && ossl_ec_check_key(pecdhctx->libctx, vecdh, 1)
+           && pecdhctx->enc_k != NULL
+           && pecdhctx->enc_peerk != NULL
+           && ecdh_match_params(pecdhctx->enc_k, pecdhctx->enc_peerk)
+           && ossl_ec_check_key(pecdhctx->libctx, pecdhctx->enc_k, 1)
+           && ossl_ec_check_key(pecdhctx->libctx, pecdhctx->enc_peerk, 1);
+}
+
+static
+int sm2dh_set_peer(void *vpecdhctx, void *vecdh)
+{
+    PROV_SM2DH_CTX *pecdhctx = (PROV_SM2DH_CTX *)vpecdhctx;
+
+    if (!ossl_prov_is_running()
+            || pecdhctx == NULL
+            || vecdh == NULL
+            || !ecdh_match_params(pecdhctx->k, vecdh)
+            || !ossl_ec_check_key(pecdhctx->libctx, vecdh, 1)
+            || !EC_KEY_up_ref(vecdh))
+        return 0;
+
+    EC_KEY_free(pecdhctx->peerk);
+    pecdhctx->peerk = vecdh;
+    return 1;
+}
+
+static
+void sm2dh_freectx(void *vpecdhctx)
+{
+    PROV_SM2DH_CTX *pecdhctx = (PROV_SM2DH_CTX *)vpecdhctx;
+
+    EC_KEY_free(pecdhctx->k);
+    EC_KEY_free(pecdhctx->peerk);
+
+    EC_KEY_free(pecdhctx->enc_k);
+    EC_KEY_free(pecdhctx->enc_peerk);
+
+    OPENSSL_free(pecdhctx->id);
+    OPENSSL_free(pecdhctx->peer_id);
+
+    EVP_MD_free(pecdhctx->md);
+
+    OPENSSL_free(pecdhctx);
+}
+
+static
+void *sm2dh_dupctx(void *vpecdhctx)
+{
+    PROV_SM2DH_CTX *srcctx = (PROV_SM2DH_CTX *)vpecdhctx;
+    PROV_SM2DH_CTX *dstctx;
+
+    if (!ossl_prov_is_running())
+        return NULL;
+
+    dstctx = OPENSSL_zalloc(sizeof(*srcctx));
+    if (dstctx == NULL)
+        return NULL;
+
+    *dstctx = *srcctx;
+
+    /* clear all pointers */
+    dstctx->k= NULL;
+    dstctx->peerk = NULL;
+    dstctx->enc_k = NULL;
+    dstctx->enc_peerk = NULL;
+    dstctx->md = NULL;
+    dstctx->id = NULL;
+    dstctx->peer_id = NULL;
+
+    /* up-ref all ref-counted objects referenced in dstctx */
+    if (srcctx->k != NULL && !EC_KEY_up_ref(srcctx->k))
+        goto err;
+    else
+        dstctx->k = srcctx->k;
+
+    if (srcctx->peerk != NULL && !EC_KEY_up_ref(srcctx->peerk))
+        goto err;
+    else
+        dstctx->peerk = srcctx->peerk;
+
+    if (srcctx->k != NULL && !EC_KEY_up_ref(srcctx->k))
+        goto err;
+    else
+        dstctx->k = srcctx->k;
+
+    if (srcctx->peerk != NULL && !EC_KEY_up_ref(srcctx->peerk))
+        goto err;
+    else
+        dstctx->peerk = srcctx->peerk;
+
+    if (srcctx->md != NULL && !EVP_MD_up_ref(srcctx->md))
+        goto err;
+    else
+        dstctx->md = srcctx->md;
+
+    if (srcctx->id != NULL && srcctx->id_len > 0) {
+        dstctx->id = OPENSSL_memdup(srcctx->id, srcctx->id_len);
+        if (dstctx->id == NULL)
+            goto err;
+    }
+
+    if (srcctx->peer_id != NULL && srcctx->peer_id_len > 0) {
+        dstctx->peer_id = OPENSSL_memdup(srcctx->peer_id, srcctx->peer_id_len);
+        if (dstctx->peer_id == NULL)
+            goto err;
+    }
+
+    return dstctx;
+
+ err:
+    sm2dh_freectx(dstctx);
+    return NULL;
+}
+
+static
+int sm2dh_set_ctx_params(void *vpecdhctx, const OSSL_PARAM params[])
+{
+    PROV_SM2DH_CTX *pectx = (PROV_SM2DH_CTX *)vpecdhctx;
+    const OSSL_PARAM *p;
+    EVP_PKEY *key = NULL;
+    void *tmp_id = NULL;
+    size_t tmp_len;
+    char name[80] = { '\0' }; /* should be big enough */
+    char *str = NULL;
+
+    if (pectx == NULL)
+        return 0;
+    if (params == NULL)
+        return 1;
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_INITIATOR);
+    if (p != NULL) {
+        int initiator;
+
+        if (!OSSL_PARAM_get_int(p, &initiator))
+            return 0;
+
+        pectx->initiator = initiator;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_SELF_ENC_KEY);
+    if (p != NULL) {
+        EVP_KEYMGMT *keymgmt = NULL;
+
+        if (!OSSL_PARAM_get_octet_ptr(p, (const void **)&key, NULL))
+            return 0;
+
+        if (key == NULL)
+            return 0;
+
+        EC_KEY_free(pectx->enc_k);
+
+        pectx->enc_k = (EC_KEY *)evp_pkey_export_to_provider(key, pectx->libctx,
+                                                             &keymgmt, NULL);
+        EVP_KEYMGMT_free(keymgmt);
+
+        if (pectx->enc_k == NULL)
+            return 0;
+        else
+            EC_KEY_up_ref(pectx->enc_k);
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_PEER_ENC_KEY);
+    if (p != NULL) {
+        EVP_KEYMGMT *keymgmt = NULL;
+
+        if (!OSSL_PARAM_get_octet_ptr(p, (const void **)&key, NULL))
+            return 0;
+
+        if (key == NULL)
+            return 0;
+
+        EC_KEY_free(pectx->enc_peerk);
+        pectx->enc_peerk = (EC_KEY *)evp_pkey_export_to_provider(key,
+                                                                 pectx->libctx,
+                                                                 &keymgmt,
+                                                                 NULL);
+        EVP_KEYMGMT_free(keymgmt);
+
+        if (pectx->enc_peerk == NULL)
+            return 0;
+        else
+            EC_KEY_up_ref(pectx->enc_peerk);
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_OUTLEN);
+    if (p != NULL) {
+        size_t outlen;
+
+        if (!OSSL_PARAM_get_size_t(p, &outlen))
+            return 0;
+        pectx->outlen = outlen;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_DIGEST);
+    if (p != NULL) {
+        char mdprops[80] = { '\0' }; /* should be big enough */
+
+        str = name;
+        if (!OSSL_PARAM_get_utf8_string(p, &str, sizeof(name)))
+            return 0;
+
+        str = mdprops;
+        p = OSSL_PARAM_locate_const(params,
+                                    OSSL_EXCHANGE_PARAM_DIGEST_PROPS);
+
+        if (p != NULL) {
+            if (!OSSL_PARAM_get_utf8_string(p, &str, sizeof(mdprops)))
+                return 0;
+        }
+
+        EVP_MD_free(pectx->md);
+        pectx->md = EVP_MD_fetch(pectx->libctx, name, mdprops);
+        if (!ossl_digest_is_allowed(pectx->libctx, pectx->md)) {
+            EVP_MD_free(pectx->md);
+            pectx->md = NULL;
+        }
+        if (pectx->md == NULL)
+            return 0;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_SELF_ID);
+    if (p != NULL) {
+        tmp_id = NULL;
+        if (!OSSL_PARAM_get_octet_string(p, &tmp_id, 0, &tmp_len))
+            return 0;
+
+        OPENSSL_free(pectx->id);
+        pectx->id = tmp_id;
+        pectx->id_len = tmp_len;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_PEER_ID);
+    if (p != NULL) {
+        tmp_id = NULL;
+        if (!OSSL_PARAM_get_octet_string(p, &tmp_id, 0, &tmp_len))
+            return 0;
+
+        OPENSSL_free(pectx->peer_id);
+        pectx->peer_id = tmp_id;
+        pectx->peer_id_len = tmp_len;
+    }
+
+    return 1;
+}
+
+static const OSSL_PARAM known_settable_ctx_params[] = {
+    OSSL_PARAM_int(OSSL_EXCHANGE_PARAM_INITIATOR, NULL),
+    OSSL_PARAM_octet_string(OSSL_EXCHANGE_PARAM_SELF_ID, NULL, 0),
+    OSSL_PARAM_octet_string(OSSL_EXCHANGE_PARAM_PEER_ID, NULL, 0),
+    OSSL_PARAM_octet_ptr(OSSL_EXCHANGE_PARAM_SELF_ENC_KEY, NULL, 0),
+    OSSL_PARAM_octet_ptr(OSSL_EXCHANGE_PARAM_PEER_ENC_KEY, NULL, 0),
+    OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_DIGEST, NULL, 0),
+    OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_DIGEST_PROPS, NULL, 0),
+    OSSL_PARAM_size_t(OSSL_EXCHANGE_PARAM_OUTLEN, NULL),
+    OSSL_PARAM_END
+};
+
+static
+const OSSL_PARAM *sm2dh_settable_ctx_params(ossl_unused void *vpecdhctx,
+                                            ossl_unused void *provctx)
+{
+    return known_settable_ctx_params;
+}
+
+static
+int sm2dh_get_ctx_params(void *vpecdhctx,
+                         OSSL_PARAM params[])
+{
+    PROV_SM2DH_CTX *pectx = (PROV_SM2DH_CTX *)vpecdhctx;
+    OSSL_PARAM *p;
+
+    if (pectx == NULL)
+        return 0;
+
+    p = OSSL_PARAM_locate(params, OSSL_EXCHANGE_PARAM_DIGEST);
+    if (p != NULL
+        && !OSSL_PARAM_set_utf8_string(p, pectx->md == NULL
+                                          ? ""
+                                          : EVP_MD_get0_name(pectx->md))){
+        return 0;
+    }
+
+    p = OSSL_PARAM_locate(params, OSSL_EXCHANGE_PARAM_OUTLEN);
+    if (p != NULL && !OSSL_PARAM_set_size_t(p, pectx->outlen))
+        return 0;
+
+    return 1;
+}
+
+static const OSSL_PARAM known_gettable_ctx_params[] = {
+    OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_DIGEST, NULL, 0),
+    OSSL_PARAM_size_t(OSSL_EXCHANGE_PARAM_OUTLEN, NULL),
+    OSSL_PARAM_END
+};
+
+static
+const OSSL_PARAM *sm2dh_gettable_ctx_params(ossl_unused void *vpecdhctx,
+                                            ossl_unused void *provctx)
+{
+    return known_gettable_ctx_params;
+}
+
+static
+int sm2dh_derive(void *vpecdhctx, unsigned char *secret,
+                size_t *psecretlen, size_t outlen)
+{
+    PROV_SM2DH_CTX *pecdhctx = (PROV_SM2DH_CTX *)vpecdhctx;
+
+    if (secret == NULL) {
+        *psecretlen = pecdhctx->outlen;
+        return 1;
+    }
+
+    if (pecdhctx->outlen > outlen) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+        return 0;
+    }
+
+    if (pecdhctx->k == NULL || pecdhctx->peerk == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_KEY);
+        return 0;
+    }
+
+    if (SM2_compute_key(secret, pecdhctx->outlen, pecdhctx->initiator,
+                        pecdhctx->peer_id, pecdhctx->peer_id_len,
+                        pecdhctx->id, pecdhctx->id_len,
+                        pecdhctx->peerk, pecdhctx->k,
+                        pecdhctx->enc_peerk, pecdhctx->enc_k,
+                        pecdhctx->md, pecdhctx->libctx, NULL) <= 0)
+        return 0;
+
+    *psecretlen = pecdhctx->outlen;
+
+    return 1;
+}
+
+const OSSL_DISPATCH ossl_sm2dh_keyexch_functions[] = {
+    { OSSL_FUNC_KEYEXCH_NEWCTX, (void (*)(void))sm2dh_newctx },
+    { OSSL_FUNC_KEYEXCH_INIT, (void (*)(void))sm2dh_init },
+    { OSSL_FUNC_KEYEXCH_DERIVE, (void (*)(void))sm2dh_derive },
+    { OSSL_FUNC_KEYEXCH_SET_PEER, (void (*)(void))sm2dh_set_peer },
+    { OSSL_FUNC_KEYEXCH_FREECTX, (void (*)(void))sm2dh_freectx },
+    { OSSL_FUNC_KEYEXCH_DUPCTX, (void (*)(void))sm2dh_dupctx },
+    { OSSL_FUNC_KEYEXCH_SET_CTX_PARAMS, (void (*)(void))sm2dh_set_ctx_params },
+    { OSSL_FUNC_KEYEXCH_SETTABLE_CTX_PARAMS,
+      (void (*)(void))sm2dh_settable_ctx_params },
+    { OSSL_FUNC_KEYEXCH_GET_CTX_PARAMS, (void (*)(void))sm2dh_get_ctx_params },
+    { OSSL_FUNC_KEYEXCH_GETTABLE_CTX_PARAMS,
+      (void (*)(void))sm2dh_gettable_ctx_params },
+    { 0, NULL }
+};
Index: b/providers/implementations/include/prov/implementations.h
===================================================================
--- a/providers/implementations/include/prov/implementations.h
+++ b/providers/implementations/include/prov/implementations.h
@@ -187,6 +187,7 @@ extern const OSSL_DISPATCH ossl_sm4128ct
 extern const OSSL_DISPATCH ossl_sm4128ofb128_functions[];
 extern const OSSL_DISPATCH ossl_sm4128cfb128_functions[];
 extern const OSSL_DISPATCH ossl_sm4128xts_functions[];
+extern const OSSL_DISPATCH ossl_sm4128gcm_functions[];
 #endif /* OPENSSL_NO_SM4 */
 #ifndef OPENSSL_NO_RC5
 extern const OSSL_DISPATCH ossl_rc5128ecb_functions[];
@@ -320,6 +321,9 @@ extern const OSSL_DISPATCH ossl_dh_keyex
 extern const OSSL_DISPATCH ossl_x25519_keyexch_functions[];
 extern const OSSL_DISPATCH ossl_x448_keyexch_functions[];
 extern const OSSL_DISPATCH ossl_ecdh_keyexch_functions[];
+#ifndef OPENSSL_NO_SM2
+extern const OSSL_DISPATCH ossl_sm2dh_keyexch_functions[];
+#endif
 extern const OSSL_DISPATCH ossl_kdf_tls1_prf_keyexch_functions[];
 extern const OSSL_DISPATCH ossl_kdf_hkdf_keyexch_functions[];
 extern const OSSL_DISPATCH ossl_kdf_scrypt_keyexch_functions[];
Index: b/providers/implementations/include/prov/names.h
===================================================================
--- a/providers/implementations/include/prov/names.h
+++ b/providers/implementations/include/prov/names.h
@@ -342,3 +342,5 @@
 #define PROV_DESCS_RSA_PSS "OpenSSL RSA-PSS implementation"
 #define PROV_NAMES_SM2 "SM2:1.2.156.10197.1.301"
 #define PROV_DESCS_SM2 "OpenSSL SM2 implementation"
+#define PROV_NAMES_SM2DH "SM2DH"
+#define PROV_DESCS_SM2DH "Tongsuo SM2DH implementation"
Index: b/providers/implementations/keymgmt/ec_kmgmt.c
===================================================================
--- a/providers/implementations/keymgmt/ec_kmgmt.c
+++ b/providers/implementations/keymgmt/ec_kmgmt.c
@@ -92,6 +92,8 @@ static
 const char *sm2_query_operation_name(int operation_id)
 {
     switch (operation_id) {
+    case OSSL_OP_KEYEXCH:
+        return "SM2DH";
     case OSSL_OP_SIGNATURE:
         return "SM2";
     }
Index: b/ssl/methods.c
===================================================================
--- a/ssl/methods.c
+++ b/ssl/methods.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2022 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -173,6 +173,24 @@ IMPLEMENT_dtls1_meth_func(DTLS_ANY_VERSI
                           DTLS_client_method,
                           ssl_undefined_function,
                           ossl_statem_connect, DTLSv1_2_enc_data)
+
+#ifndef OPENSSL_NO_NTLS
+IMPLEMENT_tls_meth_func(NTLS_VERSION, SSL_METHOD_NO_SUITEB, SSL_OP_NO_NTLS,
+                        ntls_method,
+                        ossl_statem_accept,
+                        ossl_statem_connect, NTLS_enc_data)
+
+IMPLEMENT_tls_meth_func(NTLS_VERSION, SSL_METHOD_NO_SUITEB, SSL_OP_NO_NTLS,
+                        ntls_server_method,
+                        ossl_statem_accept,
+                        ssl_undefined_function, NTLS_enc_data)
+
+IMPLEMENT_tls_meth_func(NTLS_VERSION, SSL_METHOD_NO_SUITEB, SSL_OP_NO_NTLS,
+                        ntls_client_method,
+                        ssl_undefined_function,
+                        ossl_statem_connect, NTLS_enc_data)
+#endif
+
 #ifndef OPENSSL_NO_DEPRECATED_1_1_0
 # ifndef OPENSSL_NO_TLS1_2_METHOD
 const SSL_METHOD *TLSv1_2_method(void)
@@ -276,4 +294,21 @@ const SSL_METHOD *DTLSv1_client_method(v
 }
 # endif
 
+# ifndef OPENSSL_NO_NTLS
+const SSL_METHOD *NTLS_method(void)
+{
+    return ntls_method();
+}
+
+const SSL_METHOD *NTLS_server_method(void)
+{
+    return ntls_server_method();
+}
+
+const SSL_METHOD *NTLS_client_method(void)
+{
+    return ntls_client_method();
+}
+# endif
+
 #endif
Index: b/ssl/s3_lib.c
===================================================================
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -3212,6 +3212,142 @@ static SSL_CIPHER ssl3_ciphers[] = {
      256,
      256,
      },
+#ifndef OPENSSL_NO_NTLS
+# ifndef OPENSSL_NO_SM4
+#  ifndef OPENSSL_NO_SM3
+#   ifndef OPENSSL_NO_SM2
+    {
+     1,
+     NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3,
+     NTLS_GB_ECDHE_SM2_SM4_CBC_SM3,
+     NTLS_CK_ECDHE_SM2_SM4_CBC_SM3,
+     SSL_kSM2DHE,
+     SSL_aSM2,
+     SSL_SM4,
+     SSL_SM3,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3,
+     128,
+     128,
+     },
+    {
+     1,
+     NTLS_TXT_ECDHE_SM2_SM4_GCM_SM3,
+     NTLS_GB_ECDHE_SM2_SM4_GCM_SM3,
+     NTLS_CK_ECDHE_SM2_SM4_GCM_SM3,
+     SSL_kSM2DHE,
+     SSL_aSM2,
+     SSL_SM4GCM,
+     SSL_AEAD,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3,
+     128,
+     128,
+    },
+    {
+     1,
+     NTLS_TXT_ECC_SM2_SM4_CBC_SM3,
+     NTLS_GB_ECC_SM2_SM4_CBC_SM3,
+     NTLS_CK_ECC_SM2_SM4_CBC_SM3,
+     SSL_kSM2,
+     SSL_aSM2,
+     SSL_SM4,
+     SSL_SM3,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3,
+     128,
+     128,
+     },
+    {
+     1,
+     NTLS_TXT_ECC_SM2_SM4_GCM_SM3,
+     NTLS_GB_ECC_SM2_SM4_GCM_SM3,
+     NTLS_CK_ECC_SM2_SM4_GCM_SM3,
+     SSL_kSM2,
+     SSL_aSM2,
+     SSL_SM4GCM,
+     SSL_AEAD,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3,
+     128,
+     128,
+    },
+#   endif   /* OPENSSL_NO_SM2 */
+    {
+     1,
+     NTLS_TXT_RSA_SM4_CBC_SM3,
+     NTLS_GB_RSA_SM4_CBC_SM3,
+     NTLS_CK_RSA_SM4_CBC_SM3,
+     SSL_kRSA,
+     SSL_aRSA,
+     SSL_SM4,
+     SSL_SM3,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3,
+     128,
+     128,
+    },
+    {
+     1,
+     NTLS_TXT_RSA_SM4_GCM_SM3,
+     NTLS_GB_RSA_SM4_GCM_SM3,
+     NTLS_CK_RSA_SM4_GCM_SM3,
+     SSL_kRSA,
+     SSL_aRSA,
+     SSL_SM4GCM,
+     SSL_AEAD,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3,
+     128,
+     128,
+    },
+#  endif    /* OPENSSL_NO_SM3 */
+    {
+     1,
+     NTLS_TXT_RSA_SM4_CBC_SHA256,
+     NTLS_GB_RSA_SM4_CBC_SHA256,
+     NTLS_CK_RSA_SM4_CBC_SHA256,
+     SSL_kRSA,
+     SSL_aRSA,
+     SSL_SM4,
+     SSL_SHA256,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256,
+     128,
+     128,
+    },
+    {
+     1,
+     NTLS_TXT_RSA_SM4_GCM_SHA256,
+     NTLS_GB_RSA_SM4_GCM_SHA256,
+     NTLS_CK_RSA_SM4_GCM_SHA256,
+     SSL_kRSA,
+     SSL_aRSA,
+     SSL_SM4GCM,
+     SSL_AEAD,
+     NTLS_VERSION, NTLS_VERSION,
+     0, 0,
+     SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256,
+     128,
+     128,
+    },
+# endif /* OPENSSL_NO_SM4 */
+#endif  /* OPENSSL_NO_NTLS */
 };
 
 /*
@@ -4410,14 +4546,23 @@ int ssl3_get_req_cert_type(SSL_CONNECTIO
     }
     if (!(alg_a & SSL_aRSA) && !WPACKET_put_bytes_u8(pkt, SSL3_CT_RSA_SIGN))
         return 0;
-    if (!(alg_a & SSL_aDSS) && !WPACKET_put_bytes_u8(pkt, SSL3_CT_DSS_SIGN))
+    if (!(alg_a & SSL_aDSS)
+#ifndef OPENSSL_NO_NTLS
+        /* TLCP not define DSS sign */
+        && !SSL_CONNECTION_IS_NTLS(s)
+#endif
+        && !WPACKET_put_bytes_u8(pkt, SSL3_CT_DSS_SIGN))
         return 0;
 
     /*
      * ECDSA certs can be used with RSA cipher suites too so we don't
      * need to check for SSL_kECDH or SSL_kECDHE
      */
-    if (s->version >= TLS1_VERSION
+    if ((s->version >= TLS1_VERSION
+#if (!defined OPENSSL_NO_NTLS) && (!defined OPENSSL_NO_SM2)
+        || SSL_CONNECTION_IS_NTLS(s)
+#endif
+        )
             && !(alg_a & SSL_aECDSA)
             && !WPACKET_put_bytes_u8(pkt, TLS_CT_ECDSA_SIGN))
         return 0;
Index: b/ssl/ssl_asn1.c
===================================================================
--- a/ssl/ssl_asn1.c
+++ b/ssl/ssl_asn1.c
@@ -288,6 +288,9 @@ SSL_SESSION *d2i_SSL_SESSION_ex(SSL_SESS
     }
 
     if ((as->ssl_version >> 8) != SSL3_VERSION_MAJOR
+#ifndef OPENSSL_NO_NTLS
+        && as->ssl_version != NTLS_VERSION
+#endif
         && (as->ssl_version >> 8) != DTLS1_VERSION_MAJOR
         && as->ssl_version != DTLS1_BAD_VER) {
         ERR_raise(ERR_LIB_SSL, SSL_R_UNSUPPORTED_SSL_VERSION);
Index: b/ssl/ssl_cert.c
===================================================================
--- a/ssl/ssl_cert.c
+++ b/ssl/ssl_cert.c
@@ -531,6 +531,16 @@ int ssl_verify_rpk(SSL_CONNECTION *s, EV
     return ssl_verify_internal(s, NULL, rpk);
 }
 
+SSL_cert_cb_fn ssl_cert_get_cert_cb(CERT *c)
+{
+    return c->cert_cb;
+}
+
+void *ssl_cert_get_cert_cb_arg(CERT *c)
+{
+    return c->cert_cb_arg;
+}
+
 /*
  * Verify a certificate chain
  * Return codes:
@@ -1174,7 +1184,11 @@ static int ssl_security_default_callback
             if (minbits > 160 && c->algorithm_mac & SSL_SHA1)
                 return 0;
             /* Level 3: forward secure ciphersuites only */
+#ifndef OPENSSL_NO_NTLS
+            pfs_mask = SSL_kDHE | SSL_kECDHE | SSL_kDHEPSK | SSL_kECDHEPSK | SSL_kSM2DHE;
+#else
             pfs_mask = SSL_kDHE | SSL_kECDHE | SSL_kDHEPSK | SSL_kECDHEPSK;
+#endif
             if (level >= 3 && c->min_tls != TLS1_3_VERSION &&
                                !(c->algorithm_mkey & pfs_mask))
                 return 0;
@@ -1184,6 +1198,13 @@ static int ssl_security_default_callback
         if ((sc = SSL_CONNECTION_FROM_CONST_SSL(s)) == NULL)
             return 0;
         if (!SSL_CONNECTION_IS_DTLS(sc)) {
+#ifndef OPENSSL_NO_NTLS
+            /* NTLS v1.1 not allowed at level 3 */
+            if (nid == NTLS_VERSION && level >= 3)
+                return 0;
+            if (nid == NTLS_VERSION)
+                break;
+#endif
             /* SSLv3, TLS v1.0 and TLS v1.1 only allowed at level 0 */
             if (nid <= TLS1_1_VERSION && level > 0)
                 return 0;
Index: b/ssl/ssl_cert_table.h
===================================================================
--- a/ssl/ssl_cert_table.h
+++ b/ssl/ssl_cert_table.h
@@ -19,5 +19,12 @@ static SSL_CERT_LOOKUP ssl_cert_info []
     {NID_id_GostR3410_2012_256, SSL_aGOST12}, /* SSL_PKEY_GOST12_256 */
     {NID_id_GostR3410_2012_512, SSL_aGOST12}, /* SSL_PKEY_GOST12_512 */
     {EVP_PKEY_ED25519, SSL_aECDSA}, /* SSL_PKEY_ED25519 */
-    {EVP_PKEY_ED448, SSL_aECDSA} /* SSL_PKEY_ED448 */
+    {EVP_PKEY_ED448, SSL_aECDSA}, /* SSL_PKEY_ED448 */
+    {EVP_PKEY_SM2, SSL_aSM2}, /* SSL_PKEY_ECC SM2 */
+#ifndef OPENSSL_NO_NTLS
+    {EVP_PKEY_SM2, SSL_aSM2}, /* SSL_PKEY_SM2_SIGN */
+    {EVP_PKEY_SM2, SSL_aSM2}, /* SSL_PKEY_SM2_ENC */
+    {EVP_PKEY_RSA, SSL_aRSA}, /* SSL_PKEY_RSA_SIGN */
+    {EVP_PKEY_RSA, SSL_aRSA}, /* SSL_PKEY_RSA_ENC */
+#endif
 };
Index: b/ssl/ssl_ciph.c
===================================================================
--- a/ssl/ssl_ciph.c
+++ b/ssl/ssl_ciph.c
@@ -55,6 +55,11 @@ static const ssl_cipher_table ssl_cipher
     {SSL_ARIA256GCM, NID_aria_256_gcm}, /* SSL_ENC_ARIA256GCM_IDX 21 */
     {SSL_MAGMA, NID_magma_ctr_acpkm}, /* SSL_ENC_MAGMA_IDX */
     {SSL_KUZNYECHIK, NID_kuznyechik_ctr_acpkm}, /* SSL_ENC_KUZNYECHIK_IDX */
+    {SSL_SM4GCM, NID_sm4_gcm}, /* SSL_ENC_SM4_GCM_IDX */
+    {SSL_SM4CCM, NID_sm4_ccm}, /* SSL_ENC_SM4_CCM_IDX */
+#ifndef OPENSSL_NO_SM4
+    {SSL_SM4, NID_sm4_cbc}     /* SSL_ENC_SM4_IDX */
+#endif
 };
 
 #define SSL_COMP_NULL_IDX       0
@@ -82,7 +87,8 @@ static const ssl_cipher_table ssl_cipher
     {0, NID_sha224},            /* SSL_MD_SHA224_IDX 10 */
     {0, NID_sha512},            /* SSL_MD_SHA512_IDX 11 */
     {SSL_MAGMAOMAC, NID_magma_mac}, /* sSL_MD_MAGMAOMAC_IDX */
-    {SSL_KUZNYECHIKOMAC, NID_kuznyechik_mac} /* SSL_MD_KUZNYECHIKOMAC_IDX */
+    {SSL_KUZNYECHIKOMAC, NID_kuznyechik_mac}, /* SSL_MD_KUZNYECHIKOMAC_IDX */
+    {SSL_SM3, NID_sm3}          /* SSL_MD_SM3 */
 };
 
 /* *INDENT-OFF* */
@@ -97,6 +103,8 @@ static const ssl_cipher_table ssl_cipher
     {SSL_kSRP,      NID_kx_srp},
     {SSL_kGOST,     NID_kx_gost},
     {SSL_kGOST18,   NID_kx_gost18},
+    {SSL_kSM2,      NID_kx_sm2},
+    {SSL_kSM2DHE,   NID_kx_sm2dhe},
     {SSL_kANY,      NID_kx_any}
 };
 
@@ -108,6 +116,7 @@ static const ssl_cipher_table ssl_cipher
     {SSL_aGOST01, NID_auth_gost01},
     {SSL_aGOST12, NID_auth_gost12},
     {SSL_aSRP,    NID_auth_srp},
+    {SSL_aSM2,    NID_auth_sm2},
     {SSL_aNULL,   NID_auth_null},
     {SSL_aANY,    NID_auth_any}
 };
@@ -141,7 +150,9 @@ static const int default_mac_pkey_id[SSL
     /* GOST2012_512 */
     EVP_PKEY_HMAC,
     /* MD5/SHA1, SHA224, SHA512, MAGMAOMAC, KUZNYECHIKOMAC */
-    NID_undef, NID_undef, NID_undef, NID_undef, NID_undef
+    NID_undef, NID_undef, NID_undef, NID_undef, NID_undef,
+	/* SM3 */
+	EVP_PKEY_HMAC
 };
 
 #define CIPHER_ADD      1
@@ -196,6 +207,16 @@ static const SSL_CIPHER cipher_aliases[]
     {0, SSL_TXT_kSRP, NULL, 0, SSL_kSRP},
     {0, SSL_TXT_kGOST, NULL, 0, SSL_kGOST},
     {0, SSL_TXT_kGOST18, NULL, 0, SSL_kGOST18},
+#ifndef OPENSSL_NO_NTLS
+    {0, SSL_TXT_kSM2, NULL, 0, SSL_kSM2},
+    {0, SSL_TXT_kSM2DHE, NULL, 0, SSL_kSM2DHE},
+    {0, NTLS_TXT_SM2DHE_WITH_SM4_SM3, NULL, 0, SSL_kSM2DHE, SSL_aSM2, SSL_SM4,
+     SSL_SM3, NTLS_VERSION, NTLS_VERSION, 0, 0, SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3, 128, 128},
+    {0, NTLS_TXT_SM2_WITH_SM4_SM3, NULL, 0, SSL_kSM2, SSL_aSM2, SSL_SM4,
+     SSL_SM3, NTLS_VERSION, NTLS_VERSION, 0, 0, SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SM3 | TLS1_PRF_SM3, 128, 128},
+#endif
 
     /* server authentication aliases */
     {0, SSL_TXT_aRSA, NULL, 0, 0, SSL_aRSA},
@@ -209,6 +230,7 @@ static const SSL_CIPHER cipher_aliases[]
     {0, SSL_TXT_aGOST12, NULL, 0, 0, SSL_aGOST12},
     {0, SSL_TXT_aGOST, NULL, 0, 0, SSL_aGOST01 | SSL_aGOST12},
     {0, SSL_TXT_aSRP, NULL, 0, 0, SSL_aSRP},
+    {0, SSL_TXT_aSM2, NULL, 0, 0, SSL_aSM2},
 
     /* aliases combining key exchange and server authentication */
     {0, SSL_TXT_EDH, NULL, 0, SSL_kDHE, ~SSL_aNULL},
@@ -251,7 +273,7 @@ static const SSL_CIPHER cipher_aliases[]
     {0, SSL_TXT_ARIA128, NULL, 0, 0, 0, SSL_ARIA128GCM},
     {0, SSL_TXT_ARIA256, NULL, 0, 0, 0, SSL_ARIA256GCM},
     {0, SSL_TXT_CBC, NULL, 0, 0, 0, SSL_CBC},
-
+    {0, SSL_TXT_SM4, NULL, 0, 0, 0, SSL_SM4},
     /* MAC aliases */
     {0, SSL_TXT_MD5, NULL, 0, 0, 0, 0, SSL_MD5},
     {0, SSL_TXT_SHA1, NULL, 0, 0, 0, 0, SSL_SHA1},
@@ -261,12 +283,16 @@ static const SSL_CIPHER cipher_aliases[]
     {0, SSL_TXT_SHA256, NULL, 0, 0, 0, 0, SSL_SHA256},
     {0, SSL_TXT_SHA384, NULL, 0, 0, 0, 0, SSL_SHA384},
     {0, SSL_TXT_GOST12, NULL, 0, 0, 0, 0, SSL_GOST12_256},
+    {0, SSL_TXT_SM3, NULL, 0, 0, 0, 0, SSL_SM3},
 
     /* protocol version aliases */
     {0, SSL_TXT_SSLV3, NULL, 0, 0, 0, 0, 0, SSL3_VERSION},
     {0, SSL_TXT_TLSV1, NULL, 0, 0, 0, 0, 0, TLS1_VERSION},
     {0, "TLSv1.0", NULL, 0, 0, 0, 0, 0, TLS1_VERSION},
     {0, SSL_TXT_TLSV1_2, NULL, 0, 0, 0, 0, 0, TLS1_2_VERSION},
+#ifndef OPENSSL_NO_NTLS
+    {0, SSL_TXT_NTLSV1_1, NULL, 0, 0, 0, 0, 0, NTLS1_1_VERSION},
+#endif
 
     /* strength classes */
     {0, SSL_TXT_LOW, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, SSL_LOW},
@@ -381,6 +407,16 @@ int ssl_load_ciphers(SSL_CTX *ctx)
         ctx->disabled_auth_mask |= SSL_aECDSA;
     else
         EVP_SIGNATURE_free(sig);
+    kex = EVP_KEYEXCH_fetch(ctx->libctx, "SM2DH", ctx->propq);
+    if (kex == NULL)
+        ctx->disabled_mkey_mask |= SSL_kSM2DHE;
+    else
+        EVP_KEYEXCH_free(kex);
+    sig = EVP_SIGNATURE_fetch(ctx->libctx, "SM2", ctx->propq);
+    if (sig == NULL)
+        ctx->disabled_auth_mask |= SSL_aSM2;
+    else
+        EVP_SIGNATURE_free(sig);
     ERR_pop_to_mark();
 
 #ifdef OPENSSL_NO_PSK
@@ -1756,6 +1792,12 @@ char *SSL_CIPHER_description(const SSL_C
     case SSL_kGOST18:
         kx = "GOST18";
         break;
+    case SSL_kSM2:
+        kx = "SM2";
+        break;
+    case SSL_kSM2DHE:
+        kx = "SM2DHE";
+        break;
     case SSL_kANY:
         kx = "any";
         break;
@@ -1789,6 +1831,9 @@ char *SSL_CIPHER_description(const SSL_C
     case (SSL_aGOST12 | SSL_aGOST01):
         au = "GOST12";
         break;
+    case SSL_aSM2:
+        au = "SM2";
+        break;
     case SSL_aANY:
         au = "any";
         break;
@@ -1868,6 +1913,15 @@ char *SSL_CIPHER_description(const SSL_C
     case SSL_CHACHA20POLY1305:
         enc = "CHACHA20/POLY1305(256)";
         break;
+    case SSL_SM4CCM:
+        enc = "SM4-CCM(128)";
+        break;
+    case SSL_SM4GCM:
+        enc = "SM4-GCM(128)";
+        break;
+    case SSL_SM4:
+        enc = "SM4(128)";
+        break;
     default:
         enc = "unknown";
         break;
@@ -1900,6 +1954,9 @@ char *SSL_CIPHER_description(const SSL_C
     case SSL_GOST12_512:
         mac = "GOST2012";
         break;
+    case SSL_SM3:
+        mac = "SM3";
+        break;
     default:
         mac = "unknown";
         break;
@@ -2267,3 +2324,23 @@ const char *OSSL_default_ciphersuites(vo
            "TLS_CHACHA20_POLY1305_SHA256:"
            "TLS_AES_128_GCM_SHA256";
 }
+
+unsigned long BABASSL_CIPHER_get_mkey(const SSL_CIPHER *c)
+{
+    return c->algorithm_mkey;
+}
+
+unsigned long BABASSL_CIPHER_get_auth(const SSL_CIPHER *c)
+{
+    return c->algorithm_auth;
+}
+
+unsigned long BABASSL_CIPHER_get_enc(const SSL_CIPHER *c)
+{
+    return c->algorithm_enc;
+}
+
+unsigned long BABASSL_CIPHER_get_mac(const SSL_CIPHER *c)
+{
+    return c->algorithm_mac;
+}
Index: b/ssl/ssl_conf.c
===================================================================
--- a/ssl/ssl_conf.c
+++ b/ssl/ssl_conf.c
@@ -318,7 +318,11 @@ static int protocol_from_string(const ch
         {"TLSv1.2", TLS1_2_VERSION},
         {"TLSv1.3", TLS1_3_VERSION},
         {"DTLSv1", DTLS1_VERSION},
-        {"DTLSv1.2", DTLS1_2_VERSION}
+        {"DTLSv1.2", DTLS1_2_VERSION},
+#ifndef OPENSSL_NO_NTLS
+        {"NTLS", NTLS_VERSION},
+        {"MIN_VERSION_WITH_NTLS", MIN_VERSION_WITH_NTLS}
+#endif
     };
     size_t i;
     size_t n = OSSL_NELEM(versions);
@@ -473,6 +477,107 @@ static int cmd_PrivateKey(SSL_CONF_CTX *
     return rv > 0;
 }
 
+#ifndef OPENSSL_NO_NTLS
+static int cmd_EncCertificate(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 1;
+    CERT *c = NULL;
+
+    if (cctx->ctx) {
+        /* FIXME: currently we assume all SM2 certs in PEM format */
+        rv = SSL_CTX_use_enc_certificate_file(cctx->ctx, value,
+                                              SSL_FILETYPE_PEM);
+        c = cctx->ctx->cert;
+    }
+
+    if (cctx->ssl) {
+        /* FIXME: setting certificates for SSL is not supported yet */
+        rv = 0;
+    }
+
+    if (rv > 0 && c && cctx->flags & SSL_CONF_FLAG_REQUIRE_PRIVATE) {
+        char **pfilename = &cctx->cert_filename[c->key - c->pkeys];
+        OPENSSL_free(*pfilename);
+        *pfilename = OPENSSL_strdup(value);
+        if (!*pfilename)
+            rv = 0;
+    }
+
+    return rv > 0;
+}
+
+static int cmd_EncPrivateKey(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 1;
+    if (!(cctx->flags & SSL_CONF_FLAG_CERTIFICATE))
+        return -2;
+    if (cctx->ctx)
+        rv = SSL_CTX_use_enc_PrivateKey_file(cctx->ctx, value, SSL_FILETYPE_PEM);
+    if (cctx->ssl)
+        rv = 0;
+    return rv > 0;
+}
+
+static int cmd_SignCertificate(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 1;
+    CERT *c = NULL;
+
+    if (cctx->ctx) {
+        /* FIXME: currently we assume all sign certs in PEM format */
+        rv = SSL_CTX_use_sign_certificate_file(cctx->ctx, value,
+                                               SSL_FILETYPE_PEM);
+        c = cctx->ctx->cert;
+    }
+
+    if (cctx->ssl) {
+        /* FIXME: setting certificates for SSL is not supported yet */
+        rv = 0;
+    }
+
+    if (rv > 0 && c && cctx->flags & SSL_CONF_FLAG_REQUIRE_PRIVATE) {
+        char **pfilename = &cctx->cert_filename[c->key - c->pkeys];
+        OPENSSL_free(*pfilename);
+        *pfilename = OPENSSL_strdup(value);
+        if (!*pfilename)
+            rv = 0;
+    }
+
+    return rv > 0;
+}
+
+static int cmd_SignPrivateKey(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 1;
+    if (!(cctx->flags & SSL_CONF_FLAG_CERTIFICATE))
+        return -2;
+    if (cctx->ctx)
+        rv = SSL_CTX_use_sign_PrivateKey_file(cctx->ctx, value,
+                                              SSL_FILETYPE_PEM);
+    if (cctx->ssl)
+        rv = 0;
+    return rv > 0;
+}
+#endif
+
+#ifndef OPENSSL_NO_SM2
+static int cmd_Enable_sm_tls13_strict(SSL_CONF_CTX *cctx, const char *value)
+{
+    if (strcmp(value, "on") == 0) {
+        if (cctx->ctx)
+            SSL_CTX_enable_sm_tls13_strict(cctx->ctx);
+        if (cctx->ssl)
+            SSL_enable_sm_tls13_strict(cctx->ssl);
+    } else {
+        if (cctx->ctx)
+            SSL_CTX_disable_sm_tls13_strict(cctx->ctx);
+        if (cctx->ssl)
+            SSL_disable_sm_tls13_strict(cctx->ssl);
+    }
+    return 1;
+}
+#endif
+
 static int cmd_ServerInfoFile(SSL_CONF_CTX *cctx, const char *value)
 {
     int rv = 1;
@@ -681,6 +786,23 @@ static int cmd_NumTickets(SSL_CONF_CTX *
     return rv;
 }
 
+#ifndef OPENSSL_NO_NTLS
+static int cmd_Enable_ntls(SSL_CONF_CTX *cctx, const char *value)
+{
+    if (strcmp(value, "on") == 0) {
+        if (cctx->ctx)
+            SSL_CTX_enable_ntls(cctx->ctx);
+        if (cctx->ssl)
+            SSL_enable_ntls(cctx->ssl);
+    } else {
+        if (cctx->ctx)
+            SSL_CTX_disable_ntls(cctx->ctx);
+        if (cctx->ssl)
+            SSL_disable_ntls(cctx->ssl);
+    }
+    return 1;
+}
+#endif
 typedef struct {
     int (*cmd) (SSL_CONF_CTX *cctx, const char *value);
     const char *str_file;
@@ -708,6 +830,9 @@ static const ssl_conf_cmd_tbl ssl_conf_c
     SSL_CONF_CMD_SWITCH("no_tls1_1", 0),
     SSL_CONF_CMD_SWITCH("no_tls1_2", 0),
     SSL_CONF_CMD_SWITCH("no_tls1_3", 0),
+#ifndef OPENSSL_NO_NTLS
+    SSL_CONF_CMD_SWITCH("no_ntls", 0),
+#endif
     SSL_CONF_CMD_SWITCH("bugs", 0),
     SSL_CONF_CMD_SWITCH("no_comp", 0),
     SSL_CONF_CMD_SWITCH("comp", 0),
@@ -783,6 +908,20 @@ static const ssl_conf_cmd_tbl ssl_conf_c
                  SSL_CONF_TYPE_FILE),
     SSL_CONF_CMD_STRING(RecordPadding, "record_padding", 0),
     SSL_CONF_CMD_STRING(NumTickets, "num_tickets", SSL_CONF_FLAG_SERVER),
+#ifndef OPENSSL_NO_NTLS
+    SSL_CONF_CMD_STRING(Enable_ntls, "enable_ntls", 0),
+    SSL_CONF_CMD(EncCertificate, "enc_cert", SSL_CONF_FLAG_CERTIFICATE,
+                 SSL_CONF_TYPE_FILE),
+    SSL_CONF_CMD(EncPrivateKey, "enc_key", SSL_CONF_FLAG_CERTIFICATE,
+                 SSL_CONF_TYPE_FILE),
+    SSL_CONF_CMD(SignCertificate, "sign_cert", SSL_CONF_FLAG_CERTIFICATE,
+                 SSL_CONF_TYPE_FILE),
+    SSL_CONF_CMD(SignPrivateKey, "sign_key", SSL_CONF_FLAG_CERTIFICATE,
+                 SSL_CONF_TYPE_FILE),
+#endif
+#ifndef OPENSSL_NO_SM2
+    SSL_CONF_CMD_STRING(Enable_sm_tls13_strict, "Enable_sm_tls13_strict", 0),
+#endif
 };
 
 /* Supported switches: must match order of switches in ssl_conf_cmds */
@@ -792,6 +931,9 @@ static const ssl_switch_tbl ssl_cmd_swit
     {SSL_OP_NO_TLSv1_1, 0},     /* no_tls1_1 */
     {SSL_OP_NO_TLSv1_2, 0},     /* no_tls1_2 */
     {SSL_OP_NO_TLSv1_3, 0},     /* no_tls1_3 */
+#ifndef OPENSSL_NO_NTLS
+    {SSL_OP_NO_NTLS, 0},        /* no_ntls */
+#endif
     {SSL_OP_ALL, 0},            /* bugs */
     {SSL_OP_NO_COMPRESSION, 0}, /* no_comp */
     {SSL_OP_NO_COMPRESSION, SSL_TFLAG_INV}, /* comp */
Index: b/ssl/ssl_lib.c
===================================================================
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -540,8 +540,13 @@ static int ssl_check_allowed_versions(in
 #ifdef OPENSSL_NO_TLS1_3
             || (min_version <= TLS1_3_VERSION && TLS1_3_VERSION <= max_version)
 #endif
-            )
+            ) {
+#ifndef OPENSSL_NO_NTLS
+            if (min_version == NTLS_VERSION || max_version == NTLS_VERSION)
+                return 1;
+#endif
             return 0;
+        }
     }
     return 1;
 }
@@ -757,7 +762,9 @@ SSL *ossl_ssl_connection_new_int(SSL_CTX
 
     s->num_tickets = ctx->num_tickets;
     s->pha_enabled = ctx->pha_enabled;
-
+#ifndef OPENSSL_NO_NTLS
+    s->enable_ntls = ctx->enable_ntls;
+#endif
     /* Shallow copy of the ciphersuites stack */
     s->tls13_ciphersuites = sk_SSL_CIPHER_dup(ctx->tls13_ciphersuites);
     if (s->tls13_ciphersuites == NULL)
@@ -924,6 +931,16 @@ SSL *ossl_ssl_connection_new_int(SSL_CTX
     SSL_free(ssl);
     return NULL;
 }
+#ifndef OPENSSL_NO_NTLS
+int SSL_is_ntls(const SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return 0;
+
+    return SSL_CONNECTION_IS_NTLS(sc) ? 1 : 0;
+}
+#endif
 
 SSL *ossl_ssl_connection_new(SSL_CTX *ctx)
 {
@@ -1616,6 +1633,14 @@ BIO *SSL_get_wbio(const SSL *s)
     return sc->wbio;
 }
 
+BIO *BABASSL_get0_wbio(const SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL_ONLY(s);
+    if (sc == NULL)
+        return NULL;
+    return sc->wbio;
+}
+
 int SSL_get_fd(const SSL *s)
 {
     return SSL_get_rfd(s);
@@ -3895,6 +3920,12 @@ SSL_CTX *SSL_CTX_new_ex(OSSL_LIB_CTX *li
             goto err;
     }
 
+#ifndef OPENSSL_NO_NTLS
+    ret->enable_ntls = 0;
+#endif
+#ifndef OPENSSL_NO_SM2
+    ret->enable_sm_tls13_strict = 0;
+#endif
     ret->method = meth;
     ret->min_proto_version = 0;
     ret->max_proto_version = 0;
@@ -4314,6 +4345,17 @@ void SSL_CTX_set_cert_cb(SSL_CTX *c, int
     ssl_cert_set_cert_cb(c->cert, cb, arg);
 }
 
+SSL_cert_cb_fn BABASSL_CTX_get_cert_cb(SSL_CTX *c)
+{
+    return ssl_cert_get_cert_cb(c->cert);
+}
+
+void *BABASSL_CTX_get_cert_cb_arg(SSL_CTX *c)
+{
+    return ssl_cert_get_cert_cb_arg(c->cert);
+}
+
+
 void SSL_set_cert_cb(SSL *s, int (*cb) (SSL *ssl, void *arg), void *arg)
 {
     SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
@@ -4324,6 +4366,26 @@ void SSL_set_cert_cb(SSL *s, int (*cb) (
     ssl_cert_set_cert_cb(sc->cert, cb, arg);
 }
 
+SSL_cert_cb_fn BABASSL_get_cert_cb(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+
+    if (sc == NULL)
+        return NULL;
+
+    return ssl_cert_get_cert_cb(sc->cert);
+}
+
+void *BABASSL_get_cert_cb_arg(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return NULL;
+
+    return ssl_cert_get_cert_cb_arg(sc->cert);
+}
+
+
 void ssl_set_masks(SSL_CONNECTION *s)
 {
     CERT *c = s->cert;
@@ -4331,6 +4393,10 @@ void ssl_set_masks(SSL_CONNECTION *s)
     int rsa_enc, rsa_sign, dh_tmp, dsa_sign;
     unsigned long mask_k, mask_a;
     int have_ecc_cert, ecdsa_ok;
+#ifndef OPENSSL_NO_NTLS
+    int sm2_enc, sm2_sign;
+    int ntls_rsa_enc, ntls_rsa_sign;
+#endif
 
     if (c == NULL)
         return;
@@ -4343,6 +4409,12 @@ void ssl_set_masks(SSL_CONNECTION *s)
     rsa_sign = pvalid[SSL_PKEY_RSA] & CERT_PKEY_VALID;
     dsa_sign = pvalid[SSL_PKEY_DSA_SIGN] & CERT_PKEY_VALID;
     have_ecc_cert = pvalid[SSL_PKEY_ECC] & CERT_PKEY_VALID;
+#ifndef OPENSSL_NO_NTLS
+    sm2_sign = pvalid[SSL_PKEY_SM2_SIGN] & CERT_PKEY_VALID;
+    sm2_enc = pvalid[SSL_PKEY_SM2_ENC] & CERT_PKEY_VALID;
+    ntls_rsa_sign = pvalid[SSL_PKEY_RSA_SIGN] & CERT_PKEY_VALID;
+    ntls_rsa_enc = pvalid[SSL_PKEY_RSA_ENC] & CERT_PKEY_VALID;
+#endif
     mask_k = 0;
     mask_a = 0;
 
@@ -4429,7 +4501,23 @@ void ssl_set_masks(SSL_CONNECTION *s)
             && TLS1_get_version(&s->ssl) == TLS1_2_VERSION)
             mask_a |= SSL_aECDSA;
 
+#ifndef OPENSSL_NO_NTLS
+    if (sm2_sign)
+        mask_a |= SSL_aSM2;
+
+    if (sm2_enc)
+        mask_k |= SSL_kSM2 | SSL_kSM2DHE;
+
+    if (ntls_rsa_sign)
+        mask_a |= SSL_aRSA;
+
+    if (ntls_rsa_enc)
+        mask_k |= SSL_kRSA;
+#endif
+
+#ifndef OPENSSL_NO_EC
     mask_k |= SSL_kECDHE;
+#endif
 
 #ifndef OPENSSL_NO_PSK
     mask_k |= SSL_kPSK;
@@ -4630,6 +4718,10 @@ int ossl_ssl_get_error(const SSL *s, int
 #endif
     {
         if (SSL_want_read(s)) {
+#ifndef OPENSSL_NO_NTLS
+            if (sc->enable_ntls == 1 && SSL_IS_FIRST_HANDSHAKE(sc))
+                return SSL_ERROR_WANT_READ;
+#endif
             bio = SSL_get_rbio(s);
             if (BIO_should_read(bio))
                 return SSL_ERROR_WANT_READ;
@@ -4833,6 +4925,11 @@ const char *ssl_protocol_to_string(int v
     case DTLS1_2_VERSION:
         return "DTLSv1.2";
 
+#ifndef OPENSSL_NO_NTLS
+    case NTLS1_1_VERSION:
+        return "NTLSv1.1";
+#endif
+
     default:
         return "unknown";
     }
@@ -5288,6 +5385,25 @@ SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_C
     return ssl->ctx;
 }
 
+SSL_CTX *BABASSL_set_SESSION_CTX(SSL *ssl, SSL_CTX *ctx)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(ssl);
+
+    if (sc == NULL)
+        return NULL;
+
+    if (sc->session_ctx == ctx)
+        return sc->session_ctx;
+    if (ctx == NULL)
+        ctx = sc->session_ctx;
+
+    SSL_CTX_up_ref(ctx);
+    SSL_CTX_free(sc->session_ctx);     /* decrement reference count */
+    sc->session_ctx = ctx;
+
+    return sc->session_ctx;
+}
+
 int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)
 {
     return X509_STORE_set_default_paths_ex(ctx->cert_store, ctx->libctx,
@@ -6633,6 +6749,55 @@ int SSL_client_hello_get_extension_order
     return 1;
 }
 
+int BABASSL_client_hello_get1_extensions(SSL *s, int **out, size_t *outlen)
+{
+    int *exts, i = 0;
+    size_t num = 0;
+
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return 0;
+
+    PACKET extensions = sc->clienthello->extensions;
+
+    while (PACKET_remaining(&extensions) > 0) {
+        unsigned int type;
+        PACKET extension;
+
+        if (!PACKET_get_net_2(&extensions, &type) ||
+            !PACKET_get_length_prefixed_2(&extensions, &extension)) {
+            return 0;
+        }
+
+        num++;
+    }
+
+    exts = OPENSSL_malloc(sizeof(*exts) * num);
+    if (exts == NULL)
+        return 0;
+
+    extensions = sc->clienthello->extensions;
+
+    while (PACKET_remaining(&extensions) > 0) {
+        unsigned int type;
+        PACKET extension;
+
+        if (!PACKET_get_net_2(&extensions, &type) ||
+            !PACKET_get_length_prefixed_2(&extensions, &extension)) {
+            goto err;
+        }
+
+        exts[i++] = type;
+    }
+
+    *out = exts;
+    *outlen = num;
+    return 1;
+ err:
+    OPENSSL_free(exts);
+    return 0;
+}
+
 int SSL_client_hello_get0_ext(SSL *s, unsigned int type, const unsigned char **out,
                        size_t *outlen)
 {
@@ -7179,6 +7344,64 @@ void SSL_set_allow_early_data_cb(SSL *s,
     sc->allow_early_data_cb_data = arg;
 }
 
+#ifndef OPENSSL_NO_NTLS
+void SSL_CTX_enable_ntls(SSL_CTX *ctx)
+{
+    ctx->enable_ntls = 1;
+}
+
+void SSL_CTX_disable_ntls(SSL_CTX *ctx)
+{
+    ctx->enable_ntls = 0;
+}
+
+void SSL_enable_ntls(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return;
+
+    sc->enable_ntls = 1;
+}
+
+void SSL_disable_ntls(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return;
+
+    sc->enable_ntls = 0;
+}
+#endif
+
+#ifndef OPENSSL_NO_SM2
+void SSL_CTX_enable_sm_tls13_strict(SSL_CTX *ctx)
+{
+    ctx->enable_sm_tls13_strict = 1;
+}
+
+void SSL_CTX_disable_sm_tls13_strict(SSL_CTX *ctx)
+{
+    ctx->enable_sm_tls13_strict = 0;
+}
+
+void SSL_enable_sm_tls13_strict(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return;
+    sc->enable_sm_tls13_strict = 1;
+}
+
+void SSL_disable_sm_tls13_strict(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return;
+    sc->enable_sm_tls13_strict = 0;
+}
+#endif
+
 const EVP_CIPHER *ssl_evp_cipher_fetch(OSSL_LIB_CTX *libctx,
                                        int nid,
                                        const char *properties)
@@ -7822,3 +8045,160 @@ int SSL_CTX_get0_server_cert_type(const
     *len = ctx->server_cert_type_len;
     return 1;
 }
+
+int BABASSL_SESSION_get_ref(SSL_SESSION *sess)
+{
+    if(sess != NULL)
+        return (int)(sess->references.val);
+    else
+        return 0;
+}
+
+/*
+ * For a cipher return the index corresponding to the certificate type
+ */
+static int ssl_cipher_get_cert_index(const SSL_CIPHER *c)
+{
+    uint32_t alg_a;
+
+    alg_a = c->algorithm_auth;
+
+    if (alg_a & SSL_aECDSA)
+        return SSL_PKEY_ECC;
+    else if (alg_a & SSL_aRSA)
+        return SSL_PKEY_RSA;
+    else if (alg_a & SSL_aSM2)
+        return SSL_PKEY_SM2;
+
+    return -1;
+}
+
+X509 *BABASSL_get_use_certificate(const SSL *s)
+{
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL_ONLY(s);
+    if (sc == NULL)
+        return NULL;
+
+    CERT *c = sc->cert;
+    int idx;
+
+    if (sc->s3.tmp.new_cipher == NULL)
+        return NULL;
+
+#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
+    /*
+     * Broken protocol test: return last used certificate: which may mismatch
+     * the one expected.
+     */
+    if (c->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL)
+        return c->key ? c->key->x509 : NULL;
+#endif
+
+    if (SSL_CONNECTION_IS_TLS13(sc))
+        return SSL_get_certificate(s);
+
+    idx = ssl_cipher_get_cert_index(sc->s3.tmp.new_cipher);
+    /* This may or may not be an error. */
+    if (idx < 0)
+        return NULL;
+
+    return c->pkeys[idx].x509;
+}
+
+#ifndef OPENSSL_NO_NTLS
+X509 *BABASSL_get_sign_certificate_ntls(const SSL *s)
+{
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL_ONLY(s);
+
+    if (sc != NULL && sc->s3.tmp.sign_cert != NULL)
+        return sc->s3.tmp.sign_cert->x509;
+
+    return NULL;
+}
+
+X509 *BABASSL_get_enc_certificate_ntls(const SSL *s)
+{
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL_ONLY(s);
+
+    if (sc != NULL && sc->s3.tmp.enc_cert != NULL)
+        return sc->s3.tmp.enc_cert->x509;
+
+    return NULL;
+}
+#endif
+
+/*
+ *  BABASSL_get0_alpn_proposed gets the proposed ALPN protocol (if any) from
+ *  |ssl|. On return it sets |*data| to point to |*len| bytes of protocol name
+ *  (not including the leading length-prefix byte). If the server didn't
+ *  respond with a negotiated protocol then |*len| will be zero.
+ */
+void BABASSL_get0_alpn_proposed(const SSL *ssl, const unsigned char **data,
+                                unsigned *len)
+{
+    if (ssl == NULL || data == NULL || len == NULL)
+        return;
+
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL_ONLY(ssl);
+    if (sc == NULL)
+        return;
+
+    *data = sc->s3.alpn_proposed;
+
+    if (*data == NULL)
+        *len = 0;
+    else
+        *len = sc->s3.alpn_proposed_len;
+}
+
+/* TODO: condition opt */
+int BABASSL_get_master_key(SSL *s, unsigned char **master_key,
+                           int *master_key_len)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return 0;
+
+    if (sc == NULL || sc->session == NULL || sc->statem.in_handshake == 1)
+        return 0;
+
+
+
+    if (master_key != NULL)
+        *master_key = sc->session->master_key;
+
+    if (master_key_len != NULL)
+        *master_key_len = sc->session->master_key_length;
+
+    return 1;
+}
+
+void BABASSL_CTX_certs_clear(SSL_CTX *ctx)
+{
+    ssl_cert_clear_certs(ctx->cert);
+}
+
+int BABASSL_check_tlsext_status(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+    if (sc == NULL)
+        return 0;
+
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(sc);
+    if (sc->ext.status_type != -1 && sctx && sctx->ext.status_cb)
+        return 1;
+    else
+        return 0;
+}
+
+void BABASSL_debug(SSL *s, unsigned char *str, int len)
+{
+    int i;
+    if (!str)
+        return;
+
+    for(i = 0; i < len; i++)
+        printf("%02x", str[i]);
+    printf("\n");
+    printf("%d\n", len);
+}
Index: b/ssl/ssl_local.h
===================================================================
--- a/ssl/ssl_local.h
+++ b/ssl/ssl_local.h
@@ -97,6 +97,9 @@
 /* GOST KDF key exchange, draft-smyshlyaev-tls12-gost-suites */
 # define SSL_kGOST18             0x00000200U
 
+# define SSL_kSM2                0x00000400U
+# define SSL_kSM2DHE             0x00000800U
+
 /* all PSK */
 
 # define SSL_PSK     (SSL_kPSK | SSL_kRSAPSK | SSL_kECDHEPSK | SSL_kDHEPSK)
@@ -123,9 +126,11 @@
 # define SSL_aGOST12             0x00000080U
 /* Any appropriate signature auth (for TLS 1.3 ciphersuites) */
 # define SSL_aANY                0x00000000U
+/* SM2 auth */
+# define SSL_aSM2                0x00000100U
 /* All bits requiring a certificate */
 #define SSL_aCERT \
-    (SSL_aRSA | SSL_aDSS | SSL_aECDSA | SSL_aGOST01 | SSL_aGOST12)
+    (SSL_aRSA | SSL_aDSS | SSL_aECDSA | SSL_aGOST01 | SSL_aGOST12 | SSL_aSM2)
 
 /* Bits for algorithm_enc (symmetric encryption) */
 # define SSL_DES                 0x00000001U
@@ -153,6 +158,9 @@
 # define SSL_MAGMA               0x00400000U
 # define SSL_KUZNYECHIK          0x00800000U
 
+# define SSL_SM4CCM              0x01000000U
+# define SSL_SM4GCM              0x02000000U
+# define SSL_SM4                 0x04000000U
 # define SSL_AESGCM              (SSL_AES128GCM | SSL_AES256GCM)
 # define SSL_AESCCM              (SSL_AES128CCM | SSL_AES256CCM | SSL_AES128CCM8 | SSL_AES256CCM8)
 # define SSL_AES                 (SSL_AES128|SSL_AES256|SSL_AESGCM|SSL_AESCCM)
@@ -179,6 +187,7 @@
 # define SSL_GOST12_512          0x00000200U
 # define SSL_MAGMAOMAC           0x00000400U
 # define SSL_KUZNYECHIKOMAC      0x00000800U
+# define SSL_SM3                 0x00001000U
 
 /*
  * When adding new digest in the ssl_ciph.c and increment SSL_MD_NUM_IDX make
@@ -199,7 +208,8 @@
 # define SSL_MD_SHA512_IDX 11
 # define SSL_MD_MAGMAOMAC_IDX 12
 # define SSL_MD_KUZNYECHIKOMAC_IDX 13
-# define SSL_MAX_DIGEST 14
+# define SSL_MD_SM3_IDX 14
+# define SSL_MAX_DIGEST 15
 
 #define SSL_MD_NUM_IDX  SSL_MAX_DIGEST
 
@@ -214,6 +224,7 @@
 # define SSL_HANDSHAKE_MAC_GOST12_256 SSL_MD_GOST12_256_IDX
 # define SSL_HANDSHAKE_MAC_GOST12_512 SSL_MD_GOST12_512_IDX
 # define SSL_HANDSHAKE_MAC_DEFAULT  SSL_HANDSHAKE_MAC_MD5_SHA1
+# define SSL_HANDSHAKE_MAC_SM3 SSL_MD_SM3_IDX
 
 /* Bits 8-15 bits are PRF */
 # define TLS1_PRF_DGST_SHIFT 8
@@ -224,6 +235,7 @@
 # define TLS1_PRF_GOST12_256 (SSL_MD_GOST12_256_IDX << TLS1_PRF_DGST_SHIFT)
 # define TLS1_PRF_GOST12_512 (SSL_MD_GOST12_512_IDX << TLS1_PRF_DGST_SHIFT)
 # define TLS1_PRF            (SSL_MD_MD5_SHA1_IDX << TLS1_PRF_DGST_SHIFT)
+# define TLS1_PRF_SM3 (SSL_MD_SM3_IDX << TLS1_PRF_DGST_SHIFT)
 
 /*
  * Stream MAC for GOST ciphersuites from cryptopro draft (currently this also
@@ -254,6 +266,9 @@
 /* Flag used on OpenSSL ciphersuite ids to indicate they are for SSLv3+ */
 # define SSL3_CK_CIPHERSUITE_FLAG                0x03000000
 
+# ifndef OPENSSL_NO_NTLS
+#  define SSL_CONNECTION_IS_NTLS(s) (s->version == NTLS_VERSION)
+# endif
 /* Check if an SSL structure is using DTLS */
 # define SSL_CONNECTION_IS_DTLS(s) \
     (SSL_CONNECTION_GET_SSL(s)->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS)
@@ -335,7 +350,16 @@
 # define SSL_PKEY_GOST12_512     6
 # define SSL_PKEY_ED25519        7
 # define SSL_PKEY_ED448          8
-# define SSL_PKEY_NUM            9
+# define SSL_PKEY_SM2            9
+# ifndef OPENSSL_NO_NTLS
+#  define SSL_PKEY_SM2_SIGN      10
+#  define SSL_PKEY_SM2_ENC       11
+#  define SSL_PKEY_RSA_SIGN      12
+#  define SSL_PKEY_RSA_ENC       13
+#  define SSL_PKEY_NUM           14
+# else
+#  define SSL_PKEY_NUM           10
+# endif
 
 # define SSL_ENC_DES_IDX         0
 # define SSL_ENC_3DES_IDX        1
@@ -361,7 +385,14 @@
 # define SSL_ENC_ARIA256GCM_IDX  21
 # define SSL_ENC_MAGMA_IDX       22
 # define SSL_ENC_KUZNYECHIK_IDX  23
-# define SSL_ENC_NUM_IDX         24
+# define SSL_ENC_SM4_GCM_IDX     24
+# define SSL_ENC_SM4_CCM_IDX     25
+# ifndef OPENSSL_NO_SM4
+#  define SSL_ENC_SM4_IDX        26
+#  define SSL_ENC_NUM_IDX        27
+# else
+#  define SSL_ENC_NUM_IDX        26
+# endif
 
 /*-
  * SSL_kRSA <- RSA_ENC
@@ -1179,6 +1210,18 @@ struct ssl_ctx_st {
     uint32_t disabled_mac_mask;
     uint32_t disabled_mkey_mask;
     uint32_t disabled_auth_mask;
+#ifndef OPENSSL_NO_NTLS
+    /* Tag of NTLS */
+    int enable_ntls;
+#endif
+#ifndef OPENSSL_NO_SM2
+    /*
+     * tag of determining whether we should strict follow RFC 8998,
+     * when this tag set to 1, we will reject "TLS_SM4_GCM_SM3" and "TLS_SM4_CCM_SM3"
+     * without sm2 cert at server. This tag set to 0 default
+     */
+    int enable_sm_tls13_strict;
+#endif
 
 #ifndef OPENSSL_NO_COMP_ALG
     /* certificate compression preferences */
@@ -1355,6 +1398,11 @@ struct ssl_connection_st {
             const struct sigalg_lookup_st *sigalg;
             /* Pointer to certificate we use */
             CERT_PKEY *cert;
+
+# ifndef OPENSSL_NO_NTLS
+            CERT_PKEY *sign_cert;
+            CERT_PKEY *enc_cert;
+# endif
             /*
              * signature algorithms peer reports: e.g. supported signature
              * algorithms extension for server or as part of a certificate
@@ -1802,6 +1850,18 @@ struct ssl_connection_st {
     const struct sigalg_lookup_st **shared_sigalgs;
     size_t shared_sigalgslen;
 
+# ifndef OPENSSL_NO_NTLS
+    int enable_ntls;
+# endif
+# ifndef OPENSSL_NO_SM2
+    /*
+     * tag of determining whether we should strict follow RFC 8998,
+     * when this tag set to 1, we will reject "TLS_SM4_GCM_SM3" and "TLS_SM4_CCM_SM3"
+     * without sm2 cert at server. This tag set to 0 default
+     */
+    int enable_sm_tls13_strict;
+# endif
+
 #ifndef OPENSSL_NO_COMP_ALG
     /* certificate compression preferences */
     int cert_comp_prefs[TLSEXT_comp_cert_limit];
@@ -2193,6 +2253,7 @@ typedef enum downgrade_en {
 #define TLSEXT_SIGALG_ecdsa_secp521r1_sha512                    0x0603
 #define TLSEXT_SIGALG_ecdsa_sha224                              0x0303
 #define TLSEXT_SIGALG_ecdsa_sha1                                0x0203
+#define TLSEXT_SIGALG_sm2sig_sm3                                0x0708
 #define TLSEXT_SIGALG_rsa_pss_rsae_sha256                       0x0804
 #define TLSEXT_SIGALG_rsa_pss_rsae_sha384                       0x0805
 #define TLSEXT_SIGALG_rsa_pss_rsae_sha512                       0x0806
@@ -2267,6 +2328,11 @@ __owur const SSL_METHOD *dtls_bad_ver_cl
 __owur const SSL_METHOD *dtlsv1_2_method(void);
 __owur const SSL_METHOD *dtlsv1_2_server_method(void);
 __owur const SSL_METHOD *dtlsv1_2_client_method(void);
+# ifndef OPENSSL_NO_NTLS
+__owur const SSL_METHOD *ntls_method(void);
+__owur const SSL_METHOD *ntls_server_method(void);
+__owur const SSL_METHOD *ntls_client_method(void);
+# endif
 
 extern const SSL3_ENC_METHOD TLSv1_enc_data;
 extern const SSL3_ENC_METHOD TLSv1_1_enc_data;
@@ -2275,6 +2341,9 @@ extern const SSL3_ENC_METHOD TLSv1_3_enc
 extern const SSL3_ENC_METHOD SSLv3_enc_data;
 extern const SSL3_ENC_METHOD DTLSv1_enc_data;
 extern const SSL3_ENC_METHOD DTLSv1_2_enc_data;
+# ifndef OPENSSL_NO_NTLS
+extern const SSL3_ENC_METHOD NTLS_enc_data;
+# endif
 
 /*
  * Flags for SSL methods
@@ -2526,6 +2595,8 @@ __owur int ssl_cert_add1_chain_cert(SSL_
 __owur int ssl_cert_select_current(CERT *c, X509 *x);
 __owur int ssl_cert_set_current(CERT *c, long arg);
 void ssl_cert_set_cert_cb(CERT *c, int (*cb) (SSL *ssl, void *arg), void *arg);
+SSL_cert_cb_fn ssl_cert_get_cert_cb(CERT *c);
+void *ssl_cert_get_cert_cb_arg(CERT *c);
 
 __owur int ssl_verify_cert_chain(SSL_CONNECTION *s, STACK_OF(X509) *sk);
 __owur int ssl_verify_rpk(SSL_CONNECTION *s, EVP_PKEY *rpk);
@@ -2763,6 +2834,10 @@ __owur int tls13_export_keying_material_
 __owur int tls1_alert_code(int code);
 __owur int tls13_alert_code(int code);
 __owur int ssl3_alert_code(int code);
+#ifndef OPENSSL_NO_NTLS
+__owur int ntls_alert_code(int code);
+int tls_choose_sigalg_ntls(SSL_CONNECTION *s, int fatalerrs);
+#endif
 
 __owur int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL_CONNECTION *s);
 
Index: b/ssl/ssl_rsa.c
===================================================================
--- a/ssl/ssl_rsa.c
+++ b/ssl/ssl_rsa.c
@@ -17,6 +17,16 @@
 #include <openssl/x509v3.h>
 #include <openssl/pem.h>
 
+#ifndef OPENSSL_NO_NTLS
+static int ssl_set_cert_idx(CERT *c, X509 *x, int i);
+static int ssl_set_pkey_idx(CERT *c, EVP_PKEY *pkey, int i);
+static int ssl_use_certificate_idx(SSL *ssl, X509 *x, int i);
+static int ssl_use_certificate_file_ntls(SSL *ssl, const char *file,
+                                         int type, int tag);
+static int ssl_use_PrivateKey_idx(SSL *ssl, EVP_PKEY *pkey, int i);
+static int ssl_use_PrivateKey_file_ntls(SSL *ssl, const char *file,
+                                        int type, int tag);
+#endif
 static int ssl_set_cert(CERT *c, X509 *x509, SSL_CTX *ctx);
 static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey, SSL_CTX *ctx);
 
@@ -124,6 +134,272 @@ int SSL_use_certificate_ASN1(SSL *ssl, c
     return ret;
 }
 
+
+#ifndef OPENSSL_NO_NTLS
+static int ssl_use_certificate_idx(SSL *ssl, X509 *x, int i)
+{
+    int rv;
+    if (x == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(ssl);
+
+    if (sc == NULL)
+        return 0;
+
+    rv = ssl_security_cert(sc, NULL, x, 0, 1);
+    if (rv != 1) {
+        ERR_raise(ERR_LIB_SSL, rv);
+        return 0;
+    }
+
+    return ssl_set_cert_idx(sc->cert, x, i);
+}
+
+static int ssl_use_certificate_file_ntls(SSL *ssl, const char *file,
+                                         int type, int tag)
+{
+    int i, j;
+    BIO *in;
+    int ret = 0;
+    X509 *x = NULL;
+    EVP_PKEY *pkey;
+
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(ssl);
+
+    if (sc == NULL)
+        return 0;
+
+    in = BIO_new(BIO_s_file());
+    if (in == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SYS_LIB);
+        goto end;
+    }
+    if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        x = d2i_X509_bio(in, NULL);
+    } else if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        x = PEM_read_bio_X509(in, NULL, sc->default_passwd_callback,
+                              sc->default_passwd_callback_userdata);
+    } else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+
+    if (x == NULL) {
+        ERR_raise(ERR_LIB_SSL, j);
+        goto end;
+    }
+
+    pkey = X509_get0_pubkey(x);
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, SSL_R_X509_LIB);
+        goto end;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = (tag == SSL_SIGN_CERT) ? SSL_PKEY_SM2_SIGN : SSL_PKEY_SM2_ENC;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = (tag == SSL_SIGN_CERT) ? SSL_PKEY_RSA_SIGN : SSL_PKEY_RSA_ENC;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        goto end;
+    }
+
+    ret = ssl_use_certificate_idx(ssl, x, i);
+ end:
+    X509_free(x);
+    BIO_free(in);
+    return ret;
+}
+
+static int ssl_use_PrivateKey_idx(SSL *ssl, EVP_PKEY *pkey, int i)
+{
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(ssl);
+
+    if (sc == NULL)
+        return 0;
+
+    return ssl_set_pkey_idx(sc->cert, pkey, i);
+}
+
+static int ssl_use_PrivateKey_file_ntls(SSL *ssl, const char *file,
+                                        int type, int tag)
+{
+    int i, j, ret = 0;
+    BIO *in;
+    EVP_PKEY *pkey = NULL;
+
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(ssl);
+
+    if (sc == NULL)
+        return 0;
+
+    in = BIO_new(BIO_s_file());
+    if (in == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SYS_LIB);
+        goto end;
+    }
+    if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        pkey = PEM_read_bio_PrivateKey(in, NULL,
+                                       sc->default_passwd_callback,
+                                       sc->default_passwd_callback_userdata);
+    } else if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        pkey = d2i_PrivateKey_bio(in, NULL);
+    } else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, j);
+        goto end;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = (tag == SSL_SIGN_CERT) ? SSL_PKEY_SM2_SIGN : SSL_PKEY_SM2_ENC;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = (tag == SSL_SIGN_CERT) ? SSL_PKEY_RSA_SIGN : SSL_PKEY_RSA_ENC;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        goto end;
+    }
+
+    ret = ssl_use_PrivateKey_idx(ssl, pkey, i);
+ end:
+    EVP_PKEY_free(pkey);
+    BIO_free(in);
+    return ret;
+}
+
+int SSL_use_sign_certificate(SSL *ssl, X509 *x)
+{
+    EVP_PKEY *pkey;
+    int i;
+
+    pkey = X509_get0_pubkey(x);
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, SSL_R_X509_LIB);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_SIGN;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_SIGN;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_use_certificate_idx(ssl, x, i);
+}
+
+int SSL_use_sign_certificate_file(SSL *ssl, const char *file, int type)
+{
+    return ssl_use_certificate_file_ntls(ssl, file, type, SSL_SIGN_CERT);
+}
+
+int SSL_use_enc_certificate(SSL *ssl, X509 *x)
+{
+    EVP_PKEY *pkey;
+    int i;
+
+    pkey = X509_get0_pubkey(x);
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, SSL_R_X509_LIB);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_ENC;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_ENC;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_use_certificate_idx(ssl, x, i);
+}
+
+int SSL_use_enc_certificate_file(SSL *ssl, const char *file, int type)
+{
+    return ssl_use_certificate_file_ntls(ssl, file, type, SSL_ENC_CERT);
+}
+
+int SSL_use_enc_PrivateKey(SSL *ssl, EVP_PKEY *pkey)
+{
+    int i;
+
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_ENC;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_ENC;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_use_PrivateKey_idx(ssl, pkey, i);
+}
+
+int SSL_use_enc_PrivateKey_file(SSL *ssl, const char *file, int type)
+{
+    return ssl_use_PrivateKey_file_ntls(ssl, file, type, SSL_ENC_CERT);
+}
+
+int SSL_use_sign_PrivateKey(SSL *ssl, EVP_PKEY *pkey)
+{
+    int i;
+
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_SIGN;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_SIGN;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_use_PrivateKey_idx(ssl, pkey, i);
+}
+
+int SSL_use_sign_PrivateKey_file(SSL *ssl, const char *file, int type)
+{
+    return ssl_use_PrivateKey_file_ntls(ssl, file, type, SSL_SIGN_CERT);
+}
+#endif
+
 static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey, SSL_CTX *ctx)
 {
     size_t i;
@@ -1057,3 +1333,362 @@ int SSL_CTX_use_cert_and_key(SSL_CTX *ct
 {
     return ssl_set_cert_and_key(NULL, ctx, x509, privatekey, chain, override);
 }
+
+#ifndef OPENSSL_NO_NTLS
+/* this is the explicitly cert setting version of ssl_set_cert */
+static int ssl_set_cert_idx(CERT *c, X509 *x, int i)
+{
+    EVP_PKEY *pkey;
+
+    pkey = X509_get0_pubkey(x);
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, SSL_R_X509_LIB);
+        return 0;
+    }
+
+    if (c->pkeys[i].privatekey != NULL) {
+        /*
+         * The return code from EVP_PKEY_copy_parameters is deliberately
+         * ignored. Some EVP_PKEY types cannot do this.
+         */
+        EVP_PKEY_copy_parameters(pkey, c->pkeys[i].privatekey);
+        ERR_clear_error();
+
+        if (!X509_check_private_key(x, c->pkeys[i].privatekey)) {
+            /*
+             * don't fail for a cert/key mismatch, just free current private
+             * key (when switching to a different cert & key, first this
+             * function should be used, then ssl_set_pkey
+             */
+            EVP_PKEY_free(c->pkeys[i].privatekey);
+            c->pkeys[i].privatekey = NULL;
+            /* clear error queue */
+            ERR_clear_error();
+        }
+    }
+
+    X509_free(c->pkeys[i].x509);
+    X509_up_ref(x);
+    c->pkeys[i].x509 = x;
+    c->key = &(c->pkeys[i]);
+
+    return 1;
+}
+
+static int ssl_set_pkey_idx(CERT *c, EVP_PKEY *pkey, int i)
+{
+    if (c->pkeys[i].x509 != NULL) {
+        EVP_PKEY *pktmp;
+        pktmp = X509_get0_pubkey(c->pkeys[i].x509);
+        if (pktmp == NULL) {
+            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+        /*
+         * The return code from EVP_PKEY_copy_parameters is deliberately
+         * ignored. Some EVP_PKEY types cannot do this.
+         */
+        EVP_PKEY_copy_parameters(pktmp, pkey);
+        ERR_clear_error();
+
+        if (!X509_check_private_key(c->pkeys[i].x509, pkey)) {
+            X509_free(c->pkeys[i].x509);
+            c->pkeys[i].x509 = NULL;
+            return 0;
+        }
+    }
+
+    EVP_PKEY_free(c->pkeys[i].privatekey);
+    EVP_PKEY_up_ref(pkey);
+    c->pkeys[i].privatekey = pkey;
+    c->key = &c->pkeys[i];
+
+    return 1;
+}
+
+int SSL_CTX_use_enc_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
+{
+    int i;
+
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_ENC;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_ENC;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_set_pkey_idx(ctx->cert, pkey, i);
+}
+
+int SSL_CTX_use_enc_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
+{
+    int j, ret = 0;
+    BIO *in;
+    EVP_PKEY *pkey = NULL;
+
+    in = BIO_new(BIO_s_file());
+    if (in == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SYS_LIB);
+        goto end;
+    }
+    if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        pkey = PEM_read_bio_PrivateKey(in, NULL,
+                                       ctx->default_passwd_callback,
+                                       ctx->default_passwd_callback_userdata);
+    } else if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        pkey = d2i_PrivateKey_bio(in, NULL);
+    } else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, j);
+        goto end;
+    }
+    ret = SSL_CTX_use_enc_PrivateKey(ctx, pkey);
+    EVP_PKEY_free(pkey);
+ end:
+    BIO_free(in);
+    return ret;
+}
+
+int SSL_CTX_use_sign_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
+{
+    int i;
+
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_SIGN;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_SIGN;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_set_pkey_idx(ctx->cert, pkey, i);
+}
+
+int SSL_CTX_use_sign_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
+{
+    int j, ret = 0;
+    BIO *in;
+    EVP_PKEY *pkey = NULL;
+
+    in = BIO_new(BIO_s_file());
+    if (in == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SYS_LIB);
+        goto end;
+    }
+    if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        pkey = PEM_read_bio_PrivateKey(in, NULL,
+                                       ctx->default_passwd_callback,
+                                       ctx->default_passwd_callback_userdata);
+    } else if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        pkey = d2i_PrivateKey_bio(in, NULL);
+    } else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, j);
+        goto end;
+    }
+    ret = SSL_CTX_use_sign_PrivateKey(ctx, pkey);
+    EVP_PKEY_free(pkey);
+ end:
+    BIO_free(in);
+    return ret;
+}
+
+/* This function is used to set SM2 enc function only */
+int SSL_CTX_use_enc_certificate(SSL_CTX *ctx, X509 *x)
+{
+    EVP_PKEY *pkey = NULL;
+    int i, rv;
+
+    if (x == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (!(X509_get_key_usage(x) & X509v3_KU_KEY_ENCIPHERMENT)
+        && !(X509_get_key_usage(x) & X509v3_KU_DATA_ENCIPHERMENT)) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        return 0;
+    }
+
+    rv = ssl_security_cert(NULL, ctx, x, 0, 1);
+    if (rv != 1) {
+        ERR_raise(ERR_LIB_SSL, rv);
+        return 0;
+    }
+
+    pkey = X509_get0_pubkey(x);
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, SSL_R_X509_LIB);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_ENC;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_ENC;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_set_cert_idx(ctx->cert, x, i);
+}
+
+int SSL_CTX_use_enc_certificate_file(SSL_CTX *ctx, const char *file, int type)
+{
+    int j;
+    BIO *in;
+    int ret = 0;
+    X509 *x = NULL;
+
+    in = BIO_new(BIO_s_file());
+    if (in == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SYS_LIB);
+        goto end;
+    }
+
+    if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        x = d2i_X509_bio(in, NULL);
+    } else if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        x = PEM_read_bio_X509(in, NULL, ctx->default_passwd_callback,
+                              ctx->default_passwd_callback_userdata);
+    } else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+
+    if (x == NULL) {
+        ERR_raise(ERR_LIB_SSL, j);
+        goto end;
+    }
+
+    ret = SSL_CTX_use_enc_certificate(ctx, x);
+ end:
+    X509_free(x);
+    BIO_free(in);
+    return ret;
+}
+
+int SSL_CTX_use_sign_certificate(SSL_CTX *ctx, X509 *x)
+{
+    EVP_PKEY *pkey = NULL;
+    int i, rv;
+
+    if (x == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (!(X509_get_key_usage(x) & X509v3_KU_DIGITAL_SIGNATURE)
+        && !(X509_get_key_usage(x) & X509v3_KU_KEY_CERT_SIGN)
+        && !(X509_get_key_usage(x) & X509v3_KU_CRL_SIGN)) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        return 0;
+    }
+
+    rv = ssl_security_cert(NULL, ctx, x, 0, 1);
+    if (rv != 1) {
+        ERR_raise(ERR_LIB_SSL, rv);
+        return 0;
+    }
+
+    pkey = X509_get0_pubkey(x);
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_SSL, SSL_R_X509_LIB);
+        return 0;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2"))
+        i = SSL_PKEY_SM2_SIGN;
+    else if (EVP_PKEY_is_a(pkey, "RSA"))
+        i = SSL_PKEY_RSA_SIGN;
+    else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_CERTIFICATE_TYPE);
+        return 0;
+    }
+
+    return ssl_set_cert_idx(ctx->cert, x, i);
+}
+
+int SSL_CTX_use_sign_certificate_file(SSL_CTX *ctx, const char *file, int type)
+{
+    int j;
+    BIO *in;
+    int ret = 0;
+    X509 *x = NULL;
+
+    in = BIO_new(BIO_s_file());
+    if (in == NULL) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        ERR_raise(ERR_LIB_SSL, ERR_R_SYS_LIB);
+        goto end;
+    }
+
+    if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        x = d2i_X509_bio(in, NULL);
+    } else if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        x = PEM_read_bio_X509(in, NULL, ctx->default_passwd_callback,
+                              ctx->default_passwd_callback_userdata);
+    } else {
+        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+
+    if (x == NULL) {
+        ERR_raise(ERR_LIB_SSL, j);
+        goto end;
+    }
+
+    ret = SSL_CTX_use_sign_certificate(ctx, x);
+ end:
+    X509_free(x);
+    BIO_free(in);
+    return ret;
+}
+#endif
Index: b/ssl/ssl_sess.c
===================================================================
--- a/ssl/ssl_sess.c
+++ b/ssl/ssl_sess.c
@@ -361,6 +361,9 @@ int ssl_generate_session_id(SSL_CONNECTI
     case DTLS1_BAD_VER:
     case DTLS1_VERSION:
     case DTLS1_2_VERSION:
+#ifndef OPENSSL_NO_NTLS
+    case NTLS1_1_VERSION:
+#endif
         ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
         break;
     default:
Index: b/ssl/ssl_stat.c
===================================================================
--- a/ssl/ssl_stat.c
+++ b/ssl/ssl_stat.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2022 The OpenSSL Project Authors. All Rights Reserved.
  * Copyright 2005 Nokia. All rights reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
@@ -332,6 +332,20 @@ const char *SSL_alert_desc_string(int va
         return "BH";
     case TLS1_AD_UNKNOWN_PSK_IDENTITY:
         return "UP";
+#ifndef OPENSSL_NO_NTLS
+    case NTLS_AD_UNSUPPORTED_SITE2SITE:
+        return "U2";
+    case NTLS_AD_NO_AREA:
+        return "NA";
+    case NTLS_AD_UNSUPPORTED_AREATYPE:
+        return "AT";
+    case NTLS_AD_BAD_IBCPARAM:
+        return "BI";
+    case NTLS_AD_UNSUPPORTED_IBCPARAM:
+        return "UI";
+    case NTLS_AD_IDENTITY_NEED:
+        return "IN";
+#endif
     default:
         return "UK";
     }
@@ -402,6 +416,20 @@ const char *SSL_alert_desc_string_long(i
         return "unknown PSK identity";
     case TLS1_AD_NO_APPLICATION_PROTOCOL:
         return "no application protocol";
+#ifndef OPENSSL_NO_NTLS
+    case NTLS_AD_UNSUPPORTED_SITE2SITE:
+        return "unsupported site2site";
+    case NTLS_AD_NO_AREA:
+        return "no area";
+    case NTLS_AD_UNSUPPORTED_AREATYPE:
+        return "unsupported areatype";
+    case NTLS_AD_BAD_IBCPARAM:
+        return "bad ibc parameters";
+    case NTLS_AD_UNSUPPORTED_IBCPARAM:
+        return "unsupported ibc parameters";
+    case NTLS_AD_IDENTITY_NEED:
+        return "identity need";
+#endif
     default:
         return "unknown";
     }
Index: b/ssl/statem/statem.c
===================================================================
--- a/ssl/statem/statem.c
+++ b/ssl/statem/statem.c
@@ -17,6 +17,9 @@
 #include "../ssl_local.h"
 #include "statem_local.h"
 #include <assert.h>
+#ifndef OPENSSL_NO_NTLS
+# include "../statem_ntls/ntls_statem.h"
+#endif
 
 /*
  * This file implements the SSL/TLS/DTLS state machines.
@@ -293,7 +296,19 @@ int ossl_statem_connect(SSL *s)
 
     if (sc == NULL)
         return -1;
+#ifndef OPENSSL_NO_NTLS
+    int ret;
 
+    if (sc->enable_ntls == 1) {
+        ret = SSL_connection_is_ntls(sc, 0);
+        if (ret == 0)
+            return state_machine(sc, 0);
+        else if (ret == 1)
+            return state_machine_ntls(sc, 0);
+        else
+            return -1;
+    } else
+#endif
     return state_machine(sc, 0);
 }
 
@@ -303,6 +318,19 @@ int ossl_statem_accept(SSL *s)
 
     if (sc == NULL)
         return -1;
+#ifndef OPENSSL_NO_NTLS
+    int ret;
+
+    if (sc->enable_ntls == 1) {
+        ret = SSL_connection_is_ntls(sc, 1);
+        if (ret == 0)
+            return state_machine(sc, 1);
+        else if (ret == 1)
+            return state_machine_ntls(sc, 1);
+        else
+            return ret;
+    } else
+#endif
 
     return state_machine(sc, 1);
 }
Index: b/ssl/statem_ntls/README.md
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/README.md
@@ -0,0 +1,58 @@
+NTLS State Machine Design
+=========================
+
+This file provides some guidance on the thinking behind the design of the
+state machine code to aid future maintenance.
+
+The message flow state machine is divided into a reading sub-state machine and a
+writing sub-state machine. See the source comments in ntls_statem.c for a more
+detailed description of the various states and transitions possible.
+
+Conceptually the state machine component is designed as follows:
+
+                          libssl
+                             |
+    -------------------------|-----ntls_statem.h------------------------------------
+                             |
+                      _______V____________________
+                     |                            |
+                     |    ntls_statem.c           |
+                     |                            |
+                     |    Core state machine code |
+                     |____________________________|
+    ntls_statem_local.h     ^          ^
+                   _________|          |_______
+                  |                            |
+     _____________|____________   _____________|____________
+    |                          | |                          |
+    | ntls_statem_clnt.c       | | ntls_statem_srvr.c       |
+    |                          | |                          |
+    | NTLS client specific     | | NTLS server specific     |
+    | state machine code       | | state machine code       |
+    |__________________________| |__________________________|
+                      |                   |
+                      |                   |
+                      |                   |
+                 _____V___________________V___
+                |                             |
+                | ntls_statem_lib.c           |
+                |                             |
+                | Non core functions common   |
+                | to both servers and clients |
+                |_____________________________|
+Note:
+
+  - Receive a message first and then work out whether that is a valid
+    transition - not the other way around (the other way causes lots of issues
+    where we are expecting one type of message next but actually get something
+    else)
+  - Separate message flow state from handshake state (in order to better
+    understand each)
+    * message flow state = when to flush buffers; handling restarts in the
+      event of NBIO events; handling the common flow of steps for reading a
+      message and the common flow of steps for writing a message etc
+    * handshake state = what handshake message are we working on now
+  - Control complexity: only the state machine can change state: keep all
+    the state changes local to the state machine component
+  - GB/T 38636-2020 TLCP(Transport layer cryptography protocol) and GM/T
+    0024-2014 SSL VPN specification are supported.
Index: b/ssl/statem_ntls/ntls_extensions.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_extensions.c
@@ -0,0 +1,1435 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.apache.org/licenses/LICENSE-2.0
+ */
+
+#include <string.h>
+#include "internal/nelem.h"
+#include "internal/cryptlib.h"
+#include "ntls_ssl_local.h"
+#include "ntls_statem_local.h"
+#include "internal/cryptlib.h"
+
+static int init_server_name(SSL_CONNECTION *s, unsigned int context);
+static int final_server_name(SSL_CONNECTION *s, unsigned int context, int sent);
+static int final_ec_pt_formats(SSL_CONNECTION *s, unsigned int context, int sent);
+static int init_session_ticket(SSL_CONNECTION *s, unsigned int context);
+#ifndef OPENSSL_NO_OCSP
+static int init_status_request(SSL_CONNECTION *s, unsigned int context);
+#endif
+#ifndef OPENSSL_NO_NEXTPROTONEG
+static int init_npn(SSL_CONNECTION *s, unsigned int context);
+#endif
+static int init_alpn(SSL_CONNECTION *s, unsigned int context);
+static int final_alpn(SSL_CONNECTION *s, unsigned int context, int sent);
+static int init_sig_algs_cert(SSL_CONNECTION *s, unsigned int context);
+static int init_sig_algs(SSL_CONNECTION *s, unsigned int context);
+static int init_certificate_authorities(SSL_CONNECTION *s, unsigned int context);
+static EXT_RETURN tls_construct_certificate_authorities(SSL_CONNECTION *s, WPACKET *pkt,
+                                                        unsigned int context,
+                                                        X509 *x,
+                                                        size_t chainidx);
+static int tls_parse_certificate_authorities(SSL_CONNECTION *s, PACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+
+static int init_ec_point_formats(SSL_CONNECTION *s, unsigned int context);
+static int init_etm(SSL_CONNECTION *s, unsigned int context);
+static int init_ems(SSL_CONNECTION *s, unsigned int context);
+static int final_ems(SSL_CONNECTION *s, unsigned int context, int sent);
+static int init_psk_kex_modes(SSL_CONNECTION *s, unsigned int context);
+static int final_key_share(SSL_CONNECTION *s, unsigned int context, int sent);
+#ifndef OPENSSL_NO_SRTP
+static int init_srtp(SSL_CONNECTION *s, unsigned int context);
+#endif
+static int final_sig_algs(SSL_CONNECTION *s, unsigned int context, int sent);
+static int final_early_data(SSL_CONNECTION *s, unsigned int context, int sent);
+static int final_maxfragmentlen(SSL_CONNECTION *s, unsigned int context, int sent);
+static int init_post_handshake_auth(SSL_CONNECTION *s, unsigned int context);
+static int final_psk(SSL_CONNECTION *s, unsigned int context, int sent);
+
+/* Structure to define a built-in extension */
+typedef struct extensions_definition_st {
+    /* The defined type for the extension */
+    unsigned int type;
+    /*
+     * The context that this extension applies to, e.g. what messages and
+     * protocol versions
+     */
+    unsigned int context;
+    /*
+     * Initialise extension before parsing. Always called for relevant contexts
+     * even if extension not present
+     */
+    int (*init)(SSL_CONNECTION *s, unsigned int context);
+    /* Parse extension sent from client to server */
+    int (*parse_ctos)(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                      size_t chainidx);
+    /* Parse extension send from server to client */
+    int (*parse_stoc)(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                      size_t chainidx);
+    /* Construct extension sent from server to client */
+    EXT_RETURN (*construct_stoc)(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx);
+    /* Construct extension sent from client to server */
+    EXT_RETURN (*construct_ctos)(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx);
+    /*
+     * Finalise extension after parsing. Always called where an extensions was
+     * initialised even if the extension was not present. |sent| is set to 1 if
+     * the extension was seen, or 0 otherwise.
+     */
+    int (*final)(SSL_CONNECTION *s, unsigned int context, int sent);
+} EXTENSION_DEFINITION;
+
+/*
+ * Definitions of all built-in extensions. NOTE: Changes in the number or order
+ * of these extensions should be mirrored with equivalent changes to the
+ * indexes ( TLSEXT_IDX_* ) defined in ssl_local.h.
+ * Each extension has an initialiser, a client and
+ * server side parser and a finaliser. The initialiser is called (if the
+ * extension is relevant to the given context) even if we did not see the
+ * extension in the message that we received. The parser functions are only
+ * called if we see the extension in the message. The finalisers are always
+ * called if the initialiser was called.
+ * There are also server and client side constructor functions which are always
+ * called during message construction if the extension is relevant for the
+ * given context.
+ * The initialisation, parsing, finalisation and construction functions are
+ * always called in the order defined in this list. Some extensions may depend
+ * on others having been processed first, so the order of this list is
+ * significant.
+ * The extension context is defined by a series of flags which specify which
+ * messages the extension is relevant to. These flags also specify whether the
+ * extension is relevant to a particular protocol or protocol version.
+ *
+ * TODO(TLS1.3): Make sure we have a test to check the consistency of these
+ *
+ * NOTE: WebSphere Application Server 7+ cannot handle empty extensions at
+ * the end, keep these extensions before signature_algorithm.
+ */
+#define INVALID_EXTENSION { 0x10000, 0, NULL, NULL, NULL, NULL, NULL, NULL }
+static const EXTENSION_DEFINITION ext_defs[] = {
+    INVALID_EXTENSION,  /* TLSEXT_IDX_renegotiate */
+    {
+        TLSEXT_TYPE_server_name,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS,
+        init_server_name,
+        tls_parse_ctos_server_name_ntls, tls_parse_stoc_server_name_ntls,
+        tls_construct_stoc_server_name_ntls, tls_construct_ctos_server_name_ntls,
+        final_server_name
+    },
+    {
+        TLSEXT_TYPE_max_fragment_length,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS,
+        NULL, tls_parse_ctos_maxfragmentlen_ntls, tls_parse_stoc_maxfragmentlen_ntls,
+        tls_construct_stoc_maxfragmentlen_ntls, tls_construct_ctos_maxfragmentlen_ntls,
+        final_maxfragmentlen
+    },
+    INVALID_EXTENSION,  /* TLSEXT_IDX_srp */
+    {
+        TLSEXT_TYPE_ec_point_formats,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_2_AND_BELOW_ONLY,
+        init_ec_point_formats, tls_parse_ctos_ec_pt_formats_ntls, tls_parse_stoc_ec_pt_formats_ntls,
+        tls_construct_stoc_ec_pt_formats_ntls, tls_construct_ctos_ec_pt_formats_ntls,
+        final_ec_pt_formats
+    },
+    {
+        /*
+         * "supported_groups" is spread across several specifications.
+         * It was originally specified as "elliptic_curves" in RFC 4492,
+         * and broadened to include named FFDH groups by RFC 7919.
+         * Both RFCs 4492 and 7919 do not include a provision for the server
+         * to indicate to the client the complete list of groups supported
+         * by the server, with the server instead just indicating the
+         * selected group for this connection in the ServerKeyExchange
+         * message.  TLS 1.3 adds a scheme for the server to indicate
+         * to the client its list of supported groups in the
+         * EncryptedExtensions message, but none of the relevant
+         * specifications permit sending supported_groups in the ServerHello.
+         * Nonetheless (possibly due to the close proximity to the
+         * "ec_point_formats" extension, which is allowed in the ServerHello),
+         * there are several servers that send this extension in the
+         * ServerHello anyway.  Up to and including the 1.1.0 release,
+         * we did not check for the presence of nonpermitted extensions,
+         * so to avoid a regression, we must permit this extension in the
+         * TLS 1.2 ServerHello as well.
+         *
+         * Note that there is no tls_parse_stoc_supported_groups function,
+         * so we do not perform any additional parsing, validation, or
+         * processing on the server's group list -- this is just a minimal
+         * change to preserve compatibility with these misbehaving servers.
+         */
+        TLSEXT_TYPE_supported_groups,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS
+        | SSL_EXT_TLS1_2_SERVER_HELLO,
+        NULL, tls_parse_ctos_supported_groups_ntls, NULL,
+        tls_construct_stoc_supported_groups_ntls,
+        tls_construct_ctos_supported_groups_ntls, NULL
+    },
+    {
+        TLSEXT_TYPE_session_ticket,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_2_AND_BELOW_ONLY,
+        init_session_ticket, tls_parse_ctos_session_ticket_ntls,
+        tls_parse_stoc_session_ticket_ntls, tls_construct_stoc_session_ticket_ntls,
+        tls_construct_ctos_session_ticket_ntls, NULL
+    },
+#ifndef OPENSSL_NO_OCSP
+    {
+        TLSEXT_TYPE_status_request,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_3_CERTIFICATE | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST,
+        init_status_request, tls_parse_ctos_status_request_ntls,
+        tls_parse_stoc_status_request_ntls, tls_construct_stoc_status_request_ntls,
+        tls_construct_ctos_status_request_ntls, NULL
+    },
+#else
+    INVALID_EXTENSION,
+#endif
+#ifndef OPENSSL_NO_NEXTPROTONEG
+    {
+        TLSEXT_TYPE_next_proto_neg,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_2_AND_BELOW_ONLY,
+        init_npn, tls_parse_ctos_npn_ntls, tls_parse_stoc_npn_ntls,
+        tls_construct_stoc_next_proto_neg_ntls, tls_construct_ctos_npn_ntls, NULL
+    },
+#else
+    INVALID_EXTENSION,
+#endif
+    {
+        /*
+         * Must appear in this list after server_name so that finalisation
+         * happens after server_name callbacks
+         */
+        TLSEXT_TYPE_application_layer_protocol_negotiation,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS,
+        init_alpn, tls_parse_ctos_alpn_ntls, tls_parse_stoc_alpn_ntls,
+        tls_construct_stoc_alpn_ntls, tls_construct_ctos_alpn_ntls, final_alpn
+    },
+#ifndef OPENSSL_NO_SRTP
+    {
+        TLSEXT_TYPE_use_srtp,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS | SSL_EXT_DTLS_ONLY,
+        init_srtp, tls_parse_ctos_use_srtp_ntls, tls_parse_stoc_use_srtp_ntls,
+        tls_construct_stoc_use_srtp_ntls, tls_construct_ctos_use_srtp_ntls, NULL
+    },
+#else
+    INVALID_EXTENSION,
+#endif
+    {
+        TLSEXT_TYPE_encrypt_then_mac,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_2_AND_BELOW_ONLY,
+        init_etm, tls_parse_ctos_etm_ntls, tls_parse_stoc_etm_ntls,
+        tls_construct_stoc_etm_ntls, tls_construct_ctos_etm_ntls, NULL
+    },
+#ifndef OPENSSL_NO_CT
+    {
+        TLSEXT_TYPE_signed_certificate_timestamp,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_3_CERTIFICATE | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST,
+        NULL,
+        /*
+         * No server side support for this, but can be provided by a custom
+         * extension. This is an exception to the rule that custom extensions
+         * cannot override built in ones.
+         */
+        NULL, tls_parse_stoc_sct_ntls, NULL, tls_construct_ctos_sct_ntls,  NULL
+    },
+#else
+    INVALID_EXTENSION,
+#endif
+    {
+        TLSEXT_TYPE_extended_master_secret,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_2_AND_BELOW_ONLY,
+        init_ems, tls_parse_ctos_ems_ntls, tls_parse_stoc_ems_ntls,
+        tls_construct_stoc_ems_ntls, tls_construct_ctos_ems_ntls, final_ems
+    },
+    {
+        TLSEXT_TYPE_signature_algorithms_cert,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST,
+        init_sig_algs_cert, tls_parse_ctos_sig_algs_cert_ntls,
+        tls_parse_ctos_sig_algs_cert_ntls,
+        /* We do not generate signature_algorithms_cert at present. */
+        NULL, NULL, NULL
+    },
+    {
+        TLSEXT_TYPE_post_handshake_auth,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_ONLY,
+        init_post_handshake_auth,
+        tls_parse_ctos_post_handshake_auth_ntls, NULL,
+        NULL, tls_construct_ctos_post_handshake_auth_ntls,
+        NULL,
+    },
+    {
+        TLSEXT_TYPE_signature_algorithms,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST,
+        init_sig_algs, tls_parse_ctos_sig_algs_ntls,
+        tls_parse_ctos_sig_algs_ntls, tls_construct_ctos_sig_algs_ntls,
+        tls_construct_ctos_sig_algs_ntls, final_sig_algs
+    },
+    {
+        TLSEXT_TYPE_supported_versions,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_SERVER_HELLO
+        | SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST | SSL_EXT_TLS_IMPLEMENTATION_ONLY,
+        NULL,
+        /* Processed inline as part of version selection */
+        NULL, tls_parse_stoc_supported_versions_ntls,
+        tls_construct_stoc_supported_versions_ntls,
+        tls_construct_ctos_supported_versions_ntls, NULL
+    },
+    {
+        TLSEXT_TYPE_psk_kex_modes,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS_IMPLEMENTATION_ONLY
+        | SSL_EXT_TLS1_3_ONLY,
+        init_psk_kex_modes, tls_parse_ctos_psk_kex_modes_ntls, NULL, NULL,
+        tls_construct_ctos_psk_kex_modes_ntls, NULL
+    },
+    {
+        /*
+         * Must be in this list after supported_groups. We need that to have
+         * been parsed before we do this one.
+         */
+        TLSEXT_TYPE_key_share,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_SERVER_HELLO
+        | SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST | SSL_EXT_TLS_IMPLEMENTATION_ONLY
+        | SSL_EXT_TLS1_3_ONLY,
+        NULL, tls_parse_ctos_key_share_ntls, tls_parse_stoc_key_share_ntls,
+        tls_construct_stoc_key_share_ntls, tls_construct_ctos_key_share_ntls,
+        final_key_share
+    },
+    {
+        /* Must be after key_share */
+        TLSEXT_TYPE_cookie,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST
+        | SSL_EXT_TLS_IMPLEMENTATION_ONLY | SSL_EXT_TLS1_3_ONLY,
+        NULL, tls_parse_ctos_cookie_ntls, tls_parse_stoc_cookie_ntls,
+        tls_construct_stoc_cookie_ntls, tls_construct_ctos_cookie_ntls, NULL
+    },
+    {
+        /*
+         * Special unsolicited ServerHello extension only used when
+         * SSL_OP_CRYPTOPRO_TLSEXT_BUG is set. We allow it in a ClientHello but
+         * ignore it.
+         */
+        TLSEXT_TYPE_cryptopro_bug,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO
+        | SSL_EXT_TLS1_2_AND_BELOW_ONLY,
+        NULL, NULL, NULL, tls_construct_stoc_cryptopro_bug_ntls, NULL, NULL
+    },
+    {
+        TLSEXT_TYPE_early_data,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS
+        | SSL_EXT_TLS1_3_NEW_SESSION_TICKET | SSL_EXT_TLS1_3_ONLY,
+        NULL, tls_parse_ctos_early_data_ntls, tls_parse_stoc_early_data_ntls,
+        tls_construct_stoc_early_data_ntls, tls_construct_ctos_early_data_ntls,
+        final_early_data
+    },
+    {
+        TLSEXT_TYPE_certificate_authorities,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST
+        | SSL_EXT_TLS1_3_ONLY,
+        init_certificate_authorities,
+        tls_parse_certificate_authorities, tls_parse_certificate_authorities,
+        tls_construct_certificate_authorities,
+        tls_construct_certificate_authorities, NULL,
+    },
+    {
+        /* Must be immediately before pre_shared_key */
+        TLSEXT_TYPE_padding,
+        SSL_EXT_CLIENT_HELLO,
+        NULL,
+        /* We send this, but don't read it */
+        NULL, NULL, NULL, tls_construct_ctos_padding_ntls, NULL
+    },
+    {
+        /* Required by the TLSv1.3 spec to always be the last extension */
+        TLSEXT_TYPE_psk,
+        SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_SERVER_HELLO
+        | SSL_EXT_TLS_IMPLEMENTATION_ONLY | SSL_EXT_TLS1_3_ONLY,
+        NULL, tls_parse_ctos_psk_ntls, tls_parse_stoc_psk_ntls, tls_construct_stoc_psk_ntls,
+        tls_construct_ctos_psk_ntls, final_psk
+    }
+};
+
+/* Check whether an extension's context matches the current context */
+static int validate_context(SSL_CONNECTION *s, unsigned int extctx, unsigned int thisctx)
+{
+    /* Check we're allowed to use this extension in this context */
+    if ((thisctx & extctx) == 0)
+        return 0;
+
+    if (SSL_CONNECTION_IS_DTLS(s)) {
+        if ((extctx & SSL_EXT_TLS_ONLY) != 0)
+            return 0;
+    } else if ((extctx & SSL_EXT_DTLS_ONLY) != 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
+int tls_validate_all_contexts_ntls(SSL_CONNECTION *s, unsigned int thisctx, RAW_EXTENSION *exts)
+{
+    size_t i, num_exts, builtin_num = OSSL_NELEM(ext_defs), offset;
+    RAW_EXTENSION *thisext;
+    unsigned int context;
+    ENDPOINT role = ENDPOINT_BOTH;
+
+    if ((thisctx & SSL_EXT_CLIENT_HELLO) != 0)
+        role = ENDPOINT_SERVER;
+    else if ((thisctx & SSL_EXT_TLS1_2_SERVER_HELLO) != 0)
+        role = ENDPOINT_CLIENT;
+
+    /* Calculate the number of extensions in the extensions list */
+    num_exts = builtin_num + s->cert->custext.meths_count;
+
+    for (thisext = exts, i = 0; i < num_exts; i++, thisext++) {
+        if (!thisext->present)
+            continue;
+
+        if (i < builtin_num) {
+            context = ext_defs[i].context;
+        } else {
+            custom_ext_method *meth = NULL;
+
+            meth = custom_ext_find_ntls(&s->cert->custext, role, thisext->type,
+                                   &offset);
+            if (!ossl_assert(meth != NULL))
+                return 0;
+            context = meth->context;
+        }
+
+        if (!validate_context(s, context, thisctx))
+            return 0;
+    }
+
+    return 1;
+}
+
+/*
+ * Verify whether we are allowed to use the extension |type| in the current
+ * |context|. Returns 1 to indicate the extension is allowed or unknown or 0 to
+ * indicate the extension is not allowed. If returning 1 then |*found| is set to
+ * the definition for the extension we found.
+ */
+static int verify_extension(SSL_CONNECTION *s, unsigned int context, unsigned int type,
+                            custom_ext_methods *meths, RAW_EXTENSION *rawexlist,
+                            RAW_EXTENSION **found)
+{
+    size_t i;
+    size_t builtin_num = OSSL_NELEM(ext_defs);
+    const EXTENSION_DEFINITION *thisext;
+
+    for (i = 0, thisext = ext_defs; i < builtin_num; i++, thisext++) {
+        if (type == thisext->type) {
+            if (!validate_context(s, thisext->context, context))
+                return 0;
+
+            *found = &rawexlist[i];
+            return 1;
+        }
+    }
+
+    /* Check the custom extensions */
+    if (meths != NULL) {
+        size_t offset = 0;
+        ENDPOINT role = ENDPOINT_BOTH;
+        custom_ext_method *meth = NULL;
+
+        if ((context & SSL_EXT_CLIENT_HELLO) != 0)
+            role = ENDPOINT_SERVER;
+        else if ((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0)
+            role = ENDPOINT_CLIENT;
+
+        meth = custom_ext_find_ntls(meths, role, type, &offset);
+        if (meth != NULL) {
+            if (!validate_context(s, meth->context, context))
+                return 0;
+            *found = &rawexlist[offset + builtin_num];
+            return 1;
+        }
+    }
+
+    /* Unknown extension. We allow it */
+    *found = NULL;
+    return 1;
+}
+
+/*
+ * Check whether the context defined for an extension |extctx| means whether
+ * the extension is relevant for the current context |thisctx| or not. Returns
+ * 1 if the extension is relevant for this context, and 0 otherwise
+ */
+int extension_is_relevant_ntls(SSL_CONNECTION *s, unsigned int extctx, unsigned int thisctx)
+{
+    int is_tls13;
+
+    /*
+     * For HRR we haven't selected the version yet but we know it will be
+     * TLSv1.3
+     */
+    if ((thisctx & SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST) != 0)
+        is_tls13 = 1;
+    else
+        is_tls13 = SSL_CONNECTION_IS_TLS13(s);
+
+    if ((SSL_CONNECTION_IS_DTLS(s)
+                && (extctx & SSL_EXT_TLS_IMPLEMENTATION_ONLY) != 0)
+            || (s->version == SSL3_VERSION
+                    && (extctx & SSL_EXT_SSL3_ALLOWED) == 0)
+            /*
+             * Note that SSL_IS_TLS13() means "TLS 1.3 has been negotiated",
+             * which is never true when generating the ClientHello.
+             * However, version negotiation *has* occurred by the time the
+             * ClientHello extensions are being parsed.
+             * Be careful to allow TLS 1.3-only extensions when generating
+             * the ClientHello.
+             */
+            || (is_tls13 && (extctx & SSL_EXT_TLS1_2_AND_BELOW_ONLY) != 0)
+            || (!is_tls13 && (extctx & SSL_EXT_TLS1_3_ONLY) != 0
+                && (thisctx & SSL_EXT_CLIENT_HELLO) == 0)
+            || (s->server && !is_tls13 && (extctx & SSL_EXT_TLS1_3_ONLY) != 0)
+            || (s->hit && (extctx & SSL_EXT_IGNORE_ON_RESUMPTION) != 0))
+        return 0;
+    return 1;
+}
+
+/*
+ * Gather a list of all the extensions from the data in |packet]. |context|
+ * tells us which message this extension is for. The raw extension data is
+ * stored in |*res| on success. We don't actually process the content of the
+ * extensions yet, except to check their types. This function also runs the
+ * initialiser functions for all known extensions if |init| is nonzero (whether
+ * we have collected them or not). If successful the caller is responsible for
+ * freeing the contents of |*res|.
+ *
+ * Per http://tools.ietf.org/html/rfc5246#section-7.4.1.4, there may not be
+ * more than one extension of the same type in a ClientHello or ServerHello.
+ * This function returns 1 if all extensions are unique and we have parsed their
+ * types, and 0 if the extensions contain duplicates, could not be successfully
+ * found, or an internal error occurred. We only check duplicates for
+ * extensions that we know about. We ignore others.
+ */
+int tls_collect_extensions_ntls(SSL_CONNECTION *s, PACKET *packet, unsigned int context,
+                           RAW_EXTENSION **res, size_t *len, int init)
+{
+    PACKET extensions = *packet;
+    size_t i = 0;
+    size_t num_exts;
+    custom_ext_methods *exts = &s->cert->custext;
+    RAW_EXTENSION *raw_extensions = NULL;
+    const EXTENSION_DEFINITION *thisexd;
+
+    *res = NULL;
+
+    /*
+     * Initialise server side custom extensions. Client side is done during
+     * construction of extensions for the ClientHello.
+     */
+    if ((context & SSL_EXT_CLIENT_HELLO) != 0)
+        custom_ext_init_ntls(&s->cert->custext);
+
+    num_exts = OSSL_NELEM(ext_defs) + (exts != NULL ? exts->meths_count : 0);
+    raw_extensions = OPENSSL_zalloc(num_exts * sizeof(*raw_extensions));
+    if (raw_extensions == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    i = 0;
+    while (PACKET_remaining(&extensions) > 0) {
+        unsigned int type, idx;
+        PACKET extension;
+        RAW_EXTENSION *thisex;
+
+        if (!PACKET_get_net_2(&extensions, &type) ||
+            !PACKET_get_length_prefixed_2(&extensions, &extension)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            goto err;
+        }
+        /*
+         * Verify this extension is allowed. We only check duplicates for
+         * extensions that we recognise. We also have a special case for the
+         * PSK extension, which must be the last one in the ClientHello.
+         */
+        if (!verify_extension(s, context, type, exts, raw_extensions, &thisex)
+                || (thisex != NULL && thisex->present == 1)
+                || (type == TLSEXT_TYPE_psk
+                    && (context & SSL_EXT_CLIENT_HELLO) != 0
+                    && PACKET_remaining(&extensions) != 0)) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);
+            goto err;
+        }
+        idx = thisex - raw_extensions;
+        /*-
+         * Check that we requested this extension (if appropriate). Requests can
+         * be sent in the ClientHello and CertificateRequest. Unsolicited
+         * extensions can be sent in the NewSessionTicket. We only do this for
+         * the built-in extensions. Custom extensions have a different but
+         * similar check elsewhere.
+         * Special cases:
+         * - The HRR cookie extension is unsolicited
+         * - The renegotiate extension is unsolicited (the client signals
+         *   support via an SCSV)
+         * - The signed_certificate_timestamp extension can be provided by a
+         * custom extension or by the built-in version. We let the extension
+         * itself handle unsolicited response checks.
+         */
+        if (idx < OSSL_NELEM(ext_defs)
+                && (context & (SSL_EXT_CLIENT_HELLO
+                               | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST
+                               | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) == 0
+                && type != TLSEXT_TYPE_cookie
+                && type != TLSEXT_TYPE_renegotiate
+                && type != TLSEXT_TYPE_signed_certificate_timestamp
+                && (s->ext.extflags[idx] & SSL_EXT_FLAG_SENT) == 0
+#ifndef OPENSSL_NO_GOST
+                && !((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0
+                     && type == TLSEXT_TYPE_cryptopro_bug)
+#endif
+								) {
+            SSLfatal_ntls(s, SSL_AD_UNSUPPORTED_EXTENSION,
+                     SSL_R_UNSOLICITED_EXTENSION);
+            goto err;
+        }
+        if (thisex != NULL) {
+            thisex->data = extension;
+            thisex->present = 1;
+            thisex->type = type;
+            thisex->received_order = i++;
+            if (s->ext.debug_cb)
+                s->ext.debug_cb(SSL_CONNECTION_GET_USER_SSL(s), !s->server, thisex->type,
+                                PACKET_data(&thisex->data),
+                                PACKET_remaining(&thisex->data),
+                                s->ext.debug_arg);
+        }
+    }
+
+    if (init) {
+        /*
+         * Initialise all known extensions relevant to this context,
+         * whether we have found them or not
+         */
+        for (thisexd = ext_defs, i = 0; i < OSSL_NELEM(ext_defs);
+             i++, thisexd++) {
+            if (thisexd->init != NULL && (thisexd->context & context) != 0
+                && extension_is_relevant_ntls(s, thisexd->context, context)
+                && !thisexd->init(s, context)) {
+                /* SSLfatal_ntls() already called */
+                goto err;
+            }
+        }
+    }
+
+    *res = raw_extensions;
+    if (len != NULL)
+        *len = num_exts;
+    return 1;
+
+ err:
+    OPENSSL_free(raw_extensions);
+    return 0;
+}
+
+/*
+ * Runs the parser for a given extension with index |idx|. |exts| contains the
+ * list of all parsed extensions previously collected by
+ * tls_collect_extensions_ntls(). The parser is only run if it is applicable for the
+ * given |context| and the parser has not already been run. If this is for a
+ * Certificate message, then we also provide the parser with the relevant
+ * Certificate |x| and its position in the |chainidx| with 0 being the first
+ * Certificate. Returns 1 on success or 0 on failure. If an extension is not
+ * present this counted as success.
+ */
+int tls_parse_extension_ntls(SSL_CONNECTION *s, TLSEXT_INDEX idx, int context,
+                        RAW_EXTENSION *exts, X509 *x, size_t chainidx)
+{
+    RAW_EXTENSION *currext = &exts[idx];
+    int (*parser)(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                  size_t chainidx) = NULL;
+
+    /* Skip if the extension is not present */
+    if (!currext->present)
+        return 1;
+
+    /* Skip if we've already parsed this extension */
+    if (currext->parsed)
+        return 1;
+
+    currext->parsed = 1;
+
+    if (idx < OSSL_NELEM(ext_defs)) {
+        /* We are handling a built-in extension */
+        const EXTENSION_DEFINITION *extdef = &ext_defs[idx];
+
+        /* Check if extension is defined for our protocol. If not, skip */
+        if (!extension_is_relevant_ntls(s, extdef->context, context))
+            return 1;
+
+        parser = s->server ? extdef->parse_ctos : extdef->parse_stoc;
+
+        if (parser != NULL)
+            return parser(s, &currext->data, context, x, chainidx);
+
+        /*
+         * If the parser is NULL we fall through to the custom extension
+         * processing
+         */
+    }
+
+    /* Parse custom extensions */
+    return custom_ext_parse_ntls(s, context, currext->type,
+                            PACKET_data(&currext->data),
+                            PACKET_remaining(&currext->data),
+                            x, chainidx);
+}
+
+/*
+ * Parse all remaining extensions that have not yet been parsed. Also calls the
+ * finalisation for all extensions at the end if |fin| is nonzero, whether we
+ * collected them or not. Returns 1 for success or 0 for failure. If we are
+ * working on a Certificate message then we also pass the Certificate |x| and
+ * its position in the |chainidx|, with 0 being the first certificate.
+ */
+int tls_parse_all_extensions_ntls(SSL_CONNECTION *s, int context, RAW_EXTENSION *exts, X509 *x,
+                             size_t chainidx, int fin)
+{
+    size_t i, numexts = OSSL_NELEM(ext_defs);
+    const EXTENSION_DEFINITION *thisexd;
+
+    /* Calculate the number of extensions in the extensions list */
+    numexts += s->cert->custext.meths_count;
+
+    /* Parse each extension in turn */
+    for (i = 0; i < numexts; i++) {
+        if (!tls_parse_extension_ntls(s, i, context, exts, x, chainidx)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+
+    if (fin) {
+        /*
+         * Finalise all known extensions relevant to this context,
+         * whether we have found them or not
+         */
+        for (i = 0, thisexd = ext_defs; i < OSSL_NELEM(ext_defs);
+             i++, thisexd++) {
+            if (thisexd->final != NULL && (thisexd->context & context) != 0
+                && !thisexd->final(s, context, exts[i].present)) {
+                /* SSLfatal_ntls() already called */
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+
+int should_add_extension_ntls(SSL_CONNECTION *s, unsigned int extctx, unsigned int thisctx,
+                         int max_version)
+{
+    /* Skip if not relevant for our context */
+    if ((extctx & thisctx) == 0)
+        return 0;
+
+    /* Check if this extension is defined for our protocol. If not, skip */
+    if (!extension_is_relevant_ntls(s, extctx, thisctx)
+            || ((extctx & SSL_EXT_TLS1_3_ONLY) != 0
+                && (thisctx & SSL_EXT_CLIENT_HELLO) != 0
+                && (SSL_CONNECTION_IS_DTLS(s) || max_version < TLS1_3_VERSION)))
+        return 0;
+
+    return 1;
+}
+
+/*
+ * Construct all the extensions relevant to the current |context| and write
+ * them to |pkt|. If this is an extension for a Certificate in a Certificate
+ * message, then |x| will be set to the Certificate we are handling, and
+ * |chainidx| will indicate the position in the chainidx we are processing (with
+ * 0 being the first in the chain). Returns 1 on success or 0 on failure. On a
+ * failure construction stops at the first extension to fail to construct.
+ */
+int tls_construct_extensions_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                             X509 *x, size_t chainidx)
+{
+    size_t i;
+    int min_version, max_version = 0, reason;
+    const EXTENSION_DEFINITION *thisexd;
+
+    if (!WPACKET_start_sub_packet_u16(pkt)
+               /*
+                * If extensions are of zero length then we don't even add the
+                * extensions length bytes to a ClientHello/ServerHello
+                * (for non-TLSv1.3).
+                */
+            || ((context &
+                 (SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO)) != 0
+                && !WPACKET_set_flags(pkt,
+                                     WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH))) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if ((context & SSL_EXT_CLIENT_HELLO) != 0) {
+        reason = ssl_get_min_max_version_ntls(s, &min_version, &max_version, NULL);
+        if (reason != 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, reason);
+            return 0;
+        }
+    }
+
+    /* Add custom extensions first */
+    if ((context & SSL_EXT_CLIENT_HELLO) != 0) {
+        /* On the server side with initialise during ClientHello parsing */
+        custom_ext_init_ntls(&s->cert->custext);
+    }
+    if (!custom_ext_add_ntls(s, context, pkt, x, chainidx, max_version)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    for (i = 0, thisexd = ext_defs; i < OSSL_NELEM(ext_defs); i++, thisexd++) {
+        EXT_RETURN (*construct)(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                X509 *x, size_t chainidx);
+        EXT_RETURN ret;
+
+        /* Skip if not relevant for our context */
+        if (!should_add_extension_ntls(s, thisexd->context, context, max_version))
+            continue;
+
+        construct = s->server ? thisexd->construct_stoc
+                              : thisexd->construct_ctos;
+
+        if (construct == NULL)
+            continue;
+
+        ret = construct(s, pkt, context, x, chainidx);
+        if (ret == EXT_RETURN_FAIL) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+        if (ret == EXT_RETURN_SENT
+                && (context & (SSL_EXT_CLIENT_HELLO
+                               | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST
+                               | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) != 0)
+            s->ext.extflags[i] |= SSL_EXT_FLAG_SENT;
+    }
+
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+/*
+ * Built in extension finalisation and initialisation functions. All initialise
+ * or finalise the associated extension type for the given |context|. For
+ * finalisers |sent| is set to 1 if we saw the extension during parsing, and 0
+ * otherwise. These functions return 1 on success or 0 on failure.
+ */
+
+static ossl_inline void ssl_tsan_decr(const SSL_CTX *ctx,
+                                      TSAN_QUALIFIER int *stat)
+{
+    if (ssl_tsan_lock(ctx)) {
+        tsan_decr(stat);
+        ssl_tsan_unlock(ctx);
+    }
+}
+
+static int init_server_name(SSL_CONNECTION *s, unsigned int context)
+{
+    if (s->server) {
+        s->servername_done = 0;
+
+        OPENSSL_free(s->ext.hostname);
+        s->ext.hostname = NULL;
+    }
+
+    return 1;
+}
+
+static int final_server_name(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    int ret = SSL_TLSEXT_ERR_NOACK;
+    int altmp = SSL_AD_UNRECOGNIZED_NAME;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    int was_ticket = (SSL_get_options(ssl) & SSL_OP_NO_TICKET) == 0;
+
+    if (!ossl_assert(sctx != NULL) || !ossl_assert(s->session_ctx != NULL)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (sctx->ext.servername_cb != NULL)
+        ret = sctx->ext.servername_cb(ussl, &altmp,
+                                        sctx->ext.servername_arg);
+    else if (s->session_ctx->ext.servername_cb != NULL)
+        ret = s->session_ctx->ext.servername_cb(ussl, &altmp,
+                                       s->session_ctx->ext.servername_arg);
+
+    /*
+     * For servers, propagate the SNI hostname from the temporary
+     * storage in the SSL to the persistent SSL_SESSION, now that we
+     * know we accepted it.
+     * Clients make this copy when parsing the server's response to
+     * the extension, which is when they find out that the negotiation
+     * was successful.
+     */
+    if (s->server) {
+        if (sent && ret == SSL_TLSEXT_ERR_OK && !s->hit) {
+            /* Only store the hostname in the session if we accepted it. */
+            OPENSSL_free(s->session->ext.hostname);
+            s->session->ext.hostname = OPENSSL_strdup(s->ext.hostname);
+            if (s->session->ext.hostname == NULL && s->ext.hostname != NULL) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            }
+        }
+    }
+
+    /*
+     * If we switched contexts (whether here or in the client_hello callback),
+     * move the sess_accept increment from the session_ctx to the new
+     * context, to avoid the confusing situation of having sess_accept_good
+     * exceed sess_accept (zero) for the new context.
+     */
+    if (SSL_IS_FIRST_HANDSHAKE(s) && sctx != s->session_ctx
+            && s->hello_retry_request == SSL_HRR_NONE) {
+        ssl_tsan_counter(sctx, &sctx->stats.sess_accept);
+        ssl_tsan_decr(s->session_ctx, &s->session_ctx->stats.sess_accept);
+    }
+
+    /*
+     * If we're expecting to send a ticket, and tickets were previously enabled,
+     * and now tickets are disabled, then turn off expected ticket.
+     * Also, if this is not a resumption, create a new session ID
+     */
+    if (ret == SSL_TLSEXT_ERR_OK && s->ext.ticket_expected
+            && was_ticket && (SSL_get_options(ssl) & SSL_OP_NO_TICKET) != 0) {
+        s->ext.ticket_expected = 0;
+        if (!s->hit) {
+            SSL_SESSION* ss = SSL_get_session(ssl);
+
+            if (ss != NULL) {
+                OPENSSL_free(ss->ext.tick);
+                ss->ext.tick = NULL;
+                ss->ext.ticklen = 0;
+                ss->ext.tick_lifetime_hint = 0;
+                ss->ext.tick_age_add = 0;
+                if (!ssl_generate_session_id(s, ss)) {
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    return 0;
+                }
+            } else {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+        }
+    }
+
+    switch (ret) {
+    case SSL_TLSEXT_ERR_ALERT_FATAL:
+        SSLfatal_ntls(s, altmp, SSL_R_CALLBACK_FAILED);
+        return 0;
+
+    case SSL_TLSEXT_ERR_ALERT_WARNING:
+        ssl3_send_alert(s, SSL3_AL_WARNING, altmp);
+        s->servername_done = 0;
+        return 1;
+
+    case SSL_TLSEXT_ERR_NOACK:
+        s->servername_done = 0;
+        return 1;
+
+    default:
+        return 1;
+    }
+}
+
+static int final_ec_pt_formats(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    /* Ignore ec_point_formats */
+    return 1;
+}
+
+static int init_session_ticket(SSL_CONNECTION *s, unsigned int context)
+{
+    if (!s->server)
+        s->ext.ticket_expected = 0;
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_OCSP
+static int init_status_request(SSL_CONNECTION *s, unsigned int context)
+{
+    if (s->server) {
+        s->ext.status_type = TLSEXT_STATUSTYPE_nothing;
+    } else {
+        /*
+         * Ensure we get sensible values passed to tlsext_status_cb in the event
+         * that we don't receive a status message
+         */
+        OPENSSL_free(s->ext.ocsp.resp);
+        s->ext.ocsp.resp = NULL;
+        s->ext.ocsp.resp_len = 0;
+    }
+
+    return 1;
+}
+#endif
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+static int init_npn(SSL_CONNECTION *s, unsigned int context)
+{
+    s->s3.npn_seen = 0;
+
+    return 1;
+}
+#endif
+
+static int init_alpn(SSL_CONNECTION *s, unsigned int context)
+{
+    OPENSSL_free(s->s3.alpn_selected);
+    s->s3.alpn_selected = NULL;
+    s->s3.alpn_selected_len = 0;
+    if (s->server) {
+        OPENSSL_free(s->s3.alpn_proposed);
+        s->s3.alpn_proposed = NULL;
+        s->s3.alpn_proposed_len = 0;
+    }
+    return 1;
+}
+
+static int final_alpn(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    if (!s->server && !sent && s->session->ext.alpn_selected != NULL)
+            s->ext.early_data_ok = 0;
+        return 1;
+
+    /*
+     * Call alpn_select callback if needed.  Has to be done after SNI and
+     * cipher negotiation (HTTP/2 restricts permitted ciphers). In TLSv1.3
+     * we also have to do this before we decide whether to accept early_data.
+     * In TLSv1.3 we've already negotiated our cipher so we do this call now.
+     * For < TLSv1.3 we defer it until after cipher negotiation.
+     *
+     * On failure SSLfatal_ntls() already called.
+     */
+    return tls_handle_alpn_ntls(s);
+}
+
+static int init_sig_algs(SSL_CONNECTION *s, unsigned int context)
+{
+    /* Clear any signature algorithms extension received */
+    OPENSSL_free(s->s3.tmp.peer_sigalgs);
+    s->s3.tmp.peer_sigalgs = NULL;
+    s->s3.tmp.peer_sigalgslen = 0;
+
+    return 1;
+}
+
+static int init_sig_algs_cert(SSL_CONNECTION *s, ossl_unused unsigned int context)
+{
+    /* Clear any signature algorithms extension received */
+    OPENSSL_free(s->s3.tmp.peer_cert_sigalgs);
+    s->s3.tmp.peer_cert_sigalgs = NULL;
+    s->s3.tmp.peer_cert_sigalgslen = 0;
+
+    return 1;
+}
+
+static int init_ec_point_formats(SSL_CONNECTION *s, unsigned int context)
+{
+    OPENSSL_free(s->ext.peer_ecpointformats);
+    s->ext.peer_ecpointformats = NULL;
+    s->ext.peer_ecpointformats_len = 0;
+
+    return 1;
+}
+
+static int init_etm(SSL_CONNECTION *s, unsigned int context)
+{
+    s->ext.use_etm = 0;
+
+    return 1;
+}
+
+static int init_ems(SSL_CONNECTION *s, unsigned int context)
+{
+    if (s->s3.flags & TLS1_FLAGS_RECEIVED_EXTMS) {
+        s->s3.flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;
+        s->s3.flags |= TLS1_FLAGS_REQUIRED_EXTMS;
+    }
+
+    return 1;
+}
+
+static int final_ems(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    /* Ignore extended_master_secret */
+    return 1;
+}
+
+static int init_certificate_authorities(SSL_CONNECTION *s, unsigned int context)
+{
+    sk_X509_NAME_pop_free(s->s3.tmp.peer_ca_names, X509_NAME_free);
+    s->s3.tmp.peer_ca_names = NULL;
+    return 1;
+}
+
+static EXT_RETURN tls_construct_certificate_authorities(SSL_CONNECTION *s, WPACKET *pkt,
+                                                        unsigned int context,
+                                                        X509 *x,
+                                                        size_t chainidx)
+{
+    const STACK_OF(X509_NAME) *ca_sk = get_ca_names_ntls(s);
+
+    if (ca_sk == NULL || sk_X509_NAME_num(ca_sk) == 0)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_certificate_authorities)
+        || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!construct_ca_names_ntls(s, ca_sk, pkt)) {
+        /* SSLfatal_ntls() already called */
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+static int tls_parse_certificate_authorities(SSL_CONNECTION *s, PACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    if (!parse_ca_names_ntls(s, pkt))
+        return 0;
+    if (PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+    return 1;
+}
+
+#ifndef OPENSSL_NO_SRTP
+static int init_srtp(SSL_CONNECTION *s, unsigned int context)
+{
+    if (s->server)
+        s->srtp_profile = NULL;
+
+    return 1;
+}
+#endif
+
+static int final_sig_algs(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    return 1;
+}
+
+static int final_key_share(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    return 1;
+}
+
+static int init_psk_kex_modes(SSL_CONNECTION *s, unsigned int context)
+{
+    s->ext.psk_kex_mode = TLSEXT_KEX_MODE_FLAG_NONE;
+    return 1;
+}
+
+int tls_psk_do_binder_ntls(SSL_CONNECTION *s, const EVP_MD *md, const unsigned char *msgstart,
+                      size_t binderoffset, const unsigned char *binderin,
+                      unsigned char *binderout, SSL_SESSION *sess, int sign,
+                      int external)
+{
+    EVP_PKEY *mackey = NULL;
+    EVP_MD_CTX *mctx = NULL;
+    unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE];
+    unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE];
+    unsigned char *early_secret;
+#ifdef CHARSET_EBCDIC
+    static const unsigned char resumption_label[] = { 0x72, 0x65, 0x73, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x65, 0x72, 0x00 };
+    static const unsigned char external_label[]   = { 0x65, 0x78, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x65, 0x72, 0x00 };
+#else
+    static const unsigned char resumption_label[] = "res binder";
+    static const unsigned char external_label[] = "ext binder";
+#endif
+    const unsigned char *label;
+    size_t bindersize, labelsize, hashsize;
+    int hashsizei = EVP_MD_get_size(md);
+    int ret = -1;
+    int usepskfored = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /* Ensure cast to size_t is safe */
+    if (!ossl_assert(hashsizei >= 0)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    hashsize = (size_t)hashsizei;
+
+    if (external
+            && s->early_data_state == SSL_EARLY_DATA_CONNECTING
+            && s->session->ext.max_early_data == 0
+            && sess->ext.max_early_data > 0)
+        usepskfored = 1;
+
+    if (external) {
+        label = external_label;
+        labelsize = sizeof(external_label) - 1;
+    } else {
+        label = resumption_label;
+        labelsize = sizeof(resumption_label) - 1;
+    }
+
+    /*
+     * Generate the early_secret. On the server side we've selected a PSK to
+     * resume with (internal or external) so we always do this. On the client
+     * side we do this for a non-external (i.e. resumption) PSK or external PSK
+     * that will be used for early_data so that it is in place for sending early
+     * data. For client side external PSK not being used for early_data we
+     * generate it but store it away for later use.
+     */
+    if (s->server || !external || usepskfored)
+        early_secret = (unsigned char *)s->early_secret;
+    else
+        early_secret = (unsigned char *)sess->early_secret;
+
+    if (!tls13_generate_secret(s, md, NULL, sess->master_key,
+                               sess->master_key_length, early_secret)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    /*
+     * Create the handshake hash for the binder key...the messages so far are
+     * empty!
+     */
+    mctx = EVP_MD_CTX_new();
+    if (mctx == NULL
+            || EVP_DigestInit_ex(mctx, md, NULL) <= 0
+            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /* Generate the binder key */
+    if (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash,
+                           hashsize, binderkey, hashsize, 1)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    /* Generate the finished key */
+    if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /*
+     * Get a hash of the ClientHello up to the start of the binders. If we are
+     * following a HelloRetryRequest then this includes the hash of the first
+     * ClientHello and the HelloRetryRequest itself.
+     */
+    if (s->hello_retry_request == SSL_HRR_PENDING) {
+        size_t hdatalen;
+        long hdatalen_l;
+        void *hdata;
+
+        hdatalen = hdatalen_l =
+            BIO_get_mem_data(s->s3.handshake_buffer, &hdata);
+        if (hdatalen_l <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_HANDSHAKE_LENGTH);
+            goto err;
+        }
+
+        /*
+         * For servers the handshake buffer data will include the second
+         * ClientHello - which we don't want - so we need to take that bit off.
+         */
+        if (s->server) {
+            PACKET hashprefix, msg;
+
+            /* Find how many bytes are left after the first two messages */
+            if (!PACKET_buf_init(&hashprefix, hdata, hdatalen)
+                    || !PACKET_forward(&hashprefix, 1)
+                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)
+                    || !PACKET_forward(&hashprefix, 1)
+                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+            hdatalen -= PACKET_remaining(&hashprefix);
+        }
+
+        if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+    }
+
+    if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0
+            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    mackey = EVP_PKEY_new_raw_private_key_ex(sctx->libctx, "HMAC",
+                                             sctx->propq, finishedkey,
+                                             hashsize);
+    if (mackey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!sign)
+        binderout = tmpbinder;
+
+    bindersize = hashsize;
+    if (EVP_DigestSignInit_ex(mctx, NULL, EVP_MD_get0_name(md), sctx->libctx,
+                              sctx->propq, mackey, NULL) <= 0
+            || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0
+            || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0
+            || bindersize != hashsize) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (sign) {
+        ret = 1;
+    } else {
+        /* HMAC keys can't do EVP_DigestVerify* - use CRYPTO_memcmp instead */
+        ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);
+        if (!ret)
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BINDER_DOES_NOT_VERIFY);
+    }
+
+ err:
+    OPENSSL_cleanse(binderkey, sizeof(binderkey));
+    OPENSSL_cleanse(finishedkey, sizeof(finishedkey));
+    EVP_PKEY_free(mackey);
+    EVP_MD_CTX_free(mctx);
+
+    return ret;
+}
+
+static int final_early_data(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    if (!sent)
+        return 1;
+
+    if (!s->server) {
+        if (context == SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS
+                && sent
+                && !s->ext.early_data_ok) {
+            /*
+             * If we get here then the server accepted our early_data but we
+             * later realised that it shouldn't have done (e.g. inconsistent
+             * ALPN)
+             */
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EARLY_DATA);
+            return 0;
+        }
+
+        return 1;
+    }
+
+    if (s->max_early_data == 0
+            || !s->hit
+            || s->early_data_state != SSL_EARLY_DATA_ACCEPTING
+            || !s->ext.early_data_ok
+            || s->hello_retry_request != SSL_HRR_NONE
+            || (s->allow_early_data_cb != NULL
+                && !s->allow_early_data_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                         s->allow_early_data_cb_data))) {
+        s->ext.early_data = SSL_EARLY_DATA_REJECTED;
+    } else {
+        s->ext.early_data = SSL_EARLY_DATA_ACCEPTED;
+
+        if (!tls13_change_cipher_state(s,
+                    SSL3_CC_EARLY | SSL3_CHANGE_CIPHER_SERVER_READ)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static int final_maxfragmentlen(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    /*
+     * Session resumption on server-side with MFL extension active
+     *  BUT MFL extension packet was not resent (i.e. sent == 0)
+     */
+    if (s->server && s->hit && USE_MAX_FRAGMENT_LENGTH_EXT(s->session)
+            && !sent ) {
+        SSLfatal_ntls(s, SSL_AD_MISSING_EXTENSION, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /* Current SSL buffer is lower than requested MFL */
+    if (s->session && USE_MAX_FRAGMENT_LENGTH_EXT(s->session)) {
+            s->rlayer.rrlmethod->set_max_frag_len(s->rlayer.rrl,
+                                              GET_MAX_FRAGMENT_LENGTH(s->session));
+            s->rlayer.wrlmethod->set_max_frag_len(s->rlayer.wrl,
+                                              ssl_get_max_send_fragment(s));
+        }
+    return 1;
+}
+
+static int init_post_handshake_auth(SSL_CONNECTION *s, ossl_unused unsigned int context)
+{
+    s->post_handshake_auth = SSL_PHA_NONE;
+
+    return 1;
+}
+
+/*
+ * If clients offer "pre_shared_key" without a "psk_key_exchange_modes"
+ * extension, servers MUST abort the handshake.
+ */
+static int final_psk(SSL_CONNECTION *s, unsigned int context, int sent)
+{
+    if (s->server && sent && s->clienthello != NULL
+            && !s->clienthello->pre_proc_exts[TLSEXT_IDX_psk_kex_modes].present) {
+        SSLfatal(s, TLS13_AD_MISSING_EXTENSION,
+                 SSL_R_MISSING_PSK_KEX_MODES_EXTENSION);
+        return 0;
+    }
+
+    return 1;
+}
Index: b/ssl/statem_ntls/ntls_extensions_clnt.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_extensions_clnt.c
@@ -0,0 +1,1610 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include <openssl/ocsp.h>
+#include "ntls_ssl_local.h"
+#include "internal/cryptlib.h"
+#include "ntls_statem_local.h"
+
+EXT_RETURN tls_construct_ctos_server_name_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                          unsigned int context, X509 *x,
+                                          size_t chainidx)
+{
+    if (s->ext.hostname == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    /* Add TLS extension servername to the Client Hello message */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)
+               /* Sub-packet for server_name extension */
+            || !WPACKET_start_sub_packet_u16(pkt)
+               /* Sub-packet for servername list (always 1 hostname)*/
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_put_bytes_u8(pkt, TLSEXT_NAMETYPE_host_name)
+            || !WPACKET_sub_memcpy_u16(pkt, s->ext.hostname,
+                                       strlen(s->ext.hostname))
+            || !WPACKET_close(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+/* Push a Max Fragment Len extension into ClientHello */
+EXT_RETURN tls_construct_ctos_maxfragmentlen_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    if (s->ext.max_fragment_len_mode == TLSEXT_max_fragment_length_DISABLED)
+        return EXT_RETURN_NOT_SENT;
+
+    /* Add Max Fragment Length extension if client enabled it. */
+    /*-
+     * 4 bytes for this extension type and extension length
+     * 1 byte for the Max Fragment Length code value.
+     */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_max_fragment_length)
+            /* Sub-packet for Max Fragment Length extension (1 byte) */
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_put_bytes_u8(pkt, s->ext.max_fragment_len_mode)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+EXT_RETURN tls_construct_ctos_ec_pt_formats_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx)
+{
+    /* No ec_point_formats */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_ctos_supported_groups_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                               unsigned int context, X509 *x,
+                                               size_t chainidx)
+{
+    /* No supported_groups */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_ctos_session_ticket_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    size_t ticklen;
+
+    if (!tls_use_ticket(s))
+        return EXT_RETURN_NOT_SENT;
+
+    if (!s->new_session && s->session != NULL
+            && s->session->ext.tick != NULL
+            && s->session->ssl_version != TLS1_3_VERSION) {
+        ticklen = s->session->ext.ticklen;
+    } else if (s->session && s->ext.session_ticket != NULL
+               && s->ext.session_ticket->data != NULL) {
+        ticklen = s->ext.session_ticket->length;
+        s->session->ext.tick = OPENSSL_malloc(ticklen);
+        if (s->session->ext.tick == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        memcpy(s->session->ext.tick,
+               s->ext.session_ticket->data, ticklen);
+        s->session->ext.ticklen = ticklen;
+    } else {
+        ticklen = 0;
+    }
+
+    if (ticklen == 0 && s->ext.session_ticket != NULL &&
+            s->ext.session_ticket->data == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_session_ticket)
+            || !WPACKET_sub_memcpy_u16(pkt, s->session->ext.tick, ticklen)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+EXT_RETURN tls_construct_ctos_sig_algs_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                       unsigned int context, X509 *x,
+                                       size_t chainidx)
+{
+    /* No signature_algorithms */
+    return EXT_RETURN_NOT_SENT;
+}
+
+#ifndef OPENSSL_NO_OCSP
+EXT_RETURN tls_construct_ctos_status_request_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    int i;
+
+    /* This extension isn't defined for client Certificates */
+    if (x != NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (s->ext.status_type != TLSEXT_STATUSTYPE_ocsp)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request)
+               /* Sub-packet for status request extension */
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_put_bytes_u8(pkt, TLSEXT_STATUSTYPE_ocsp)
+               /* Sub-packet for the ids */
+            || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+    for (i = 0; i < sk_OCSP_RESPID_num(s->ext.ocsp.ids); i++) {
+        unsigned char *idbytes;
+        OCSP_RESPID *id = sk_OCSP_RESPID_value(s->ext.ocsp.ids, i);
+        int idlen = i2d_OCSP_RESPID(id, NULL);
+
+        if (idlen <= 0
+                   /* Sub-packet for an individual id */
+                || !WPACKET_sub_allocate_bytes_u16(pkt, idlen, &idbytes)
+                || i2d_OCSP_RESPID(id, &idbytes) != idlen) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+    }
+    if (!WPACKET_close(pkt)
+            || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+    if (s->ext.ocsp.exts) {
+        unsigned char *extbytes;
+        int extlen = i2d_X509_EXTENSIONS(s->ext.ocsp.exts, NULL);
+
+        if (extlen < 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        if (!WPACKET_allocate_bytes(pkt, extlen, &extbytes)
+                || i2d_X509_EXTENSIONS(s->ext.ocsp.exts, &extbytes)
+                   != extlen) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+       }
+    }
+    if (!WPACKET_close(pkt) || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+EXT_RETURN tls_construct_ctos_npn_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    if (SSL_CONNECTION_GET_CTX(s)->ext.npn_select_cb == NULL || !SSL_IS_FIRST_HANDSHAKE(s))
+        return EXT_RETURN_NOT_SENT;
+
+    /*
+     * The client advertises an empty extension to indicate its support
+     * for Next Protocol Negotiation
+     */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_next_proto_neg)
+            || !WPACKET_put_bytes_u16(pkt, 0)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+EXT_RETURN tls_construct_ctos_alpn_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                   X509 *x, size_t chainidx)
+{
+    s->s3.alpn_sent = 0;
+
+    if (s->ext.alpn == NULL || !SSL_IS_FIRST_HANDSHAKE(s))
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt,
+                TLSEXT_TYPE_application_layer_protocol_negotiation)
+               /* Sub-packet ALPN extension */
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_sub_memcpy_u16(pkt, s->ext.alpn, s->ext.alpn_len)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+    s->s3.alpn_sent = 1;
+
+    return EXT_RETURN_SENT;
+}
+
+
+#ifndef OPENSSL_NO_SRTP
+EXT_RETURN tls_construct_ctos_use_srtp_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                       unsigned int context, X509 *x,
+                                       size_t chainidx)
+{
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    STACK_OF(SRTP_PROTECTION_PROFILE) *clnt = SSL_get_srtp_profiles(ssl);
+    int i, end;
+
+    if (clnt == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_use_srtp)
+               /* Sub-packet for SRTP extension */
+            || !WPACKET_start_sub_packet_u16(pkt)
+               /* Sub-packet for the protection profile list */
+            || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    end = sk_SRTP_PROTECTION_PROFILE_num(clnt);
+    for (i = 0; i < end; i++) {
+        const SRTP_PROTECTION_PROFILE *prof =
+            sk_SRTP_PROTECTION_PROFILE_value(clnt, i);
+
+        if (prof == NULL || !WPACKET_put_bytes_u16(pkt, prof->id)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+    }
+    if (!WPACKET_close(pkt)
+               /* Add an empty use_mki value */
+            || !WPACKET_put_bytes_u8(pkt, 0)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+EXT_RETURN tls_construct_ctos_etm_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    /* No encrypt-then-MAC */
+    return EXT_RETURN_NOT_SENT;
+}
+
+#ifndef OPENSSL_NO_CT
+EXT_RETURN tls_construct_ctos_sct_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    if (s->ct_validation_callback == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    /* Not defined for client Certificates */
+    if (x != NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_signed_certificate_timestamp)
+            || !WPACKET_put_bytes_u16(pkt, 0)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+EXT_RETURN tls_construct_ctos_ems_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    /* No extended_master_secret */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_ctos_supported_versions_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                                 unsigned int context, X509 *x,
+                                                 size_t chainidx)
+{
+    /* No supported_versions */
+    return EXT_RETURN_NOT_SENT;
+}
+
+/*
+ * Construct a psk_kex_modes extension.
+ */
+EXT_RETURN tls_construct_ctos_psk_kex_modes_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    int nodhe = s->options & SSL_OP_ALLOW_NO_DHE_KEX;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_psk_kex_modes)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_start_sub_packet_u8(pkt)
+            || !WPACKET_put_bytes_u8(pkt, TLSEXT_KEX_MODE_KE_DHE)
+            || (nodhe && !WPACKET_put_bytes_u8(pkt, TLSEXT_KEX_MODE_KE))
+            || !WPACKET_close(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    s->ext.psk_kex_mode = TLSEXT_KEX_MODE_FLAG_KE_DHE;
+    if (nodhe)
+        s->ext.psk_kex_mode |= TLSEXT_KEX_MODE_FLAG_KE;
+#endif
+
+    return EXT_RETURN_SENT;
+}
+
+#ifndef OPENSSL_NO_TLS1_3
+static int add_key_share(SSL_CONNECTION *s, WPACKET *pkt, unsigned int curve_id)
+{
+    unsigned char *encoded_point = NULL;
+    EVP_PKEY *key_share_key = NULL;
+    size_t encodedlen;
+
+    if (s->s3.tmp.pkey != NULL) {
+        if (!ossl_assert(s->hello_retry_request == SSL_HRR_PENDING)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        /*
+         * Could happen if we got an HRR that wasn't requesting a new key_share
+         */
+        key_share_key = s->s3.tmp.pkey;
+    } else {
+        key_share_key = ssl_generate_pkey_group(s, curve_id);
+        if (key_share_key == NULL) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+
+    /* Encode the public key. */
+    encodedlen = EVP_PKEY_get1_encoded_public_key(key_share_key,
+                                                  &encoded_point);
+    if (encodedlen == 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    /* Create KeyShareEntry */
+    if (!WPACKET_put_bytes_u16(pkt, curve_id)
+            || !WPACKET_sub_memcpy_u16(pkt, encoded_point, encodedlen)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /*
+     * When changing to send more than one key_share we're
+     * going to need to be able to save more than one EVP_PKEY. For now
+     * we reuse the existing tmp.pkey
+     */
+    s->s3.tmp.pkey = key_share_key;
+    s->s3.group_id = curve_id;
+    OPENSSL_free(encoded_point);
+
+    return 1;
+ err:
+    if (s->s3.tmp.pkey == NULL)
+        EVP_PKEY_free(key_share_key);
+    OPENSSL_free(encoded_point);
+    return 0;
+}
+#endif
+
+EXT_RETURN tls_construct_ctos_key_share_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                        unsigned int context, X509 *x,
+                                        size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    size_t i, num_groups = 0;
+    const uint16_t *pgroups = NULL;
+    uint16_t curve_id = 0;
+
+    /* key_share extension */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)
+               /* Extension data sub-packet */
+            || !WPACKET_start_sub_packet_u16(pkt)
+               /* KeyShare list sub-packet */
+            || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    tls1_get_supported_groups(s, &pgroups, &num_groups);
+
+    /*
+     * Make the number of key_shares sent configurable. For
+     * now, we just send one
+     */
+    if (s->s3.group_id != 0) {
+        curve_id = s->s3.group_id;
+    } else {
+        for (i = 0; i < num_groups; i++) {
+
+            if (!tls_group_allowed(s, pgroups[i], SSL_SECOP_CURVE_SUPPORTED))
+                continue;
+
+            curve_id = pgroups[i];
+            break;
+        }
+    }
+
+    if (curve_id == 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_NO_SUITABLE_KEY_SHARE);
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!add_key_share(s, pkt, curve_id)) {
+        /* SSLfatal_ntls() already called */
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!WPACKET_close(pkt) || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+    return EXT_RETURN_SENT;
+#else
+    return EXT_RETURN_NOT_SENT;
+#endif
+}
+
+EXT_RETURN tls_construct_ctos_cookie_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                     X509 *x, size_t chainidx)
+{
+    EXT_RETURN ret = EXT_RETURN_FAIL;
+
+    /* Should only be set if we've had an HRR */
+    if (s->ext.tls13_cookie_len == 0)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_cookie)
+               /* Extension data sub-packet */
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_sub_memcpy_u16(pkt, s->ext.tls13_cookie,
+                                       s->ext.tls13_cookie_len)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto end;
+    }
+
+    ret = EXT_RETURN_SENT;
+ end:
+    OPENSSL_free(s->ext.tls13_cookie);
+    s->ext.tls13_cookie = NULL;
+    s->ext.tls13_cookie_len = 0;
+
+    return ret;
+}
+
+EXT_RETURN tls_construct_ctos_early_data_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         unsigned int context, X509 *x,
+                                         size_t chainidx)
+{
+#ifndef OPENSSL_NO_PSK
+    char identity[PSK_MAX_IDENTITY_LEN + 1];
+#endif  /* OPENSSL_NO_PSK */
+    const unsigned char *id = NULL;
+    size_t idlen = 0;
+    SSL_SESSION *psksess = NULL;
+    SSL_SESSION *edsess = NULL;
+    const EVP_MD *handmd = NULL;
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    if (s->hello_retry_request == SSL_HRR_PENDING)
+        handmd = ssl_handshake_md(s);
+
+    if (s->psk_use_session_cb != NULL
+            && (!s->psk_use_session_cb(ussl, handmd, &id, &idlen, &psksess)
+                || (psksess != NULL
+                    && psksess->ssl_version != TLS1_3_VERSION))) {
+        SSL_SESSION_free(psksess);
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);
+        return EXT_RETURN_FAIL;
+    }
+
+#ifndef OPENSSL_NO_PSK
+    if (psksess == NULL && s->psk_client_callback != NULL) {
+        unsigned char psk[PSK_MAX_PSK_LEN];
+        size_t psklen = 0;
+
+        memset(identity, 0, sizeof(identity));
+        psklen = s->psk_client_callback(ussl, NULL, identity, sizeof(identity) - 1,
+                                        psk, sizeof(psk));
+
+        if (psklen > PSK_MAX_PSK_LEN) {
+            SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        } else if (psklen > 0) {
+            const unsigned char tls13_aes128gcmsha256_id[] = { 0x13, 0x01 };
+            const SSL_CIPHER *cipher;
+
+            idlen = strlen(identity);
+            if (idlen > PSK_MAX_IDENTITY_LEN) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return EXT_RETURN_FAIL;
+            }
+            id = (unsigned char *)identity;
+
+            /*
+             * We found a PSK using an old style callback. We don't know
+             * the digest so we default to SHA256 as per the TLSv1.3 spec
+             */
+            cipher = SSL_CIPHER_find(SSL_CONNECTION_GET_SSL(s),
+                                     tls13_aes128gcmsha256_id);
+            if (cipher == NULL) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return EXT_RETURN_FAIL;
+            }
+
+            psksess = SSL_SESSION_new();
+            if (psksess == NULL
+                    || !SSL_SESSION_set1_master_key(psksess, psk, psklen)
+                    || !SSL_SESSION_set_cipher(psksess, cipher)
+                    || !SSL_SESSION_set_protocol_version(psksess, TLS1_3_VERSION)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                OPENSSL_cleanse(psk, psklen);
+                return EXT_RETURN_FAIL;
+            }
+            OPENSSL_cleanse(psk, psklen);
+        }
+    }
+#endif  /* OPENSSL_NO_PSK */
+
+    SSL_SESSION_free(s->psksession);
+    s->psksession = psksess;
+    if (psksess != NULL) {
+        OPENSSL_free(s->psksession_id);
+        s->psksession_id = OPENSSL_memdup(id, idlen);
+        if (s->psksession_id == NULL) {
+            s->psksession_id_len = 0;
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        s->psksession_id_len = idlen;
+    }
+
+    if (s->early_data_state != SSL_EARLY_DATA_CONNECTING
+            || (s->session->ext.max_early_data == 0
+                && (psksess == NULL || psksess->ext.max_early_data == 0))) {
+        s->max_early_data = 0;
+        return EXT_RETURN_NOT_SENT;
+    }
+    edsess = s->session->ext.max_early_data != 0 ? s->session : psksess;
+    s->max_early_data = edsess->ext.max_early_data;
+
+    if (edsess->ext.hostname != NULL) {
+        if (s->ext.hostname == NULL
+                || (s->ext.hostname != NULL
+                    && strcmp(s->ext.hostname, edsess->ext.hostname) != 0)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+			              SSL_R_INCONSISTENT_EARLY_DATA_SNI);
+            return EXT_RETURN_FAIL;
+        }
+    }
+
+    if ((s->ext.alpn == NULL && edsess->ext.alpn_selected != NULL)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_INCONSISTENT_EARLY_DATA_ALPN);
+        return EXT_RETURN_FAIL;
+    }
+
+    /*
+     * Verify that we are offering an ALPN protocol consistent with the early
+     * data.
+     */
+    if (edsess->ext.alpn_selected != NULL) {
+        PACKET prots, alpnpkt;
+        int found = 0;
+
+        if (!PACKET_buf_init(&prots, s->ext.alpn, s->ext.alpn_len)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        while (PACKET_get_length_prefixed_1(&prots, &alpnpkt)) {
+            if (PACKET_equal(&alpnpkt, edsess->ext.alpn_selected,
+                             edsess->ext.alpn_selected_len)) {
+                found = 1;
+                break;
+            }
+        }
+        if (!found) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                          SSL_R_INCONSISTENT_EARLY_DATA_ALPN);
+            return EXT_RETURN_FAIL;
+        }
+    }
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_early_data)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    /*
+     * We set this to rejected here. Later, if the server acknowledges the
+     * extension, we set it to accepted.
+     */
+    s->ext.early_data = SSL_EARLY_DATA_REJECTED;
+    s->ext.early_data_ok = 1;
+
+    return EXT_RETURN_SENT;
+}
+
+#define F5_WORKAROUND_MIN_MSG_LEN   0xff
+#define F5_WORKAROUND_MAX_MSG_LEN   0x200
+
+/*
+ * PSK pre binder overhead =
+ *  2 bytes for TLSEXT_TYPE_psk
+ *  2 bytes for extension length
+ *  2 bytes for identities list length
+ *  2 bytes for identity length
+ *  4 bytes for obfuscated_ticket_age
+ *  2 bytes for binder list length
+ *  1 byte for binder length
+ * The above excludes the number of bytes for the identity itself and the
+ * subsequent binder bytes
+ */
+#define PSK_PRE_BINDER_OVERHEAD (2 + 2 + 2 + 2 + 4 + 2 + 1)
+
+EXT_RETURN tls_construct_ctos_padding_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                      unsigned int context, X509 *x,
+                                      size_t chainidx)
+{
+    unsigned char *padbytes;
+    size_t hlen;
+
+    if ((s->options & SSL_OP_TLSEXT_PADDING) == 0)
+        return EXT_RETURN_NOT_SENT;
+
+    /*
+     * Add padding to workaround bugs in F5 terminators. See RFC7685.
+     * This code calculates the length of all extensions added so far but
+     * excludes the PSK extension (because that MUST be written last). Therefore
+     * this extension MUST always appear second to last.
+     */
+    if (!WPACKET_get_total_written(pkt, &hlen)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    /*
+     * If we're going to send a PSK then that will be written out after this
+     * extension, so we need to calculate how long it is going to be.
+     */
+    if (s->session->ssl_version == TLS1_3_VERSION
+            && s->session->ext.ticklen != 0
+            && s->session->cipher != NULL) {
+        const EVP_MD *md = ssl_md(SSL_CONNECTION_GET_CTX(s),
+                                    s->session->cipher->algorithm2);
+
+        if (md != NULL) {
+            /*
+             * Add the fixed PSK overhead, the identity length and the binder
+             * length.
+             */
+            hlen +=  PSK_PRE_BINDER_OVERHEAD + s->session->ext.ticklen
+                     + EVP_MD_get_size(md);
+        }
+    }
+
+    if (hlen > F5_WORKAROUND_MIN_MSG_LEN && hlen < F5_WORKAROUND_MAX_MSG_LEN) {
+        /* Calculate the amount of padding we need to add */
+        hlen = F5_WORKAROUND_MAX_MSG_LEN - hlen;
+
+        /*
+         * Take off the size of extension header itself (2 bytes for type and
+         * 2 bytes for length bytes), but ensure that the extension is at least
+         * 1 byte long so as not to have an empty extension last (WebSphere 7.x,
+         * 8.x are intolerant of that condition)
+         */
+        if (hlen > 4)
+            hlen -= 4;
+        else
+            hlen = 1;
+
+        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_padding)
+                || !WPACKET_sub_allocate_bytes_u16(pkt, hlen, &padbytes)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        memset(padbytes, 0, hlen);
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+/*
+ * Construct the pre_shared_key extension
+ */
+EXT_RETURN tls_construct_ctos_psk_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    uint32_t agesec, agems = 0;
+    size_t reshashsize = 0, pskhashsize = 0, binderoffset, msglen;
+    unsigned char *resbinder = NULL, *pskbinder = NULL, *msgstart = NULL;
+    const EVP_MD *handmd = NULL, *mdres = NULL, *mdpsk = NULL;
+    int dores = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    OSSL_TIME t;
+    s->ext.tick_identity = 0;
+
+    /*
+     * Note: At this stage of the code we only support adding a single
+     * resumption PSK. If we add support for multiple PSKs then the length
+     * calculations in the padding extension will need to be adjusted.
+     */
+
+    /*
+     * If this is an incompatible or new session then we have nothing to resume
+     * so don't add this extension.
+     */
+    if (s->session->ssl_version != TLS1_3_VERSION
+            || (s->session->ext.ticklen == 0 && s->psksession == NULL))
+        return EXT_RETURN_NOT_SENT;
+
+    if (s->hello_retry_request == SSL_HRR_PENDING)
+        handmd = ssl_handshake_md(s);
+
+    if (s->session->ext.ticklen != 0) {
+        /* Get the digest associated with the ciphersuite in the session */
+        if (s->session->cipher == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        mdres = ssl_md(sctx, s->session->cipher->algorithm2);
+        if (mdres == NULL) {
+            /*
+             * Don't recognize this cipher so we can't use the session.
+             * Ignore it
+             */
+            goto dopsksess;
+        }
+
+        if (s->hello_retry_request == SSL_HRR_PENDING && mdres != handmd) {
+            /*
+             * Selected ciphersuite hash does not match the hash for the session
+             * so we can't use it.
+             */
+            goto dopsksess;
+        }
+
+        /*
+         * Technically the C standard just says time() returns a time_t and says
+         * nothing about the encoding of that type. In practice most
+         * implementations follow POSIX which holds it as an integral type in
+         * seconds since epoch. We've already made the assumption that we can do
+         * this in multiple places in the code, so portability shouldn't be an
+         * issue.
+         */
+        t = ossl_time_subtract(ossl_time_now(), s->session->time);
+        agesec = (uint32_t)ossl_time2seconds(t);
+        /*
+         * We calculate the age in seconds but the server may work in ms. Due to
+         * rounding errors we could overestimate the age by up to 1s. It is
+         * better to underestimate it. Otherwise, if the RTT is very short, when
+         * the server calculates the age reported by the client it could be
+         * bigger than the age calculated on the server - which should never
+         * happen.
+         */
+        if (agesec > 0)
+            agesec--;
+
+        if (s->session->ext.tick_lifetime_hint < agesec) {
+            /* Ticket is too old. Ignore it. */
+            goto dopsksess;
+        }
+
+        /*
+         * Calculate age in ms. We're just doing it to nearest second. Should be
+         * good enough.
+         */
+        agems = agesec * (uint32_t)1000;
+
+        if (agesec != 0 && agems / (uint32_t)1000 != agesec) {
+            /*
+             * Overflow. Shouldn't happen unless this is a *really* old session.
+             * If so we just ignore it.
+             */
+            goto dopsksess;
+        }
+
+        /*
+         * Obfuscate the age. Overflow here is fine, this addition is supposed
+         * to be mod 2^32.
+         */
+        agems += s->session->ext.tick_age_add;
+
+        reshashsize = EVP_MD_get_size(mdres);
+        s->ext.tick_identity++;
+        dores = 1;
+    }
+
+ dopsksess:
+    if (!dores && s->psksession == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (s->psksession != NULL) {
+        mdpsk = ssl_md(sctx, s->psksession->cipher->algorithm2);
+        if (mdpsk == NULL) {
+            /*
+             * Don't recognize this cipher so we can't use the session.
+             * If this happens it's an application bug.
+             */
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);
+            return EXT_RETURN_FAIL;
+        }
+
+        if (s->hello_retry_request == SSL_HRR_PENDING && mdpsk != handmd) {
+            /*
+             * Selected ciphersuite hash does not match the hash for the PSK
+             * session. This is an application bug.
+             */
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);
+            return EXT_RETURN_FAIL;
+        }
+
+        pskhashsize = EVP_MD_get_size(mdpsk);
+    }
+
+    /* Create the extension, but skip over the binder for now */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_psk)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    if (dores) {
+        if (!WPACKET_sub_memcpy_u16(pkt, s->session->ext.tick,
+                                           s->session->ext.ticklen)
+                || !WPACKET_put_bytes_u32(pkt, agems)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+    }
+
+    if (s->psksession != NULL) {
+        if (!WPACKET_sub_memcpy_u16(pkt, s->psksession_id,
+                                    s->psksession_id_len)
+                || !WPACKET_put_bytes_u32(pkt, 0)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        s->ext.tick_identity++;
+    }
+
+    if (!WPACKET_close(pkt)
+            || !WPACKET_get_total_written(pkt, &binderoffset)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || (dores
+                && !WPACKET_sub_allocate_bytes_u8(pkt, reshashsize, &resbinder))
+            || (s->psksession != NULL
+                && !WPACKET_sub_allocate_bytes_u8(pkt, pskhashsize, &pskbinder))
+            || !WPACKET_close(pkt)
+            || !WPACKET_close(pkt)
+            || !WPACKET_get_total_written(pkt, &msglen)
+               /*
+                * We need to fill in all the sub-packet lengths now so we can
+                * calculate the HMAC of the message up to the binders
+                */
+            || !WPACKET_fill_lengths(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    msgstart = WPACKET_get_curr(pkt) - msglen;
+
+    if (dores
+            && tls_psk_do_binder_ntls(s, mdres, msgstart, binderoffset, NULL,
+                                 resbinder, s->session, 1, 0) != 1) {
+        /* SSLfatal_ntls() already called */
+        return EXT_RETURN_FAIL;
+    }
+
+    if (s->psksession != NULL
+            && tls_psk_do_binder_ntls(s, mdpsk, msgstart, binderoffset, NULL,
+                                 pskbinder, s->psksession, 1, 1) != 1) {
+        /* SSLfatal_ntls() already called */
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+#else
+    return EXT_RETURN_NOT_SENT;
+#endif
+}
+
+EXT_RETURN tls_construct_ctos_post_handshake_auth_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                                       ossl_unused unsigned int context,
+                                                       ossl_unused X509 *x,
+													   ossl_unused size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    if (!s->pha_enabled)
+        return EXT_RETURN_NOT_SENT;
+
+    /* construct extension - 0 length, no contents */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_post_handshake_auth)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    s->post_handshake_auth = SSL_PHA_EXT_SENT;
+
+    return EXT_RETURN_SENT;
+#else
+    return EXT_RETURN_NOT_SENT;
+#endif
+}
+
+/* Parse the server's max fragment len extension packet */
+int tls_parse_stoc_maxfragmentlen_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    unsigned int value;
+
+    if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /* |value| should contains a valid max-fragment-length code. */
+    if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+		              SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);
+        return 0;
+    }
+
+    /* Must be the same value as client-configured one who was sent to server */
+    /*-
+     * RFC 6066: if a client receives a maximum fragment length negotiation
+     * response that differs from the length it requested, ...
+     * It must abort with SSL_AD_ILLEGAL_PARAMETER alert
+     */
+    if (value != s->ext.max_fragment_len_mode) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                 SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);
+        return 0;
+    }
+
+    /*
+     * Maximum Fragment Length Negotiation succeeded.
+     * The negotiated Maximum Fragment Length is binding now.
+     */
+    s->session->ext.max_fragment_len_mode = value;
+
+    return 1;
+}
+
+int tls_parse_stoc_server_name_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                               X509 *x, size_t chainidx)
+{
+    if (s->ext.hostname == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (PACKET_remaining(pkt) > 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    if (!s->hit) {
+        if (s->session->ext.hostname != NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        s->session->ext.hostname = OPENSSL_strdup(s->ext.hostname);
+        if (s->session->ext.hostname == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+int tls_parse_stoc_ec_pt_formats_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx)
+{
+    /* Ignore ec_point_formats */
+    return 1;
+}
+
+int tls_parse_stoc_session_ticket_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    SSL *ssl = SSL_CONNECTION_GET_USER_SSL(s);
+    if (s->ext.session_ticket_cb != NULL &&
+        !s->ext.session_ticket_cb(ssl, PACKET_data(pkt),
+                              PACKET_remaining(pkt),
+                              s->ext.session_ticket_cb_arg)) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    if (!tls_use_ticket(s)) {
+        SSLfatal_ntls(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+    if (PACKET_remaining(pkt) > 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    s->ext.ticket_expected = 1;
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_OCSP
+int tls_parse_stoc_status_request_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    if (context == SSL_EXT_TLS1_3_CERTIFICATE_REQUEST) {
+        /* We ignore this if the server sends a CertificateRequest */
+        return 1;
+    }
+
+    /*
+     * MUST only be sent if we've requested a status
+     * request message. In TLS <= 1.2 it must also be empty.
+     */
+    if (s->ext.status_type != TLSEXT_STATUSTYPE_ocsp) {
+        SSLfatal_ntls(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+    if (PACKET_remaining(pkt) > 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /* Set flag to expect CertificateStatus message */
+    s->ext.status_expected = 1;
+
+    return 1;
+}
+#endif
+
+
+#ifndef OPENSSL_NO_CT
+int tls_parse_stoc_sct_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    if (context == SSL_EXT_TLS1_3_CERTIFICATE_REQUEST) {
+        /* We ignore this if the server sends it in a CertificateRequest */
+        return 1;
+    }
+
+    /*
+     * Only take it if we asked for it - i.e if there is no CT validation
+     * callback set, then a custom extension MAY be processing it, so we
+     * need to let control continue to flow to that.
+     */
+    if (s->ct_validation_callback != NULL) {
+        size_t size = PACKET_remaining(pkt);
+
+        /* Simply copy it off for later processing */
+        OPENSSL_free(s->ext.scts);
+        s->ext.scts = NULL;
+
+        s->ext.scts_len = (uint16_t)size;
+        if (size > 0) {
+            s->ext.scts = OPENSSL_malloc(size);
+            if (s->ext.scts == NULL) {
+			    s->ext.scts_len = 0;
+				SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+                return 0;
+			}
+            if (!PACKET_copy_bytes(pkt, s->ext.scts, size)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+        }
+    } else {
+        ENDPOINT role = (context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0
+                        ? ENDPOINT_CLIENT : ENDPOINT_BOTH;
+
+        /*
+         * If we didn't ask for it then there must be a custom extension,
+         * otherwise this is unsolicited.
+         */
+        if (custom_ext_find_ntls(&s->cert->custext, role,
+                            TLSEXT_TYPE_signed_certificate_timestamp,
+                            NULL) == NULL) {
+            SSLfatal_ntls(s, TLS1_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+        if (!custom_ext_parse_ntls(s, context,
+                             TLSEXT_TYPE_signed_certificate_timestamp,
+                             PACKET_data(pkt), PACKET_remaining(pkt),
+                             x, chainidx)) {
+            /* SSLfatal_ntls already called */
+            return 0;
+        }
+    }
+
+    return 1;
+}
+#endif
+
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+/*
+ * ssl_next_proto_validate validates a Next Protocol Negotiation block. No
+ * elements of zero length are allowed and the set of elements must exactly
+ * fill the length of the block. Returns 1 on success or 0 on failure.
+ */
+static int ssl_next_proto_validate(SSL_CONNECTION *s, PACKET *pkt)
+{
+    PACKET tmp_protocol;
+
+    while (PACKET_remaining(pkt)) {
+        if (!PACKET_get_length_prefixed_1(pkt, &tmp_protocol)
+            || PACKET_remaining(&tmp_protocol) == 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+int tls_parse_stoc_npn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    unsigned char *selected;
+    unsigned char selected_len;
+    PACKET tmppkt;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /* Check if we are in a renegotiation. If so ignore this extension */
+    if (!SSL_IS_FIRST_HANDSHAKE(s))
+        return 1;
+
+    /* We must have requested it. */
+    if (sctx->ext.npn_select_cb == NULL) {
+        SSLfatal_ntls(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /* The data must be valid */
+    tmppkt = *pkt;
+    if (!ssl_next_proto_validate(s, &tmppkt)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+    if (sctx->ext.npn_select_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                  &selected, &selected_len,
+                                  PACKET_data(pkt),
+                                  PACKET_remaining(pkt),
+                                  sctx->ext.npn_select_cb_arg) !=
+             SSL_TLSEXT_ERR_OK) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /*
+     * Could be non-NULL if server has sent multiple NPN extensions in
+     * a single Serverhello
+     */
+    OPENSSL_free(s->ext.npn);
+    s->ext.npn = OPENSSL_malloc(selected_len);
+    if (s->ext.npn == NULL) {
+        s->ext.npn_len = 0;
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    memcpy(s->ext.npn, selected, selected_len);
+    s->ext.npn_len = selected_len;
+    s->s3.npn_seen = 1;
+
+    return 1;
+}
+#endif
+
+int tls_parse_stoc_alpn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                        size_t chainidx)
+{
+    size_t len;
+
+    /* We must have requested it. */
+    if (!s->s3.alpn_sent) {
+        SSLfatal_ntls(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+    /*-
+     * The extension data consists of:
+     *   uint16 list_length
+     *   uint8 proto_length;
+     *   uint8 proto[proto_length];
+     */
+    if (!PACKET_get_net_2_len(pkt, &len)
+        || PACKET_remaining(pkt) != len || !PACKET_get_1_len(pkt, &len)
+        || PACKET_remaining(pkt) != len) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+    OPENSSL_free(s->s3.alpn_selected);
+    s->s3.alpn_selected = OPENSSL_malloc(len);
+    if (s->s3.alpn_selected == NULL) {
+        s->s3.alpn_selected_len = 0;
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    if (!PACKET_copy_bytes(pkt, s->s3.alpn_selected, len)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+    s->s3.alpn_selected_len = len;
+
+    if (s->session->ext.alpn_selected == NULL
+            || s->session->ext.alpn_selected_len != len
+            || memcmp(s->session->ext.alpn_selected, s->s3.alpn_selected, len)
+               != 0) {
+        /* ALPN not consistent with the old session so cannot use early_data */
+        s->ext.early_data_ok = 0;
+    }
+    if (!s->hit) {
+        /*
+         * This is a new session and so alpn_selected should have been
+         * initialised to NULL. We should update it with the selected ALPN.
+         */
+        if (!ossl_assert(s->session->ext.alpn_selected == NULL)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        s->session->ext.alpn_selected =
+            OPENSSL_memdup(s->s3.alpn_selected, s->s3.alpn_selected_len);
+        if (s->session->ext.alpn_selected == NULL) {
+            s->session->ext.alpn_selected_len = 0;
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        s->session->ext.alpn_selected_len = s->s3.alpn_selected_len;
+    }
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_SRTP
+int tls_parse_stoc_use_srtp_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                            size_t chainidx)
+{
+    unsigned int id, ct, mki;
+    int i;
+    STACK_OF(SRTP_PROTECTION_PROFILE) *clnt;
+    SRTP_PROTECTION_PROFILE *prof;
+
+    if (!PACKET_get_net_2(pkt, &ct) || ct != 2
+            || !PACKET_get_net_2(pkt, &id)
+            || !PACKET_get_1(pkt, &mki)
+            || PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR,
+		              SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);
+        return 0;
+    }
+
+    if (mki != 0) {
+        /* Must be no MKI, since we never offer one */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_SRTP_MKI_VALUE);
+        return 0;
+    }
+
+    /* Throw an error if the server gave us an unsolicited extension */
+    clnt = SSL_get_srtp_profiles(SSL_CONNECTION_GET_SSL(s));
+    if (clnt == NULL) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_NO_SRTP_PROFILES);
+        return 0;
+    }
+
+    /*
+     * Check to see if the server gave us something we support (and
+     * presumably offered)
+     */
+    for (i = 0; i < sk_SRTP_PROTECTION_PROFILE_num(clnt); i++) {
+        prof = sk_SRTP_PROTECTION_PROFILE_value(clnt, i);
+
+        if (prof->id == id) {
+            s->srtp_profile = prof;
+            return 1;
+        }
+    }
+
+    SSLfatal_ntls(s, SSL_AD_DECODE_ERROR,
+                  SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);
+    return 0;
+}
+#endif
+
+int tls_parse_stoc_etm_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    /* Ignore encrypt-then-MAC */
+    return 1;
+}
+
+int tls_parse_stoc_ems_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    /* Ignore extended_master_secret */
+    return 1;
+}
+
+int tls_parse_stoc_supported_versions_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                      X509 *x, size_t chainidx)
+{
+    /* Ignore supported_versions */
+    return 1;
+}
+
+int tls_parse_stoc_key_share_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                             size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    unsigned int group_id;
+    PACKET encoded_pt;
+    EVP_PKEY *ckey = s->s3.tmp.pkey, *skey = NULL;
+    const TLS_GROUP_INFO *ginf = NULL;
+
+    /* Sanity check */
+    if (ckey == NULL || s->s3.peer_tmp != NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (!PACKET_get_net_2(pkt, &group_id)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    if ((context & SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST) != 0) {
+        const uint16_t *pgroups = NULL;
+        size_t i, num_groups;
+
+        if (PACKET_remaining(pkt) != 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            return 0;
+        }
+
+        /*
+         * It is an error if the HelloRetryRequest wants a key_share that we
+         * already sent in the first ClientHello
+         */
+        if (group_id == s->s3.group_id) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+            return 0;
+        }
+
+        /* Validate the selected group is one we support */
+        tls1_get_supported_groups(s, &pgroups, &num_groups);
+        for (i = 0; i < num_groups; i++) {
+            if (group_id == pgroups[i])
+                break;
+        }
+        if (i >= num_groups
+                || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED)) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+            return 0;
+        }
+
+        s->s3.group_id = group_id;
+        EVP_PKEY_free(s->s3.tmp.pkey);
+        s->s3.tmp.pkey = NULL;
+        return 1;
+    }
+
+    if (group_id != s->s3.group_id) {
+        /*
+         * This isn't for the group that we sent in the original
+         * key_share!
+         */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+        return 0;
+    }
+    /* Retain this group in the SSL_SESSION */
+    if (!s->hit) {
+        s->session->kex_group = group_id;
+    } else if (group_id != s->session->kex_group) {
+        /*
+         * If this is a resumption but changed what group was used, we need
+         * to record the new group in the session, but the session is not
+         * a new session and could be in use by other threads.  So, make
+         * a copy of the session to record the new information so that it's
+         * useful for any sessions resumed from tickets issued on this
+         * connection.
+         */
+        SSL_SESSION *new_sess;
+
+        if ((new_sess = ssl_session_dup(s->session, 0)) == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+        SSL_SESSION_free(s->session);
+        s->session = new_sess;
+        s->session->kex_group = group_id;
+    }
+
+    if ((ginf = tls1_group_id_lookup(SSL_CONNECTION_GET_CTX(s),
+                                    group_id)) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+        return 0;
+    }
+
+    if (!PACKET_as_length_prefixed_2(pkt, &encoded_pt)
+            || PACKET_remaining(&encoded_pt) == 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    if (!ginf->is_kem) {
+        /* Regular KEX */
+        skey = EVP_PKEY_new();
+        if (skey == NULL || EVP_PKEY_copy_parameters(skey, ckey) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_COPY_PARAMETERS_FAILED);
+            EVP_PKEY_free(skey);
+            return 0;
+        }
+
+        if (tls13_set_encoded_pub_key(skey, PACKET_data(&encoded_pt),
+                                      PACKET_remaining(&encoded_pt)) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_ECPOINT);
+            EVP_PKEY_free(skey);
+            return 0;
+        }
+
+        if (ssl_derive(s, ckey, skey, 1) == 0) {
+            /* SSLfatal_ntls() already called */
+            EVP_PKEY_free(skey);
+            return 0;
+        }
+        s->s3.peer_tmp = skey;
+    } else {
+        /* KEM Mode */
+        const unsigned char *ct = PACKET_data(&encoded_pt);
+        size_t ctlen = PACKET_remaining(&encoded_pt);
+
+        if (ssl_decapsulate(s, ckey, ct, ctlen, 1) == 0) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+    s->s3.did_kex = 1;
+#endif
+
+    return 1;
+}
+
+int tls_parse_stoc_cookie_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    PACKET cookie;
+
+    if (!PACKET_as_length_prefixed_2(pkt, &cookie)
+            || !PACKET_memdup(&cookie, &s->ext.tls13_cookie,
+                              &s->ext.tls13_cookie_len)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    return 1;
+}
+
+int tls_parse_stoc_early_data_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                              X509 *x, size_t chainidx)
+{
+    if (context == SSL_EXT_TLS1_3_NEW_SESSION_TICKET) {
+        unsigned long max_early_data;
+
+        if (!PACKET_get_net_4(pkt, &max_early_data)
+                || PACKET_remaining(pkt) != 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_INVALID_MAX_EARLY_DATA);
+            return 0;
+        }
+
+        s->session->ext.max_early_data = max_early_data;
+
+        return 1;
+    }
+
+    if (PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    if (!s->ext.early_data_ok
+            || !s->hit) {
+        /*
+         * If we get here then we didn't send early data, or we didn't resume
+         * using the first identity, or the SNI/ALPN is not consistent so the
+         * server should not be accepting it.
+         */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    s->ext.early_data = SSL_EARLY_DATA_ACCEPTED;
+
+    return 1;
+}
+
+int tls_parse_stoc_psk_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    unsigned int identity;
+
+    if (!PACKET_get_net_2(pkt, &identity) || PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    if (identity >= (unsigned int)s->ext.tick_identity) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_PSK_IDENTITY);
+        return 0;
+    }
+
+    /*
+     * Session resumption tickets are always sent before PSK tickets. If the
+     * ticket index is 0 then it must be for a session resumption ticket if we
+     * sent two tickets, or if we didn't send a PSK ticket.
+     */
+    if (identity == 0 && (s->psksession == NULL || s->ext.tick_identity == 2)) {
+        s->hit = 1;
+        SSL_SESSION_free(s->psksession);
+        s->psksession = NULL;
+        return 1;
+    }
+
+    if (s->psksession == NULL) {
+        /* Should never happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /*
+     * If we used the external PSK for sending early_data then s->early_secret
+     * is already set up, so don't overwrite it. Otherwise we copy the
+     * early_secret across that we generated earlier.
+     */
+    if ((s->early_data_state != SSL_EARLY_DATA_WRITE_RETRY
+                && s->early_data_state != SSL_EARLY_DATA_FINISHED_WRITING)
+            || s->session->ext.max_early_data > 0
+            || s->psksession->ext.max_early_data == 0)
+        memcpy(s->early_secret, s->psksession->early_secret, EVP_MAX_MD_SIZE);
+
+    SSL_SESSION_free(s->session);
+    s->session = s->psksession;
+    s->psksession = NULL;
+    s->hit = 1;
+    /* Early data is only allowed if we used the first ticket */
+    if (identity != 0)
+        s->ext.early_data_ok = 0;
+#endif
+
+    return 1;
+}
Index: b/ssl/statem_ntls/ntls_extensions_cust.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_extensions_cust.c
@@ -0,0 +1,528 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+/* Custom extension utility functions */
+
+#include <openssl/ct.h>
+#include "ntls_ssl_local.h"
+#include "internal/cryptlib.h"
+#include "ntls_statem_local.h"
+
+typedef struct {
+    void *add_arg;
+    custom_ext_add_cb add_cb;
+    custom_ext_free_cb free_cb;
+} custom_ext_add_cb_wrap;
+
+typedef struct {
+    void *parse_arg;
+    custom_ext_parse_cb parse_cb;
+} custom_ext_parse_cb_wrap;
+
+/*
+ * Provide thin wrapper callbacks which convert new style arguments to old style
+ */
+static int custom_ext_add_ntls_old_cb_wrap(SSL *s, unsigned int ext_type,
+                                      unsigned int context,
+                                      const unsigned char **out,
+                                      size_t *outlen, X509 *x, size_t chainidx,
+                                      int *al, void *add_arg)
+{
+    custom_ext_add_cb_wrap *add_cb_wrap = (custom_ext_add_cb_wrap *)add_arg;
+
+    if (add_cb_wrap->add_cb == NULL)
+        return 1;
+
+    return add_cb_wrap->add_cb(s, ext_type, out, outlen, al,
+                               add_cb_wrap->add_arg);
+}
+
+static void custom_ext_free_old_cb_wrap(SSL *s, unsigned int ext_type,
+                                        unsigned int context,
+                                        const unsigned char *out, void *add_arg)
+{
+    custom_ext_add_cb_wrap *add_cb_wrap = (custom_ext_add_cb_wrap *)add_arg;
+
+    if (add_cb_wrap->free_cb == NULL)
+        return;
+
+    add_cb_wrap->free_cb(s, ext_type, out, add_cb_wrap->add_arg);
+}
+
+static int custom_ext_parse_ntls_old_cb_wrap(SSL *s, unsigned int ext_type,
+                                        unsigned int context,
+                                        const unsigned char *in,
+                                        size_t inlen, X509 *x, size_t chainidx,
+                                        int *al, void *parse_arg)
+{
+    custom_ext_parse_cb_wrap *parse_cb_wrap =
+        (custom_ext_parse_cb_wrap *)parse_arg;
+
+    if (parse_cb_wrap->parse_cb == NULL)
+        return 1;
+
+    return parse_cb_wrap->parse_cb(s, ext_type, in, inlen, al,
+                                   parse_cb_wrap->parse_arg);
+}
+
+/*
+ * Find a custom extension from the list. The |role| param is there to
+ * support the legacy API where custom extensions for client and server could
+ * be set independently on the same SSL_CTX. It is set to ENDPOINT_SERVER if we
+ * are trying to find a method relevant to the server, ENDPOINT_CLIENT for the
+ * client, or ENDPOINT_BOTH for either
+ */
+custom_ext_method *custom_ext_find_ntls(const custom_ext_methods *exts,
+                                   ENDPOINT role, unsigned int ext_type,
+                                   size_t *idx)
+{
+    size_t i;
+    custom_ext_method *meth = exts->meths;
+
+    for (i = 0; i < exts->meths_count; i++, meth++) {
+        if (ext_type == meth->ext_type
+                && (role == ENDPOINT_BOTH || role == meth->role
+                    || meth->role == ENDPOINT_BOTH)) {
+            if (idx != NULL)
+                *idx = i;
+            return meth;
+        }
+    }
+    return NULL;
+}
+
+/*
+ * Initialise custom extensions flags to indicate neither sent nor received.
+ */
+void custom_ext_init_ntls(custom_ext_methods *exts)
+{
+    size_t i;
+    custom_ext_method *meth = exts->meths;
+
+    for (i = 0; i < exts->meths_count; i++, meth++)
+        meth->ext_flags = 0;
+}
+
+/* Pass received custom extension data to the application for parsing. */
+int custom_ext_parse_ntls(SSL_CONNECTION *s, unsigned int context, unsigned int ext_type,
+                     const unsigned char *ext_data, size_t ext_size, X509 *x,
+                     size_t chainidx)
+{
+    int al;
+    custom_ext_methods *exts = &s->cert->custext;
+    custom_ext_method *meth;
+    ENDPOINT role = ENDPOINT_BOTH;
+
+    if ((context & (SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO)) != 0)
+        role = s->server ? ENDPOINT_SERVER : ENDPOINT_CLIENT;
+
+    meth = custom_ext_find_ntls(exts, role, ext_type, NULL);
+    /* If not found return success */
+    if (!meth)
+        return 1;
+
+    /* Check if extension is defined for our protocol. If not, skip */
+    if (!extension_is_relevant_ntls(s, meth->context, context))
+        return 1;
+
+    if ((context & (SSL_EXT_TLS1_2_SERVER_HELLO
+                    | SSL_EXT_TLS1_3_SERVER_HELLO
+                    | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS)) != 0) {
+        /*
+         * If it's ServerHello or EncryptedExtensions we can't have any
+         * extensions not sent in ClientHello.
+         */
+        if ((meth->ext_flags & SSL_EXT_FLAG_SENT) == 0) {
+            SSLfatal_ntls(s, TLS1_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+    }
+
+    /*
+     * Extensions received in the ClientHello or CertificateRequest are marked
+     * with the SSL_EXT_FLAG_RECEIVED. This is so we know to add the equivalent
+     * extensions in the response messages
+     */
+    if ((context & (SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST))
+            != 0)
+        meth->ext_flags |= SSL_EXT_FLAG_RECEIVED;
+
+    /* If no parse function set return success */
+    if (!meth->parse_cb)
+        return 1;
+
+    if (meth->parse_cb(SSL_CONNECTION_GET_USER_SSL(s), ext_type, context, ext_data, ext_size, x, chainidx,
+                       &al, meth->parse_arg) <= 0) {
+        SSLfatal_ntls(s, al, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    return 1;
+}
+
+/*
+ * Request custom extension data from the application and add to the return
+ * buffer.
+ */
+int custom_ext_add_ntls(SSL_CONNECTION *s, int context, WPACKET *pkt, X509 *x, size_t chainidx,
+                   int maxversion)
+{
+    custom_ext_methods *exts = &s->cert->custext;
+    custom_ext_method *meth;
+    size_t i;
+    int al;
+
+    for (i = 0; i < exts->meths_count; i++) {
+        const unsigned char *out = NULL;
+        size_t outlen = 0;
+
+        meth = exts->meths + i;
+
+        if (!should_add_extension_ntls(s, meth->context, context, maxversion))
+            continue;
+
+        if ((context & (SSL_EXT_TLS1_2_SERVER_HELLO
+                        | SSL_EXT_TLS1_3_SERVER_HELLO
+                        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS
+                        | SSL_EXT_TLS1_3_CERTIFICATE
+                        | SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST)) != 0) {
+            /* Only send extensions present in ClientHello/CertificateRequest */
+            if (!(meth->ext_flags & SSL_EXT_FLAG_RECEIVED))
+                continue;
+        }
+        /*
+         * We skip it if the callback is absent - except for a ClientHello where
+         * we add an empty extension.
+         */
+        if ((context & SSL_EXT_CLIENT_HELLO) == 0 && meth->add_cb == NULL)
+            continue;
+
+        if (meth->add_cb != NULL) {
+            int cb_retval = meth->add_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                         meth->ext_type, context, &out,
+                                         &outlen, x, chainidx, &al,
+                                         meth->add_arg);
+
+            if (cb_retval < 0) {
+                SSLfatal_ntls(s, al, SSL_R_CALLBACK_FAILED);
+                return 0;       /* error */
+            }
+            if (cb_retval == 0)
+                continue;       /* skip this extension */
+        }
+
+        if (!WPACKET_put_bytes_u16(pkt, meth->ext_type)
+                || !WPACKET_start_sub_packet_u16(pkt)
+                || (outlen > 0 && !WPACKET_memcpy(pkt, out, outlen))
+                || !WPACKET_close(pkt)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        if ((context & SSL_EXT_CLIENT_HELLO) != 0) {
+            /*
+             * We can't send duplicates: code logic should prevent this.
+             */
+            if (!ossl_assert((meth->ext_flags & SSL_EXT_FLAG_SENT) == 0)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+            /*
+             * Indicate extension has been sent: this is both a sanity check to
+             * ensure we don't send duplicate extensions and indicates that it
+             * is not an error if the extension is present in ServerHello.
+             */
+            meth->ext_flags |= SSL_EXT_FLAG_SENT;
+        }
+        if (meth->free_cb != NULL)
+            meth->free_cb(SSL_CONNECTION_GET_USER_SSL(s), meth->ext_type, context, out, meth->add_arg);
+    }
+    return 1;
+}
+
+/* Copy the flags from src to dst for any extensions that exist in both */
+int custom_exts_copy_flags_ntls(custom_ext_methods *dst,
+                           const custom_ext_methods *src)
+{
+    size_t i;
+    custom_ext_method *methsrc = src->meths;
+
+    for (i = 0; i < src->meths_count; i++, methsrc++) {
+        custom_ext_method *methdst = custom_ext_find_ntls(dst, methsrc->role,
+                                                     methsrc->ext_type, NULL);
+
+        if (methdst == NULL)
+            continue;
+
+        methdst->ext_flags = methsrc->ext_flags;
+    }
+
+    return 1;
+}
+
+/* Copy table of custom extensions */
+int custom_exts_copy_ntls(custom_ext_methods *dst, const custom_ext_methods *src)
+{
+    size_t i;
+    int err = 0;
+
+    if (src->meths_count > 0) {
+        dst->meths =
+            OPENSSL_memdup(src->meths,
+                           sizeof(*src->meths) * src->meths_count);
+        if (dst->meths == NULL)
+            return 0;
+        dst->meths_count = src->meths_count;
+
+        for (i = 0; i < src->meths_count; i++) {
+            custom_ext_method *methsrc = src->meths + i;
+            custom_ext_method *methdst = dst->meths + i;
+
+            if (methsrc->add_cb != custom_ext_add_ntls_old_cb_wrap)
+                continue;
+
+            /*
+             * We have found an old style API wrapper. We need to copy the
+             * arguments too.
+             */
+
+            if (err) {
+                methdst->add_arg = NULL;
+                methdst->parse_arg = NULL;
+                continue;
+            }
+
+            methdst->add_arg = OPENSSL_memdup(methsrc->add_arg,
+                                              sizeof(custom_ext_add_cb_wrap));
+            methdst->parse_arg = OPENSSL_memdup(methsrc->parse_arg,
+                                            sizeof(custom_ext_parse_cb_wrap));
+
+            if (methdst->add_arg == NULL || methdst->parse_arg == NULL)
+                err = 1;
+        }
+    }
+
+    if (err) {
+        custom_exts_free_ntls(dst);
+        return 0;
+    }
+
+    return 1;
+}
+
+void custom_exts_free_ntls(custom_ext_methods *exts)
+{
+    size_t i;
+    custom_ext_method *meth;
+
+    for (i = 0, meth = exts->meths; i < exts->meths_count; i++, meth++) {
+        if (meth->add_cb != custom_ext_add_ntls_old_cb_wrap)
+            continue;
+
+        /* Old style API wrapper. Need to free the arguments too */
+        OPENSSL_free(meth->add_arg);
+        OPENSSL_free(meth->parse_arg);
+    }
+    OPENSSL_free(exts->meths);
+}
+
+/* Return true if a client custom extension exists, false otherwise */
+int SSL_CTX_has_client_custom_ext_ntls(const SSL_CTX *ctx, unsigned int ext_type)
+{
+    return custom_ext_find_ntls(&ctx->cert->custext, ENDPOINT_CLIENT, ext_type,
+                           NULL) != NULL;
+}
+
+static int add_custom_ext_intern(SSL_CTX *ctx, ENDPOINT role,
+                                 unsigned int ext_type,
+                                 unsigned int context,
+                                 SSL_custom_ext_add_cb_ex add_cb,
+                                 SSL_custom_ext_free_cb_ex free_cb,
+                                 void *add_arg,
+                                 SSL_custom_ext_parse_cb_ex parse_cb,
+                                 void *parse_arg)
+{
+    custom_ext_methods *exts = &ctx->cert->custext;
+    custom_ext_method *meth, *tmp;
+
+    /*
+     * Check application error: if add_cb is not set free_cb will never be
+     * called.
+     */
+    if (add_cb == NULL && free_cb != NULL)
+        return 0;
+
+#ifndef OPENSSL_NO_CT
+    /*
+     * We don't want applications registering callbacks for SCT extensions
+     * whilst simultaneously using the built-in SCT validation features, as
+     * these two things may not play well together.
+     */
+    if (ext_type == TLSEXT_TYPE_signed_certificate_timestamp
+            && (context & SSL_EXT_CLIENT_HELLO) != 0
+            && SSL_CTX_ct_is_enabled(ctx))
+        return 0;
+#endif
+
+    /*
+     * Don't add if extension supported internally, but make exception
+     * for extension types that previously were not supported, but now are.
+     */
+    if (SSL_extension_supported_ntls(ext_type)
+            && ext_type != TLSEXT_TYPE_signed_certificate_timestamp)
+        return 0;
+
+    /* Extension type must fit in 16 bits */
+    if (ext_type > 0xffff)
+        return 0;
+    /* Search for duplicate */
+    if (custom_ext_find_ntls(exts, role, ext_type, NULL))
+        return 0;
+    tmp = OPENSSL_realloc(exts->meths,
+                          (exts->meths_count + 1) * sizeof(custom_ext_method));
+    if (tmp == NULL)
+        return 0;
+
+    exts->meths = tmp;
+    meth = exts->meths + exts->meths_count;
+    memset(meth, 0, sizeof(*meth));
+    meth->role = role;
+    meth->context = context;
+    meth->parse_cb = parse_cb;
+    meth->add_cb = add_cb;
+    meth->free_cb = free_cb;
+    meth->ext_type = ext_type;
+    meth->add_arg = add_arg;
+    meth->parse_arg = parse_arg;
+    exts->meths_count++;
+    return 1;
+}
+
+static int add_old_custom_ext(SSL_CTX *ctx, ENDPOINT role,
+                              unsigned int ext_type,
+                              unsigned int context,
+                              custom_ext_add_cb add_cb,
+                              custom_ext_free_cb free_cb,
+                              void *add_arg,
+                              custom_ext_parse_cb parse_cb, void *parse_arg)
+{
+    custom_ext_add_cb_wrap *add_cb_wrap
+        = OPENSSL_malloc(sizeof(*add_cb_wrap));
+    custom_ext_parse_cb_wrap *parse_cb_wrap
+        = OPENSSL_malloc(sizeof(*parse_cb_wrap));
+    int ret;
+
+    if (add_cb_wrap == NULL || parse_cb_wrap == NULL) {
+        OPENSSL_free(add_cb_wrap);
+        OPENSSL_free(parse_cb_wrap);
+        return 0;
+    }
+
+    add_cb_wrap->add_arg = add_arg;
+    add_cb_wrap->add_cb = add_cb;
+    add_cb_wrap->free_cb = free_cb;
+    parse_cb_wrap->parse_arg = parse_arg;
+    parse_cb_wrap->parse_cb = parse_cb;
+
+    ret = add_custom_ext_intern(ctx, role, ext_type,
+                                context,
+                                custom_ext_add_ntls_old_cb_wrap,
+                                custom_ext_free_old_cb_wrap,
+                                add_cb_wrap,
+                                custom_ext_parse_ntls_old_cb_wrap,
+                                parse_cb_wrap);
+
+    if (!ret) {
+        OPENSSL_free(add_cb_wrap);
+        OPENSSL_free(parse_cb_wrap);
+    }
+
+    return ret;
+}
+
+/* Application level functions to add the old custom extension callbacks */
+int SSL_CTX_add_client_custom_ext_ntls(SSL_CTX *ctx, unsigned int ext_type,
+                                  custom_ext_add_cb add_cb,
+                                  custom_ext_free_cb free_cb,
+                                  void *add_arg,
+                                  custom_ext_parse_cb parse_cb, void *parse_arg)
+{
+    return add_old_custom_ext(ctx, ENDPOINT_CLIENT, ext_type,
+                              SSL_EXT_TLS1_2_AND_BELOW_ONLY
+                              | SSL_EXT_CLIENT_HELLO
+                              | SSL_EXT_TLS1_2_SERVER_HELLO
+                              | SSL_EXT_IGNORE_ON_RESUMPTION,
+                              add_cb, free_cb, add_arg, parse_cb, parse_arg);
+}
+
+int SSL_CTX_add_server_custom_ext_ntls(SSL_CTX *ctx, unsigned int ext_type,
+                                  custom_ext_add_cb add_cb,
+                                  custom_ext_free_cb free_cb,
+                                  void *add_arg,
+                                  custom_ext_parse_cb parse_cb, void *parse_arg)
+{
+    return add_old_custom_ext(ctx, ENDPOINT_SERVER, ext_type,
+                              SSL_EXT_TLS1_2_AND_BELOW_ONLY
+                              | SSL_EXT_CLIENT_HELLO
+                              | SSL_EXT_TLS1_2_SERVER_HELLO
+                              | SSL_EXT_IGNORE_ON_RESUMPTION,
+                              add_cb, free_cb, add_arg, parse_cb, parse_arg);
+}
+
+int SSL_CTX_add_custom_ext_ntls(SSL_CTX *ctx, unsigned int ext_type,
+                           unsigned int context,
+                           SSL_custom_ext_add_cb_ex add_cb,
+                           SSL_custom_ext_free_cb_ex free_cb,
+                           void *add_arg,
+                           SSL_custom_ext_parse_cb_ex parse_cb, void *parse_arg)
+{
+    return add_custom_ext_intern(ctx, ENDPOINT_BOTH, ext_type, context, add_cb,
+                                 free_cb, add_arg, parse_cb, parse_arg);
+}
+
+int SSL_extension_supported_ntls(unsigned int ext_type)
+{
+    switch (ext_type) {
+        /* Internally supported extensions. */
+    case TLSEXT_TYPE_application_layer_protocol_negotiation:
+    case TLSEXT_TYPE_ec_point_formats:
+    case TLSEXT_TYPE_supported_groups:
+    case TLSEXT_TYPE_key_share:
+#ifndef OPENSSL_NO_NEXTPROTONEG
+    case TLSEXT_TYPE_next_proto_neg:
+#endif
+    case TLSEXT_TYPE_padding:
+    case TLSEXT_TYPE_renegotiate:
+    case TLSEXT_TYPE_max_fragment_length:
+    case TLSEXT_TYPE_server_name:
+    case TLSEXT_TYPE_session_ticket:
+    case TLSEXT_TYPE_signature_algorithms:
+
+#ifndef OPENSSL_NO_OCSP
+    case TLSEXT_TYPE_status_request:
+#endif
+#ifndef OPENSSL_NO_CT
+    case TLSEXT_TYPE_signed_certificate_timestamp:
+#endif
+#ifndef OPENSSL_NO_SRTP
+    case TLSEXT_TYPE_use_srtp:
+#endif
+    case TLSEXT_TYPE_encrypt_then_mac:
+    case TLSEXT_TYPE_supported_versions:
+    case TLSEXT_TYPE_extended_master_secret:
+    case TLSEXT_TYPE_psk_kex_modes:
+    case TLSEXT_TYPE_cookie:
+    case TLSEXT_TYPE_early_data:
+    case TLSEXT_TYPE_certificate_authorities:
+    case TLSEXT_TYPE_psk:
+    case TLSEXT_TYPE_post_handshake_auth:
+        return 1;
+    default:
+        return 0;
+    }
+}
Index: b/ssl/statem_ntls/ntls_extensions_srvr.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_extensions_srvr.c
@@ -0,0 +1,1645 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include <openssl/ocsp.h>
+#include "ntls_ssl_local.h"
+#include "ntls_statem_local.h"
+#include "internal/cryptlib.h"
+
+#define COOKIE_STATE_FORMAT_VERSION     0
+
+/*
+ * 2 bytes for packet length, 2 bytes for format version, 2 bytes for
+ * protocol version, 2 bytes for group id, 2 bytes for cipher id, 1 byte for
+ * key_share present flag, 4 bytes for timestamp, 2 bytes for the hashlen,
+ * EVP_MAX_MD_SIZE for transcript hash, 1 byte for app cookie length, app cookie
+ * length bytes, SHA256_DIGEST_LENGTH bytes for the HMAC of the whole thing.
+ */
+#define MAX_COOKIE_SIZE (2 + 2 + 2 + 2 + 2 + 1 + 4 + 2 + EVP_MAX_MD_SIZE + 1 \
+                         + SSL_COOKIE_LENGTH + SHA256_DIGEST_LENGTH)
+
+/*
+ * Message header + 2 bytes for protocol version + number of random bytes +
+ * + 1 byte for legacy session id length + number of bytes in legacy session id
+ * + 2 bytes for ciphersuite + 1 byte for legacy compression
+ * + 2 bytes for extension block length + 6 bytes for key_share extension
+ * + 4 bytes for cookie extension header + the number of bytes in the cookie
+ */
+#define MAX_HRR_SIZE    (SSL3_HM_HEADER_LENGTH + 2 + SSL3_RANDOM_SIZE + 1 \
+                         + SSL_MAX_SSL_SESSION_ID_LENGTH + 2 + 1 + 2 + 6 + 4 \
+                         + MAX_COOKIE_SIZE)
+
+
+/*-
+ * The servername extension is treated as follows:
+ *
+ * - Only the hostname type is supported with a maximum length of 255.
+ * - The servername is rejected if too long or if it contains zeros,
+ *   in which case an fatal alert is generated.
+ * - The servername field is maintained together with the session cache.
+ * - When a session is resumed, the servername call back invoked in order
+ *   to allow the application to position itself to the right context.
+ * - The servername is acknowledged if it is new for a session or when
+ *   it is identical to a previously used for the same session.
+ *   Applications can control the behaviour.  They can at any time
+ *   set a 'desirable' servername for a new SSL object. This can be the
+ *   case for example with HTTPS when a Host: header field is received and
+ *   a renegotiation is requested. In this case, a possible servername
+ *   presented in the new client hello is only acknowledged if it matches
+ *   the value of the Host: field.
+ * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
+ *   if they provide for changing an explicit servername context for the
+ *   session, i.e. when the session has been established with a servername
+ *   extension.
+ * - On session reconnect, the servername extension may be absent.
+ */
+int tls_parse_ctos_server_name_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                               X509 *x, size_t chainidx)
+{
+    unsigned int servname_type;
+    PACKET sni, hostname;
+
+    if (!PACKET_as_length_prefixed_2(pkt, &sni)
+        /* ServerNameList must be at least 1 byte long. */
+        || PACKET_remaining(&sni) == 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /*
+     * Although the intent was for server_name to be extensible, RFC 4366
+     * was not clear about it; and so OpenSSL among other implementations,
+     * always and only allows a 'host_name' name types.
+     * RFC 6066 corrected the mistake but adding new name types
+     * is nevertheless no longer feasible, so act as if no other
+     * SNI types can exist, to simplify parsing.
+     *
+     * Also note that the RFC permits only one SNI value per type,
+     * i.e., we can only have a single hostname.
+     */
+    if (!PACKET_get_1(&sni, &servname_type)
+        || servname_type != TLSEXT_NAMETYPE_host_name
+        || !PACKET_as_length_prefixed_2(&sni, &hostname)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /*
+     * In TLSv1.2 and below the SNI is associated with the session. In TLSv1.3
+     * we always use the SNI value from the handshake.
+     */
+    if (!s->hit || SSL_CONNECTION_IS_TLS13(s)) {
+        if (PACKET_remaining(&hostname) > TLSEXT_MAXLEN_host_name) {
+            SSLfatal_ntls(s, SSL_AD_UNRECOGNIZED_NAME, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+        if (PACKET_contains_zero_byte(&hostname)) {
+            SSLfatal_ntls(s, SSL_AD_UNRECOGNIZED_NAME, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+        /*
+         * Store the requested SNI in the SSL as temporary storage.
+         * If we accept it, it will get stored in the SSL_SESSION as well.
+         */
+        OPENSSL_free(s->ext.hostname);
+        s->ext.hostname = NULL;
+        if (!PACKET_strndup(&hostname, &s->ext.hostname)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+
+        s->servername_done = 1;
+    } else {
+        /*
+         * In TLSv1.2 and below we should check if the SNI is consistent between
+         * the initial handshake and the resumption. In TLSv1.3 SNI is not
+         * associated with the session.
+         */
+        s->servername_done = (s->session->ext.hostname != NULL)
+            && PACKET_equal(&hostname, s->session->ext.hostname,
+                            strlen(s->session->ext.hostname));
+    }
+
+    return 1;
+}
+
+int tls_parse_ctos_maxfragmentlen_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    unsigned int value;
+
+    if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /* Received |value| should be a valid max-fragment-length code. */
+    if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                 SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);
+        return 0;
+    }
+
+    /*
+     * RFC 6066:  The negotiated length applies for the duration of the session
+     * including session resumptions.
+     * We should receive the same code as in resumed session !
+     */
+    if (s->hit && s->session->ext.max_fragment_len_mode != value) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                 SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);
+        return 0;
+    }
+
+    /*
+     * Store it in session, so it'll become binding for us
+     * and we'll include it in a next Server Hello.
+     */
+    s->session->ext.max_fragment_len_mode = value;
+    return 1;
+}
+
+int tls_parse_ctos_ec_pt_formats_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx)
+{
+    /* Ignore ec_point_formats */
+    return 1;
+}
+
+int tls_parse_ctos_session_ticket_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    if (s->ext.session_ticket_cb &&
+            !s->ext.session_ticket_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                  PACKET_data(pkt),
+                                  PACKET_remaining(pkt),
+                                  s->ext.session_ticket_cb_arg)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+int tls_parse_ctos_sig_algs_cert_ntls(SSL_CONNECTION *s, PACKET *pkt,
+                                      ossl_unused unsigned int context,
+                                      ossl_unused X509 *x,
+									  ossl_unused size_t chainidx)
+{
+    /* Ignore signature_algorithms_cert */
+    return 1;
+}
+
+int tls_parse_ctos_sig_algs_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                            size_t chainidx)
+{
+    /* Ignore signature_algorithms */
+    return 1;
+}
+
+#ifndef OPENSSL_NO_OCSP
+int tls_parse_ctos_status_request_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    PACKET responder_id_list, exts;
+
+    /* We ignore this in a resumption handshake */
+    if (s->hit)
+        return 1;
+
+    /* Not defined if we get one of these in a client Certificate */
+    if (x != NULL)
+        return 1;
+
+    if (!PACKET_get_1(pkt, (unsigned int *)&s->ext.status_type)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    if (s->ext.status_type != TLSEXT_STATUSTYPE_ocsp) {
+        /*
+         * We don't know what to do with any other type so ignore it.
+         */
+        s->ext.status_type = TLSEXT_STATUSTYPE_nothing;
+        return 1;
+    }
+
+    if (!PACKET_get_length_prefixed_2 (pkt, &responder_id_list)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    /*
+     * We remove any OCSP_RESPIDs from a previous handshake
+     * to prevent unbounded memory growth - CVE-2016-6304
+     */
+    sk_OCSP_RESPID_pop_free(s->ext.ocsp.ids, OCSP_RESPID_free);
+    if (PACKET_remaining(&responder_id_list) > 0) {
+        s->ext.ocsp.ids = sk_OCSP_RESPID_new_null();
+        if (s->ext.ocsp.ids == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    } else {
+        s->ext.ocsp.ids = NULL;
+    }
+
+    while (PACKET_remaining(&responder_id_list) > 0) {
+        OCSP_RESPID *id;
+        PACKET responder_id;
+        const unsigned char *id_data;
+
+        if (!PACKET_get_length_prefixed_2(&responder_id_list, &responder_id)
+                || PACKET_remaining(&responder_id) == 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+        id_data = PACKET_data(&responder_id);
+        id = d2i_OCSP_RESPID(NULL, &id_data,
+                             (int)PACKET_remaining(&responder_id));
+        if (id == NULL) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+        if (id_data != PACKET_end(&responder_id)) {
+            OCSP_RESPID_free(id);
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+
+            return 0;
+        }
+
+        if (!sk_OCSP_RESPID_push(s->ext.ocsp.ids, id)) {
+            OCSP_RESPID_free(id);
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+
+            return 0;
+        }
+    }
+
+    /* Read in request_extensions */
+    if (!PACKET_as_length_prefixed_2(pkt, &exts)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    if (PACKET_remaining(&exts) > 0) {
+        const unsigned char *ext_data = PACKET_data(&exts);
+
+        sk_X509_EXTENSION_pop_free(s->ext.ocsp.exts,
+                                   X509_EXTENSION_free);
+        s->ext.ocsp.exts =
+            d2i_X509_EXTENSIONS(NULL, &ext_data, (int)PACKET_remaining(&exts));
+        if (s->ext.ocsp.exts == NULL || ext_data != PACKET_end(&exts)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+    }
+
+    return 1;
+}
+#endif
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+int tls_parse_ctos_npn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    /*
+     * We shouldn't accept this extension on a
+     * renegotiation.
+     */
+    if (SSL_IS_FIRST_HANDSHAKE(s))
+        s->s3.npn_seen = 1;
+
+    return 1;
+}
+#endif
+
+/*
+ * Save the ALPN extension in a ClientHello.|pkt| holds the contents of the ALPN
+ * extension, not including type and length. Returns: 1 on success, 0 on error.
+ */
+int tls_parse_ctos_alpn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                        size_t chainidx)
+{
+    PACKET protocol_list, save_protocol_list, protocol;
+
+    if (!SSL_IS_FIRST_HANDSHAKE(s))
+        return 1;
+
+    if (!PACKET_as_length_prefixed_2(pkt, &protocol_list)
+        || PACKET_remaining(&protocol_list) < 2) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    save_protocol_list = protocol_list;
+    do {
+        /* Protocol names can't be empty. */
+        if (!PACKET_get_length_prefixed_1(&protocol_list, &protocol)
+                || PACKET_remaining(&protocol) == 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+    } while (PACKET_remaining(&protocol_list) != 0);
+
+    OPENSSL_free(s->s3.alpn_proposed);
+    s->s3.alpn_proposed = NULL;
+    s->s3.alpn_proposed_len = 0;
+    if (!PACKET_memdup(&save_protocol_list,
+                       &s->s3.alpn_proposed, &s->s3.alpn_proposed_len)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_SRTP
+int tls_parse_ctos_use_srtp_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                            size_t chainidx)
+{
+    STACK_OF(SRTP_PROTECTION_PROFILE) *srvr;
+    unsigned int ct, mki_len, id;
+    int i, srtp_pref;
+    PACKET subpkt;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    /* Ignore this if we have no SRTP profiles */
+    if (SSL_get_srtp_profiles(ssl) == NULL)
+        return 1;
+
+    /* Pull off the length of the cipher suite list  and check it is even */
+    if (!PACKET_get_net_2(pkt, &ct) || (ct & 1) != 0
+            || !PACKET_get_sub_packet(pkt, &subpkt, ct)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR,
+		              SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);
+        return 0;
+    }
+
+    srvr = SSL_get_srtp_profiles(ssl);
+    s->srtp_profile = NULL;
+    /* Search all profiles for a match initially */
+    srtp_pref = sk_SRTP_PROTECTION_PROFILE_num(srvr);
+
+    while (PACKET_remaining(&subpkt)) {
+        if (!PACKET_get_net_2(&subpkt, &id)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR,
+                          SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);
+            return 0;
+        }
+
+        /*
+         * Only look for match in profiles of higher preference than
+         * current match.
+         * If no profiles have been have been configured then this
+         * does nothing.
+         */
+        for (i = 0; i < srtp_pref; i++) {
+            SRTP_PROTECTION_PROFILE *sprof =
+                sk_SRTP_PROTECTION_PROFILE_value(srvr, i);
+
+            if (sprof->id == id) {
+                s->srtp_profile = sprof;
+                srtp_pref = i;
+                break;
+            }
+        }
+    }
+
+    /* Now extract the MKI value as a sanity check, but discard it for now */
+    if (!PACKET_get_1(pkt, &mki_len)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR,
+                      SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);
+        return 0;
+    }
+
+    if (!PACKET_forward(pkt, mki_len)
+        || PACKET_remaining(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_SRTP_MKI_VALUE);
+        return 0;
+    }
+
+    return 1;
+}
+#endif
+
+int tls_parse_ctos_etm_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    /* Ignore encrypt-then-MAC */
+    return 1;
+}
+
+/*
+ * Process a psk_kex_modes extension received in the ClientHello. |pkt| contains
+ * the raw PACKET data for the extension. Returns 1 on success or 0 on failure.
+ */
+int tls_parse_ctos_psk_kex_modes_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    PACKET psk_kex_modes;
+    unsigned int mode;
+
+    if (!PACKET_as_length_prefixed_1(pkt, &psk_kex_modes)
+            || PACKET_remaining(&psk_kex_modes) == 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    while (PACKET_get_1(&psk_kex_modes, &mode)) {
+        if (mode == TLSEXT_KEX_MODE_KE_DHE)
+            s->ext.psk_kex_mode |= TLSEXT_KEX_MODE_FLAG_KE_DHE;
+        else if (mode == TLSEXT_KEX_MODE_KE
+                && (s->options & SSL_OP_ALLOW_NO_DHE_KEX) != 0)
+            s->ext.psk_kex_mode |= TLSEXT_KEX_MODE_FLAG_KE;
+    }
+#endif
+
+    return 1;
+}
+
+/*
+ * Process a key_share extension received in the ClientHello. |pkt| contains
+ * the raw PACKET data for the extension. Returns 1 on success or 0 on failure.
+ */
+int tls_parse_ctos_key_share_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                             size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    unsigned int group_id;
+    PACKET key_share_list, encoded_pt;
+    const uint16_t *clntgroups, *srvrgroups;
+    size_t clnt_num_groups, srvr_num_groups;
+    int found = 0;
+
+    if (s->hit && (s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE_DHE) == 0)
+        return 1;
+
+    /* Sanity check */
+    if (s->s3.peer_tmp != NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (!PACKET_as_length_prefixed_2(pkt, &key_share_list)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    /* Get our list of supported groups */
+    tls1_get_supported_groups(s, &srvrgroups, &srvr_num_groups);
+    /* Get the clients list of supported groups. */
+    tls1_get_peer_groups(s, &clntgroups, &clnt_num_groups);
+    if (clnt_num_groups == 0) {
+        /*
+         * This can only happen if the supported_groups extension was not sent,
+         * because we verify that the length is non-zero when we process that
+         * extension.
+         */
+        SSLfatal_ntls(s, SSL_AD_MISSING_EXTENSION,
+		              SSL_R_MISSING_SUPPORTED_GROUPS_EXTENSION);
+        return 0;
+    }
+
+    if (s->s3.group_id != 0 && PACKET_remaining(&key_share_list) == 0) {
+        /*
+         * If we set a group_id already, then we must have sent an HRR
+         * requesting a new key_share. If we haven't got one then that is an
+         * error
+         */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+        return 0;
+    }
+
+    while (PACKET_remaining(&key_share_list) > 0) {
+        if (!PACKET_get_net_2(&key_share_list, &group_id)
+                || !PACKET_get_length_prefixed_2(&key_share_list, &encoded_pt)
+                || PACKET_remaining(&encoded_pt) == 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            return 0;
+        }
+
+        /*
+         * If we already found a suitable key_share we loop through the
+         * rest to verify the structure, but don't process them.
+         */
+        if (found)
+            continue;
+
+        /*
+         * If we sent an HRR then the key_share sent back MUST be for the group
+         * we requested, and must be the only key_share sent.
+         */
+        if (s->s3.group_id != 0
+                && (group_id != s->s3.group_id
+                    || PACKET_remaining(&key_share_list) != 0)) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+            return 0;
+        }
+
+        /* Check if this share is in supported_groups sent from client */
+        if (!check_in_list_ntls(s, group_id, clntgroups, clnt_num_groups, 0)) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);
+            return 0;
+        }
+
+        /* Check if this share is for a group we can use */
+        if (!check_in_list_ntls(s, group_id, srvrgroups, srvr_num_groups, 1)) {
+            /* Share not suitable */
+            continue;
+        }
+
+        if ((s->s3.peer_tmp = ssl_generate_param_group(s, group_id)) == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                          SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
+            return 0;
+        }
+
+        s->s3.group_id = group_id;
+        /* Cache the selected group ID in the SSL_SESSION */
+        s->session->kex_group = group_id;
+
+        if (tls13_set_encoded_pub_key(s->s3.peer_tmp,
+                                      PACKET_data(&encoded_pt),
+                                      PACKET_remaining(&encoded_pt)) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_ECPOINT);
+            return 0;
+        }
+
+        found = 1;
+    }
+#endif
+
+    return 1;
+}
+
+int tls_parse_ctos_cookie_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                          size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    unsigned int format, version, key_share, group_id;
+    EVP_MD_CTX *hctx;
+    EVP_PKEY *pkey;
+    PACKET cookie, raw, chhash, appcookie;
+    WPACKET hrrpkt;
+    const unsigned char *data, *mdin, *ciphdata;
+    unsigned char hmac[SHA256_DIGEST_LENGTH];
+    unsigned char hrr[MAX_HRR_SIZE];
+    size_t rawlen, hmaclen, hrrlen, ciphlen;
+    unsigned long tm, now;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /* Ignore any cookie if we're not set up to verify it */
+    if (sctx->verify_stateless_cookie_cb == NULL
+            || (s->s3.flags & TLS1_FLAGS_STATELESS) == 0)
+        return 1;
+
+    if (!PACKET_as_length_prefixed_2(pkt, &cookie)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    raw = cookie;
+    data = PACKET_data(&raw);
+    rawlen = PACKET_remaining(&raw);
+    if (rawlen < SHA256_DIGEST_LENGTH
+            || !PACKET_forward(&raw, rawlen - SHA256_DIGEST_LENGTH)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+    mdin = PACKET_data(&raw);
+
+    /* Verify the HMAC of the cookie */
+    hctx = EVP_MD_CTX_create();
+    pkey = EVP_PKEY_new_raw_private_key_ex(sctx->libctx, "HMAC",
+                                           sctx->propq,
+                                           s->session_ctx->ext.cookie_hmac_key,
+                                           sizeof(s->session_ctx->ext.cookie_hmac_key));
+    if (hctx == NULL || pkey == NULL) {
+        EVP_MD_CTX_free(hctx);
+        EVP_PKEY_free(pkey);
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    hmaclen = SHA256_DIGEST_LENGTH;
+    if (EVP_DigestSignInit_ex(hctx, NULL, "SHA2-256", sctx->libctx,
+                              sctx->propq, pkey, NULL) <= 0
+            || EVP_DigestSign(hctx, hmac, &hmaclen, data,
+                              rawlen - SHA256_DIGEST_LENGTH) <= 0
+            || hmaclen != SHA256_DIGEST_LENGTH) {
+        EVP_MD_CTX_free(hctx);
+        EVP_PKEY_free(pkey);
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    EVP_MD_CTX_free(hctx);
+    EVP_PKEY_free(pkey);
+
+    if (CRYPTO_memcmp(hmac, mdin, SHA256_DIGEST_LENGTH) != 0) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_COOKIE_MISMATCH);
+        return 0;
+    }
+
+    if (!PACKET_get_net_2(&cookie, &format)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+    /* Check the cookie format is something we recognise. Ignore it if not */
+    if (format != COOKIE_STATE_FORMAT_VERSION)
+        return 1;
+
+    /*
+     * The rest of these checks really shouldn't fail since we have verified the
+     * HMAC above.
+     */
+
+    /* Check the version number is sane */
+    if (!PACKET_get_net_2(&cookie, &version)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+    if (version != TLS1_3_VERSION) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                      SSL_R_BAD_PROTOCOL_VERSION_NUMBER);
+        return 0;
+    }
+
+    if (!PACKET_get_net_2(&cookie, &group_id)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    ciphdata = PACKET_data(&cookie);
+    if (!PACKET_forward(&cookie, 2)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+    if (group_id != s->s3.group_id
+            || s->s3.tmp.new_cipher
+               != ssl_get_cipher_by_char(s, ciphdata, 0)) {
+        /*
+         * We chose a different cipher or group id this time around to what is
+         * in the cookie. Something must have changed.
+         */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_CIPHER);
+        return 0;
+    }
+
+    if (!PACKET_get_1(&cookie, &key_share)
+            || !PACKET_get_net_4(&cookie, &tm)
+            || !PACKET_get_length_prefixed_2(&cookie, &chhash)
+            || !PACKET_get_length_prefixed_1(&cookie, &appcookie)
+            || PACKET_remaining(&cookie) != SHA256_DIGEST_LENGTH) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    /* We tolerate a cookie age of up to 10 minutes (= 60 * 10 seconds) */
+    now = (unsigned long)time(NULL);
+    if (tm > now || (now - tm) > 600) {
+        /* Cookie is stale. Ignore it */
+        return 1;
+    }
+
+    /* Verify the app cookie */
+    if (sctx->verify_stateless_cookie_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                     PACKET_data(&appcookie),
+                                     PACKET_remaining(&appcookie)) == 0) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_COOKIE_MISMATCH);
+        return 0;
+    }
+
+    /*
+     * Reconstruct the HRR that we would have sent in response to the original
+     * ClientHello so we can add it to the transcript hash.
+     * Note: This won't work with custom HRR extensions
+     */
+    if (!WPACKET_init_static_len(&hrrpkt, hrr, sizeof(hrr), 0)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    if (!WPACKET_put_bytes_u8(&hrrpkt, SSL3_MT_SERVER_HELLO)
+            || !WPACKET_start_sub_packet_u24(&hrrpkt)
+            || !WPACKET_put_bytes_u16(&hrrpkt, TLS1_2_VERSION)
+            || !WPACKET_memcpy(&hrrpkt, hrrrandom_ntls, SSL3_RANDOM_SIZE)
+            || !WPACKET_sub_memcpy_u8(&hrrpkt, s->tmp_session_id,
+                                      s->tmp_session_id_len)
+            || !ssl->method->put_cipher_by_char(s->s3.tmp.new_cipher, &hrrpkt,
+                                              &ciphlen)
+            || !WPACKET_put_bytes_u8(&hrrpkt, 0)
+            || !WPACKET_start_sub_packet_u16(&hrrpkt)) {
+        WPACKET_cleanup(&hrrpkt);
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    if (!WPACKET_put_bytes_u16(&hrrpkt, TLSEXT_TYPE_supported_versions)
+            || !WPACKET_start_sub_packet_u16(&hrrpkt)
+            || !WPACKET_put_bytes_u16(&hrrpkt, s->version)
+            || !WPACKET_close(&hrrpkt)) {
+        WPACKET_cleanup(&hrrpkt);
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    if (key_share) {
+        if (!WPACKET_put_bytes_u16(&hrrpkt, TLSEXT_TYPE_key_share)
+                || !WPACKET_start_sub_packet_u16(&hrrpkt)
+                || !WPACKET_put_bytes_u16(&hrrpkt, s->s3.group_id)
+                || !WPACKET_close(&hrrpkt)) {
+            WPACKET_cleanup(&hrrpkt);
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+    }
+    if (!WPACKET_put_bytes_u16(&hrrpkt, TLSEXT_TYPE_cookie)
+            || !WPACKET_start_sub_packet_u16(&hrrpkt)
+            || !WPACKET_sub_memcpy_u16(&hrrpkt, data, rawlen)
+            || !WPACKET_close(&hrrpkt) /* cookie extension */
+            || !WPACKET_close(&hrrpkt) /* extension block */
+            || !WPACKET_close(&hrrpkt) /* message */
+            || !WPACKET_get_total_written(&hrrpkt, &hrrlen)
+            || !WPACKET_finish(&hrrpkt)) {
+        WPACKET_cleanup(&hrrpkt);
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* Reconstruct the transcript hash */
+    if (!create_synthetic_message_hash_ntls(s, PACKET_data(&chhash),
+                                       PACKET_remaining(&chhash), hrr,
+                                       hrrlen)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    /* Act as if this ClientHello came after a HelloRetryRequest */
+    s->hello_retry_request = 1;
+
+    s->ext.cookieok = 1;
+#endif
+
+    return 1;
+}
+
+int tls_parse_ctos_supported_groups_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                    X509 *x, size_t chainidx)
+{
+    /* Ignore supported_groups */
+    return 1;
+}
+
+int tls_parse_ctos_ems_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    /* Ignore extended_master_secret */
+    return 1;
+}
+
+
+int tls_parse_ctos_early_data_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                              X509 *x, size_t chainidx)
+{
+    if (PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    if (s->hello_retry_request != SSL_HRR_NONE) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    return 1;
+}
+
+static SSL_TICKET_STATUS tls_get_stateful_ticket(SSL_CONNECTION *s, PACKET *tick,
+                                                 SSL_SESSION **sess)
+{
+    SSL_SESSION *tmpsess = NULL;
+
+    s->ext.ticket_expected = 1;
+
+    switch (PACKET_remaining(tick)) {
+        case 0:
+            return SSL_TICKET_EMPTY;
+
+        case SSL_MAX_SSL_SESSION_ID_LENGTH:
+            break;
+
+        default:
+            return SSL_TICKET_NO_DECRYPT;
+    }
+
+    tmpsess = lookup_sess_in_cache(s, PACKET_data(tick),
+                                   SSL_MAX_SSL_SESSION_ID_LENGTH);
+
+    if (tmpsess == NULL)
+        return SSL_TICKET_NO_DECRYPT;
+
+    *sess = tmpsess;
+    return SSL_TICKET_SUCCESS;
+}
+
+int tls_parse_ctos_psk_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx)
+{
+    PACKET identities, binders, binder;
+    size_t binderoffset, hashsize;
+    SSL_SESSION *sess = NULL;
+    unsigned int id, i, ext = 0;
+    const EVP_MD *md = NULL;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+    /*
+     * If we have no PSK kex mode that we recognise then we can't resume so
+     * ignore this extension
+     */
+    if ((s->ext.psk_kex_mode
+            & (TLSEXT_KEX_MODE_FLAG_KE | TLSEXT_KEX_MODE_FLAG_KE_DHE)) == 0)
+        return 1;
+
+    if (!PACKET_get_length_prefixed_2(pkt, &identities)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        return 0;
+    }
+
+    s->ext.ticket_expected = 0;
+    for (id = 0; PACKET_remaining(&identities) != 0; id++) {
+        PACKET identity;
+        unsigned long ticket_agel;
+        size_t idlen;
+
+        if (!PACKET_get_length_prefixed_2(&identities, &identity)
+                || !PACKET_get_net_4(&identities, &ticket_agel)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+        idlen = PACKET_remaining(&identity);
+        if (s->psk_find_session_cb != NULL
+                && !s->psk_find_session_cb(ussl, PACKET_data(&identity), idlen,
+                                           &sess)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_EXTENSION);
+            return 0;
+        }
+
+#ifndef OPENSSL_NO_PSK
+        if(sess == NULL
+                && s->psk_server_callback != NULL
+                && idlen <= PSK_MAX_IDENTITY_LEN) {
+            char *pskid = NULL;
+            unsigned char pskdata[PSK_MAX_PSK_LEN];
+            unsigned int pskdatalen;
+
+            if (!PACKET_strndup(&identity, &pskid)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+            pskdatalen = s->psk_server_callback(ussl, pskid, pskdata,
+                                                sizeof(pskdata));
+            OPENSSL_free(pskid);
+            if (pskdatalen > PSK_MAX_PSK_LEN) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            } else if (pskdatalen > 0) {
+                const SSL_CIPHER *cipher;
+                const unsigned char tls13_aes128gcmsha256_id[] = { 0x13, 0x01 };
+
+                /*
+                 * We found a PSK using an old style callback. We don't know
+                 * the digest so we default to SHA256 as per the TLSv1.3 spec
+                 */
+                cipher = SSL_CIPHER_find(SSL_CONNECTION_GET_SSL(s),
+                                         tls13_aes128gcmsha256_id);
+                if (cipher == NULL) {
+                    OPENSSL_cleanse(pskdata, pskdatalen);
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    return 0;
+                }
+
+                sess = SSL_SESSION_new();
+                if (sess == NULL
+                        || !SSL_SESSION_set1_master_key(sess, pskdata,
+                                                        pskdatalen)
+                        || !SSL_SESSION_set_cipher(sess, cipher)
+                        || !SSL_SESSION_set_protocol_version(sess,
+                                                             TLS1_3_VERSION)) {
+                    OPENSSL_cleanse(pskdata, pskdatalen);
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+                OPENSSL_cleanse(pskdata, pskdatalen);
+            }
+        }
+#endif /* OPENSSL_NO_PSK */
+
+        if (sess != NULL) {
+            /* We found a PSK */
+            SSL_SESSION *sesstmp = ssl_session_dup(sess, 0);
+
+            if (sesstmp == NULL) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+            SSL_SESSION_free(sess);
+            sess = sesstmp;
+
+            /*
+             * We've just been told to use this session for this context so
+             * make sure the sid_ctx matches up.
+             */
+            memcpy(sess->sid_ctx, s->sid_ctx, s->sid_ctx_length);
+            sess->sid_ctx_length = s->sid_ctx_length;
+            ext = 1;
+            if (id == 0)
+                s->ext.early_data_ok = 1;
+            s->ext.ticket_expected = 1;
+        } else {
+            OSSL_TIME t, age, expire;
+            int ret;
+
+            /*
+             * If we are using anti-replay protection then we behave as if
+             * SSL_OP_NO_TICKET is set - we are caching tickets anyway so there
+             * is no point in using full stateless tickets.
+             */
+            if ((s->options & SSL_OP_NO_TICKET) != 0
+                    || (s->max_early_data > 0
+                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0))
+                ret = tls_get_stateful_ticket(s, &identity, &sess);
+            else
+                ret = tls_decrypt_ticket(s, PACKET_data(&identity),
+                                         PACKET_remaining(&identity), NULL, 0,
+                                         &sess);
+
+            if (ret == SSL_TICKET_EMPTY) {
+                SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+                return 0;
+            }
+
+            if (ret == SSL_TICKET_FATAL_ERR_MALLOC
+                    || ret == SSL_TICKET_FATAL_ERR_OTHER) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+            if (ret == SSL_TICKET_NONE || ret == SSL_TICKET_NO_DECRYPT)
+                continue;
+
+            /* Check for replay */
+            if (s->max_early_data > 0
+                    && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0
+                    && !SSL_CTX_remove_session(s->session_ctx, sess)) {
+                SSL_SESSION_free(sess);
+                sess = NULL;
+                continue;
+            }
+
+            age = ossl_time_subtract(ossl_ms2time(ticket_agel),
+                                     ossl_ms2time(sess->ext.tick_age_add));
+            t = ossl_time_subtract(ossl_time_now(), sess->time);
+
+            /*
+             * For simplicity we do our age calculations in seconds. If the
+             * client does it in ms then it could appear that their ticket age
+             * is longer than ours (our ticket age calculation should always be
+             * slightly longer than the client's due to the network latency).
+             * Therefore we add 1000ms to our age calculation to adjust for
+             * rounding errors.
+             */
+            expire = ossl_time_add(t, ossl_ms2time(1000));
+            if (id == 0
+                     && ossl_time_compare(sess->timeout, t) >= 0
+                     && ossl_time_compare(age, expire) <= 0
+                     && ossl_time_compare(ossl_time_add(age, TICKET_AGE_ALLOWANCE),
+                                         expire) >= 0) {
+                /*
+                 * Ticket age is within tolerance and not expired. We allow it
+                 * for early data
+                 */
+                s->ext.early_data_ok = 1;
+            }
+        }
+
+        md = ssl_md(sctx, sess->cipher->algorithm2);
+        if (!EVP_MD_is_a(md,
+                EVP_MD_get0_name(ssl_md(sctx,
+                                        s->s3.tmp.new_cipher->algorithm2)))) {
+            /* The ciphersuite is not compatible with this session. */
+            SSL_SESSION_free(sess);
+            sess = NULL;
+            s->ext.early_data_ok = 0;
+            s->ext.ticket_expected = 0;
+            continue;
+        }
+        break;
+    }
+
+    if (sess == NULL)
+        return 1;
+
+    binderoffset = PACKET_data(pkt) - (const unsigned char *)s->init_buf->data;
+    hashsize = EVP_MD_get_size(md);
+
+    if (!PACKET_get_length_prefixed_2(pkt, &binders)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        goto err;
+    }
+
+    for (i = 0; i <= id; i++) {
+        if (!PACKET_get_length_prefixed_1(&binders, &binder)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+            goto err;
+        }
+    }
+
+    if (PACKET_remaining(&binder) != hashsize) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
+        goto err;
+    }
+    if (tls_psk_do_binder_ntls(s, md, (const unsigned char *)s->init_buf->data,
+                          binderoffset, PACKET_data(&binder), NULL, sess, 0,
+                          ext) != 1) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    s->ext.tick_identity = id;
+
+    SSL_SESSION_free(s->session);
+    s->session = sess;
+    return 1;
+err:
+    SSL_SESSION_free(sess);
+    return 0;
+}
+
+int tls_parse_ctos_post_handshake_auth_ntls(SSL_CONNECTION *s, PACKET *pkt,
+                                            ossl_unused unsigned int context,
+                                            ossl_unused X509 *x,
+                                            ossl_unused size_t chainidx)
+{
+    if (PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR,
+                      SSL_R_POST_HANDSHAKE_AUTH_ENCODING_ERR);
+        return 0;
+    }
+
+    s->post_handshake_auth = SSL_PHA_EXT_RECEIVED;
+
+    return 1;
+}
+
+EXT_RETURN tls_construct_stoc_server_name_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                          unsigned int context, X509 *x,
+                                          size_t chainidx)
+{
+    if (s->servername_done != 1)
+        return EXT_RETURN_NOT_SENT;
+
+    /*
+     * Prior to TLSv1.3 we ignore any SNI in the current handshake if resuming.
+     * We just use the servername from the initial handshake.
+     */
+    if (s->hit && !SSL_CONNECTION_IS_TLS13(s))
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)
+            || !WPACKET_put_bytes_u16(pkt, 0)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+/* Add/include the server's max fragment len extension into ServerHello */
+EXT_RETURN tls_construct_stoc_maxfragmentlen_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    if (!USE_MAX_FRAGMENT_LENGTH_EXT(s->session))
+        return EXT_RETURN_NOT_SENT;
+
+    /*-
+     * 4 bytes for this extension type and extension length
+     * 1 byte for the Max Fragment Length code value.
+     */
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_max_fragment_length)
+        || !WPACKET_start_sub_packet_u16(pkt)
+        || !WPACKET_put_bytes_u8(pkt, s->session->ext.max_fragment_len_mode)
+        || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_ec_pt_formats_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx)
+{
+    /* No ec_point_formats */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_supported_groups_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                               unsigned int context, X509 *x,
+                                               size_t chainidx)
+{
+    /* No supported_groups */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_session_ticket_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    if (!s->ext.ticket_expected || !tls_use_ticket(s)) {
+        s->ext.ticket_expected = 0;
+        return EXT_RETURN_NOT_SENT;
+    }
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_session_ticket)
+            || !WPACKET_put_bytes_u16(pkt, 0)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+#ifndef OPENSSL_NO_OCSP
+EXT_RETURN tls_construct_stoc_status_request_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    /* We don't currently support this extension inside a CertificateRequest */
+    if (context == SSL_EXT_TLS1_3_CERTIFICATE_REQUEST)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!s->ext.status_expected)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request)
+            || !WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    /*
+     * In TLSv1.3 we include the certificate status itself. In <= TLSv1.2 we
+     * send back an empty extension, with the certificate status appearing as a
+     * separate message
+     */
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+EXT_RETURN tls_construct_stoc_next_proto_neg_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx)
+{
+    const unsigned char *npa;
+    unsigned int npalen;
+    int ret;
+    int npn_seen = s->s3.npn_seen;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    s->s3.npn_seen = 0;
+    if (!npn_seen || sctx->ext.npn_advertised_cb == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    ret = sctx->ext.npn_advertised_cb(SSL_CONNECTION_GET_USER_SSL(s), &npa, &npalen,
+                                        sctx->ext.npn_advertised_cb_arg);
+    if (ret == SSL_TLSEXT_ERR_OK) {
+        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_next_proto_neg)
+                || !WPACKET_sub_memcpy_u16(pkt, npa, npalen)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        s->s3.npn_seen = 1;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+EXT_RETURN tls_construct_stoc_alpn_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                   X509 *x, size_t chainidx)
+{
+    if (s->s3.alpn_selected == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt,
+                TLSEXT_TYPE_application_layer_protocol_negotiation)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_sub_memcpy_u8(pkt, s->s3.alpn_selected,
+                                      s->s3.alpn_selected_len)
+            || !WPACKET_close(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+#ifndef OPENSSL_NO_SRTP
+EXT_RETURN tls_construct_stoc_use_srtp_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                       unsigned int context, X509 *x,
+                                       size_t chainidx)
+{
+    if (s->srtp_profile == NULL)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_use_srtp)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_put_bytes_u16(pkt, 2)
+            || !WPACKET_put_bytes_u16(pkt, s->srtp_profile->id)
+            || !WPACKET_put_bytes_u8(pkt, 0)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+#endif
+
+EXT_RETURN tls_construct_stoc_etm_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    /* No encrypt-then-MAC */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_ems_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    /* No extended_master_secret */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_supported_versions_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                                 unsigned int context, X509 *x,
+                                                 size_t chainidx)
+{
+    /* No supported_versions */
+    return EXT_RETURN_NOT_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_key_share_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                        unsigned int context, X509 *x,
+                                        size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    unsigned char *encodedPoint;
+    size_t encoded_pt_len = 0;
+    EVP_PKEY *ckey = s->s3.peer_tmp, *skey = NULL;
+    const TLS_GROUP_INFO *ginf = NULL;
+
+    if (s->hello_retry_request == SSL_HRR_PENDING) {
+        if (ckey != NULL) {
+            /* Original key_share was acceptable so don't ask for another one */
+            return EXT_RETURN_NOT_SENT;
+        }
+        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)
+                || !WPACKET_start_sub_packet_u16(pkt)
+                || !WPACKET_put_bytes_u16(pkt, s->s3.group_id)
+                || !WPACKET_close(pkt)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+
+        return EXT_RETURN_SENT;
+    }
+
+    if (ckey == NULL) {
+        /* No key_share received from client - must be resuming */
+        if (!s->hit || !tls13_generate_handshake_secret(s, NULL, 0)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+        return EXT_RETURN_NOT_SENT;
+    }
+    if (s->hit && (s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE_DHE) == 0) {
+        /*
+         * PSK ('hit') and explicitly not doing DHE (if the client sent the
+         * DHE option we always take it); don't send key share.
+         */
+        return EXT_RETURN_NOT_SENT;
+    }
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_put_bytes_u16(pkt, s->s3.group_id)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    if ((ginf = tls1_group_id_lookup(SSL_CONNECTION_GET_CTX(s), s->s3.group_id)) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!ginf->is_kem) {
+        /* Regular KEX */
+        skey = ssl_generate_pkey(s, ckey);
+        if (skey == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            return EXT_RETURN_FAIL;
+        }
+
+        /* Generate encoding of server key */
+        encoded_pt_len = EVP_PKEY_get1_encoded_public_key(skey, &encodedPoint);
+        if (encoded_pt_len == 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
+            EVP_PKEY_free(skey);
+            return EXT_RETURN_FAIL;
+        }
+
+        if (!WPACKET_sub_memcpy_u16(pkt, encodedPoint, encoded_pt_len)
+                || !WPACKET_close(pkt)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            EVP_PKEY_free(skey);
+            OPENSSL_free(encodedPoint);
+            return EXT_RETURN_FAIL;
+        }
+        OPENSSL_free(encodedPoint);
+
+        /*
+         * This causes the crypto state to be updated based on the derived keys
+         */
+        s->s3.tmp.pkey = skey;
+        if (ssl_derive(s, skey, ckey, 1) == 0) {
+            /* SSLfatal_ntls() already called */
+            return EXT_RETURN_FAIL;
+        }
+    } else {
+        /* KEM mode */
+        unsigned char *ct = NULL;
+        size_t ctlen = 0;
+
+        /*
+         * This does not update the crypto state.
+         *
+         * The generated pms is stored in `s->s3.tmp.pms` to be later used via
+         * ssl_gensecret().
+         */
+        if (ssl_encapsulate(s, ckey, &ct, &ctlen, 0) == 0) {
+            /* SSLfatal_ntls() already called */
+            return EXT_RETURN_FAIL;
+        }
+
+        if (ctlen == 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            OPENSSL_free(ct);
+            return EXT_RETURN_FAIL;
+        }
+
+        if (!WPACKET_sub_memcpy_u16(pkt, ct, ctlen)
+                || !WPACKET_close(pkt)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            OPENSSL_free(ct);
+            return EXT_RETURN_FAIL;
+        }
+        OPENSSL_free(ct);
+
+        /*
+         * This causes the crypto state to be updated based on the generated pms
+         */
+        if (ssl_gensecret(s, s->s3.tmp.pms, s->s3.tmp.pmslen) == 0) {
+            /* SSLfatal_ntls() already called */
+            return EXT_RETURN_FAIL;
+        }
+    }
+    s->s3.did_kex = 1;
+    return EXT_RETURN_SENT;
+#else
+    return EXT_RETURN_FAIL;
+#endif
+}
+
+EXT_RETURN tls_construct_stoc_cookie_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                     X509 *x, size_t chainidx)
+{
+#ifndef OPENSSL_NO_TLS1_3
+    unsigned char *hashval1, *hashval2, *appcookie1, *appcookie2, *cookie;
+    unsigned char *hmac, *hmac2;
+    size_t startlen, ciphlen, totcookielen, hashlen, hmaclen, appcookielen;
+    EVP_MD_CTX *hctx;
+    EVP_PKEY *pkey;
+    int ret = EXT_RETURN_FAIL;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0)
+        return EXT_RETURN_NOT_SENT;
+
+    if (sctx->gen_stateless_cookie_cb == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_NO_COOKIE_CALLBACK_SET);
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_cookie)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_get_total_written(pkt, &startlen)
+            || !WPACKET_reserve_bytes(pkt, MAX_COOKIE_SIZE, &cookie)
+            || !WPACKET_put_bytes_u16(pkt, COOKIE_STATE_FORMAT_VERSION)
+            || !WPACKET_put_bytes_u16(pkt, TLS1_3_VERSION)
+            || !WPACKET_put_bytes_u16(pkt, s->s3.group_id)
+            || !ssl->method->put_cipher_by_char(s->s3.tmp.new_cipher, pkt,
+                                              &ciphlen)
+               /* Is there a key_share extension present in this HRR? */
+            || !WPACKET_put_bytes_u8(pkt, s->s3.peer_tmp == NULL)
+            || !WPACKET_put_bytes_u32(pkt, (unsigned int)time(NULL))
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_reserve_bytes(pkt, EVP_MAX_MD_SIZE, &hashval1)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    /*
+     * Get the hash of the initial ClientHello. ssl_handshake_hash() operates
+     * on raw buffers, so we first reserve sufficient bytes (above) and then
+     * subsequently allocate them (below)
+     */
+    if (!ssl3_digest_cached_records(s, 0)
+            || !ssl_handshake_hash(s, hashval1, EVP_MAX_MD_SIZE, &hashlen)) {
+        /* SSLfatal_ntls() already called */
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!WPACKET_allocate_bytes(pkt, hashlen, &hashval2)
+            || !ossl_assert(hashval1 == hashval2)
+            || !WPACKET_close(pkt)
+            || !WPACKET_start_sub_packet_u8(pkt)
+            || !WPACKET_reserve_bytes(pkt, SSL_COOKIE_LENGTH, &appcookie1)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    /* Generate the application cookie */
+    if (sctx->gen_stateless_cookie_cb(ussl, appcookie1, &appcookielen) == 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_COOKIE_GEN_CALLBACK_FAILURE);
+        return EXT_RETURN_FAIL;
+    }
+
+    if (!WPACKET_allocate_bytes(pkt, appcookielen, &appcookie2)
+            || !ossl_assert(appcookie1 == appcookie2)
+            || !WPACKET_close(pkt)
+            || !WPACKET_get_total_written(pkt, &totcookielen)
+            || !WPACKET_reserve_bytes(pkt, SHA256_DIGEST_LENGTH, &hmac)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+    hmaclen = SHA256_DIGEST_LENGTH;
+
+    totcookielen -= startlen;
+    if (!ossl_assert(totcookielen <= MAX_COOKIE_SIZE - SHA256_DIGEST_LENGTH)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    /* HMAC the cookie */
+    hctx = EVP_MD_CTX_create();
+    pkey = EVP_PKEY_new_raw_private_key_ex(sctx->libctx, "HMAC",
+                                           sctx->propq,
+                                           s->session_ctx->ext.cookie_hmac_key,
+                                           sizeof(s->session_ctx->ext.cookie_hmac_key));
+    if (hctx == NULL || pkey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (EVP_DigestSignInit_ex(hctx, NULL, "SHA2-256", sctx->libctx,
+                              sctx->propq, pkey, NULL) <= 0
+            || EVP_DigestSign(hctx, hmac, &hmaclen, cookie,
+                              totcookielen) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!ossl_assert(totcookielen + hmaclen <= MAX_COOKIE_SIZE)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!WPACKET_allocate_bytes(pkt, hmaclen, &hmac2)
+            || !ossl_assert(hmac == hmac2)
+            || !ossl_assert(cookie == hmac - totcookielen)
+            || !WPACKET_close(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    ret = EXT_RETURN_SENT;
+
+ err:
+    EVP_MD_CTX_free(hctx);
+    EVP_PKEY_free(pkey);
+    return ret;
+#else
+    return EXT_RETURN_FAIL;
+#endif
+}
+
+EXT_RETURN tls_construct_stoc_cryptopro_bug_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx)
+{
+    const unsigned char cryptopro_ext[36] = {
+        0xfd, 0xe8,         /* 65000 */
+        0x00, 0x20,         /* 32 bytes length */
+        0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,
+        0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,
+        0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,
+        0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17
+    };
+
+    if (((s->s3.tmp.new_cipher->id & 0xFFFF) != 0x80
+         && (s->s3.tmp.new_cipher->id & 0xFFFF) != 0x81)
+            || (SSL_get_options(SSL_CONNECTION_GET_SSL(s))
+               & SSL_OP_CRYPTOPRO_TLSEXT_BUG) == 0)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_memcpy(pkt, cryptopro_ext, sizeof(cryptopro_ext))) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_early_data_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         unsigned int context, X509 *x,
+                                         size_t chainidx)
+{
+    if (context == SSL_EXT_TLS1_3_NEW_SESSION_TICKET) {
+        if (s->max_early_data == 0)
+            return EXT_RETURN_NOT_SENT;
+
+        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_early_data)
+                || !WPACKET_start_sub_packet_u16(pkt)
+                || !WPACKET_put_bytes_u32(pkt, s->max_early_data)
+                || !WPACKET_close(pkt)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return EXT_RETURN_FAIL;
+        }
+
+        return EXT_RETURN_SENT;
+    }
+
+    if (s->ext.early_data != SSL_EARLY_DATA_ACCEPTED)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_early_data)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
+
+EXT_RETURN tls_construct_stoc_psk_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx)
+{
+    if (!s->hit)
+        return EXT_RETURN_NOT_SENT;
+
+    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_psk)
+            || !WPACKET_start_sub_packet_u16(pkt)
+            || !WPACKET_put_bytes_u16(pkt, s->ext.tick_identity)
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return EXT_RETURN_FAIL;
+    }
+
+    return EXT_RETURN_SENT;
+}
Index: b/ssl/statem_ntls/ntls_ssl_local.h
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_ssl_local.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#ifndef OSSL_NTLS_SSL_LOCAL_H
+# define OSSL_NTLS_SSL_LOCAL_H
+
+# include "../ssl_local.h"
+# include "ntls_statem.h"
+
+# define SSL_CLIENT_USE_SIGALGS_NTLS(s)        \
+     (SSL_CLIENT_USE_TLS1_2_CIPHERS(s) || (s->client_version == NTLS_VERSION))
+
+/*
+ *optimize later
+ *This is the default ID for NTLS context
+ */
+# define SM2_DEFAULT_ID "1234567812345678"
+# define SM2_DEFAULT_ID_LEN (sizeof(SM2_DEFAULT_ID) - 1)
+
+__owur int ssl_x509err2alert_ntls(int type);
+__owur int ssl3_do_write_ntls(SSL_CONNECTION *s, int type);
+__owur unsigned long ssl3_output_cert_chain_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                                 CERT_PKEY *a_cpk,
+                                                 CERT_PKEY *k_cpk);
+__owur int tls_close_construct_packet_ntls(SSL_CONNECTION *s, WPACKET *pkt, int htype);
+__owur int tls_setup_handshake_ntls(SSL_CONNECTION *s);
+
+__owur int ssl_allow_compression_ntls(SSL_CONNECTION *s);
+
+__owur int ssl_version_supported_ntls(const SSL_CONNECTION *s, int version,
+                                 const SSL_METHOD **meth);
+
+__owur int ssl_set_client_hello_version_ntls(SSL_CONNECTION *s);
+__owur int ssl_check_version_downgrade_ntls(SSL_CONNECTION *s);
+__owur int ssl_set_version_bound_ntls(int method_version, int version, int *bound);
+__owur int ssl_choose_server_version_ntls(SSL_CONNECTION *s, CLIENTHELLO_MSG *hello,
+                                     DOWNGRADE *dgrd);
+__owur int ssl_choose_client_version_ntls(SSL_CONNECTION *s, int version,
+                                     RAW_EXTENSION *extensions);
+__owur int ssl_get_min_max_version_ntls(const SSL_CONNECTION *s, int *min_version,
+                                   int *max_version, int *real_max);
+
+__owur int ntls_alert_code(int code);
+__owur int send_certificate_request_ntls(SSL_CONNECTION *s);
+
+/* statem/extensions_cust.c */
+
+custom_ext_method *custom_ext_find_ntls(const custom_ext_methods *exts,
+                                   ENDPOINT role, unsigned int ext_type,
+                                   size_t *idx);
+
+void custom_ext_init_ntls(custom_ext_methods *meths);
+
+__owur int custom_ext_parse_ntls(SSL_CONNECTION *s, unsigned int context, unsigned int ext_type,
+                            const unsigned char *ext_data, size_t ext_size,
+                            X509 *x, size_t chainidx);
+__owur int custom_ext_add_ntls(SSL_CONNECTION *s, int context, WPACKET *pkt, X509 *x,
+                          size_t chainidx, int maxversion);
+
+__owur int custom_exts_copy_ntls(custom_ext_methods *dst,
+                            const custom_ext_methods *src);
+__owur int custom_exts_copy_flags_ntls(custom_ext_methods *dst,
+                                  const custom_ext_methods *src);
+void custom_exts_free_ntls(custom_ext_methods *exts);
+
+void ssl_comp_free_compression_methods_int(void);
+
+/* ssl_mcnf.c */
+void ssl_ctx_system_config(SSL_CTX *ctx);
+
+#endif
Index: b/ssl/statem_ntls/ntls_statem.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_statem.c
@@ -0,0 +1,928 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include "internal/cryptlib.h"
+#include <openssl/rand.h>
+#include "ntls_ssl_local.h"
+#include "ntls_statem_local.h"
+#include <assert.h>
+
+/*
+ * This file implements the SSL/TLS state machines.
+ *
+ * There are two primary state machines:
+ *
+ * 1) Message flow state machine
+ * 2) Handshake state machine
+ *
+ * The Message flow state machine controls the reading and sending of messages
+ * including handling of non-blocking IO events, flushing of the underlying
+ * write BIO, handling unexpected messages, etc. It is itself broken into two
+ * separate sub-state machines which control reading and writing respectively.
+ *
+ * The Handshake state machine keeps track of the current SSL/TLS handshake
+ * state. Transitions of the handshake state are the result of events that
+ * occur within the Message flow state machine.
+ *
+ * Overall it looks like this:
+ *
+ * ---------------------------------------------            -------------------
+ * |                                           |            |                 |
+ * | Message flow state machine                |            |                 |
+ * |                                           |            |                 |
+ * | -------------------- -------------------- | Transition | Handshake state |
+ * | | MSG_FLOW_READING | | MSG_FLOW_WRITING | | Event      | machine         |
+ * | | sub-state        | | sub-state        | |----------->|                 |
+ * | | machine for      | | machine for      | |            |                 |
+ * | | reading messages | | writing messages | |            |                 |
+ * | -------------------- -------------------- |            |                 |
+ * |                                           |            |                 |
+ * ---------------------------------------------            -------------------
+ *
+ */
+
+/* Sub state machine return values */
+typedef enum {
+    /* Something bad happened or NBIO */
+    SUB_STATE_ERROR,
+    /* Sub state finished go to the next sub state */
+    SUB_STATE_FINISHED,
+    /* Sub state finished and handshake was completed */
+    SUB_STATE_END_HANDSHAKE
+} SUB_STATE_RETURN;
+
+static void init_read_state_machine_ntls(SSL_CONNECTION *s);
+static SUB_STATE_RETURN read_state_machine_ntls(SSL_CONNECTION *s);
+static void init_write_state_machine_ntls(SSL_CONNECTION *s);
+static SUB_STATE_RETURN write_state_machine_ntls(SSL_CONNECTION *s);
+
+OSSL_HANDSHAKE_STATE SSL_get_state_ntls(const SSL_CONNECTION *ssl)
+{
+    return ssl->statem.hand_state;
+}
+
+int SSL_in_init_ntls(const SSL *s)
+{
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL(s);
+
+    if (sc == NULL)
+        return 0;
+
+    return sc->statem.in_init;
+}
+
+int SSL_is_init_finished_ntls(const SSL *s)
+{
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL(s);
+
+    if (sc == NULL)
+        return 0;
+
+    return !(sc->statem.in_init) && (sc->statem.hand_state == TLS_ST_OK);
+}
+
+int SSL_in_before_ntls(const SSL *s)
+{
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL(s);
+
+    if (sc == NULL)
+        return 0;
+    /*
+     * Historically being "in before" meant before anything had happened. In the
+     * current code though we remain in the "before" state for a while after we
+     * have started the handshake process (e.g. as a server waiting for the
+     * first message to arrive). There "in before" is taken to mean "in before"
+     * and not started any handshake process yet.
+     */
+    return (sc->statem.hand_state == TLS_ST_BEFORE)
+        && (sc->statem.state == MSG_FLOW_UNINITED);
+}
+
+/*
+ * Clear the state machine state and reset back to MSG_FLOW_UNINITED
+ */
+void ossl_statem_clear_ntls(SSL_CONNECTION *s)
+{
+    s->statem.state = MSG_FLOW_UNINITED;
+    s->statem.hand_state = TLS_ST_BEFORE;
+    s->statem.in_init = 1;
+    s->statem.no_cert_verify = 0;
+}
+
+/*
+ * Set the state machine up ready for a renegotiation handshake
+ */
+void ossl_statem_set_renegotiate_ntls(SSL_CONNECTION *s)
+{
+    s->statem.in_init = 1;
+    s->statem.request_state = TLS_ST_SW_HELLO_REQ;
+}
+
+void ossl_statem_send_fatal_ntls(SSL_CONNECTION *s, int al)
+{
+    /* We shouldn't call SSLfatal() twice. Once is enough */
+    if (s->statem.in_init && s->statem.state == MSG_FLOW_ERROR)
+      return;
+    ossl_statem_set_in_init(s, 1);
+    s->statem.state = MSG_FLOW_ERROR;
+    if (al != SSL_AD_NO_ALERT)
+        ssl3_send_alert(s, SSL3_AL_FATAL, al);
+}
+
+/*
+ * Error reporting building block that's used instead of ERR_set_error().
+ * In addition to what ERR_set_error() does, this puts the state machine
+ * into an error state and sends an alert if appropriate.
+ * This is a permanent error for the current connection.
+ */
+void ossl_statem_fatal_ntls(SSL_CONNECTION *s, int al, int reason, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    ERR_vset_error(ERR_LIB_SSL, reason, fmt, args);
+    va_end(args);
+
+    ossl_statem_send_fatal_ntls(s, al);
+}
+
+/*
+ * This macro should only be called if we are already expecting to be in
+ * a fatal error state. We verify that we are, and set it if not (this would
+ * indicate a bug).
+ */
+#define check_fatal(s) \
+    do { \
+        if (!ossl_assert((s)->statem.in_init \
+                         && (s)->statem.state == MSG_FLOW_ERROR)) \
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_MISSING_FATAL); \
+    } while (0)
+
+/*
+ * Discover whether the current connection is in the error state.
+ *
+ * Valid return values are:
+ *   1: Yes
+ *   0: No
+ */
+int ossl_statem_in_error_ntls(const SSL_CONNECTION *s)
+{
+    if (s->statem.state == MSG_FLOW_ERROR)
+        return 1;
+
+    return 0;
+}
+
+void ossl_statem_set_in_init_ntls(SSL_CONNECTION *s, int init)
+{
+    s->statem.in_init = init;
+}
+
+int ossl_statem_get_in_handshake_ntls(SSL_CONNECTION *s)
+{
+    return s->statem.in_handshake;
+}
+
+void ossl_statem_set_in_handshake_ntls(SSL_CONNECTION *s, int inhand)
+{
+    if (inhand)
+        s->statem.in_handshake++;
+    else
+        s->statem.in_handshake--;
+}
+
+/* Are we in a sensible state to skip over unreadable early data? */
+int ossl_statem_skip_early_data_ntls(SSL_CONNECTION *s)
+{
+    if (s->ext.early_data != SSL_EARLY_DATA_REJECTED)
+        return 0;
+
+    if (!s->server
+            || s->statem.hand_state != TLS_ST_EARLY_DATA
+            || s->hello_retry_request == SSL_HRR_COMPLETE)
+        return 0;
+
+    return 1;
+}
+
+/*
+ * Called when we are in SSL_read*(), SSL_write*(), or SSL_accept()
+ * /SSL_connect()/SSL_do_handshake(). Used to test whether we are in an early
+ * data state and whether we should attempt to move the handshake on if so.
+ * |sending| is 1 if we are attempting to send data (SSL_write*()), 0 if we are
+ * attempting to read data (SSL_read*()), or -1 if we are in SSL_do_handshake()
+ * or similar.
+ */
+void ossl_statem_check_finish_init_ntls(SSL_CONNECTION *s, int sending)
+{
+    if (sending == -1) {
+        if (s->statem.hand_state == TLS_ST_PENDING_EARLY_DATA_END
+                || s->statem.hand_state == TLS_ST_EARLY_DATA) {
+            ossl_statem_set_in_init_ntls(s, 1);
+            if (s->early_data_state == SSL_EARLY_DATA_WRITE_RETRY) {
+                /*
+                 * SSL_connect() or SSL_do_handshake() has been called directly.
+                 * We don't allow any more writing of early data.
+                 */
+                s->early_data_state = SSL_EARLY_DATA_FINISHED_WRITING;
+            }
+        }
+    } else if (!s->server) {
+        if ((sending && (s->statem.hand_state == TLS_ST_PENDING_EARLY_DATA_END
+                      || s->statem.hand_state == TLS_ST_EARLY_DATA)
+                  && s->early_data_state != SSL_EARLY_DATA_WRITING)
+                || (!sending && s->statem.hand_state == TLS_ST_EARLY_DATA)) {
+            ossl_statem_set_in_init_ntls(s, 1);
+            /*
+             * SSL_write() has been called directly. We don't allow any more
+             * writing of early data.
+             */
+            if (sending && s->early_data_state == SSL_EARLY_DATA_WRITE_RETRY)
+                s->early_data_state = SSL_EARLY_DATA_FINISHED_WRITING;
+        }
+    } else {
+        if (s->early_data_state == SSL_EARLY_DATA_FINISHED_READING
+                && s->statem.hand_state == TLS_ST_EARLY_DATA)
+            ossl_statem_set_in_init_ntls(s, 1);
+    }
+}
+
+void ossl_statem_set_hello_verify_done_ntls(SSL_CONNECTION *s)
+{
+    s->statem.state = MSG_FLOW_UNINITED;
+    s->statem.in_init = 1;
+    /*
+     * This will get reset (briefly) back to TLS_ST_BEFORE when we enter
+     * state_machine() because |state| is MSG_FLOW_UNINITED, but until then any
+     * calls to SSL_in_before_ntls() will return false. Also calls to
+     * SSL_state_string() and SSL_state_string_long() will return something
+     * sensible.
+     */
+    s->statem.hand_state = TLS_ST_SR_CLNT_HELLO;
+}
+
+int ossl_statem_connect_ntls(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+
+    if (sc == NULL)
+        return -1;
+    return state_machine_ntls(sc, 0);
+}
+
+int ossl_statem_accept_ntls(SSL *s)
+{
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
+
+    if (sc == NULL)
+        return -1;
+    return state_machine_ntls(sc, 1);
+}
+
+typedef void (*info_cb) (const SSL *, int, int);
+
+static info_cb get_callback(SSL_CONNECTION *s)
+{
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    if (s->info_callback != NULL)
+        return s->info_callback;
+    else if (sctx->info_callback != NULL)
+        return sctx->info_callback;
+
+    return NULL;
+}
+
+/*
+ * The main message flow state machine. We start in the MSG_FLOW_UNINITED or
+ * MSG_FLOW_FINISHED state and finish in MSG_FLOW_FINISHED. Valid states and
+ * transitions are as follows:
+ *
+ * MSG_FLOW_UNINITED     MSG_FLOW_FINISHED
+ *        |                       |
+ *        +-----------------------+
+ *        v
+ * MSG_FLOW_WRITING <---> MSG_FLOW_READING
+ *        |
+ *        V
+ * MSG_FLOW_FINISHED
+ *        |
+ *        V
+ *    [SUCCESS]
+ *
+ * We may exit at any point due to an error or NBIO event. If an NBIO event
+ * occurs then we restart at the point we left off when we are recalled.
+ * MSG_FLOW_WRITING and MSG_FLOW_READING have sub-state machines associated with them.
+ *
+ * In addition to the above there is also the MSG_FLOW_ERROR state. We can move
+ * into that state at any point in the event that an irrecoverable error occurs.
+ *
+ * Valid return values are:
+ *   1: Success
+ * <=0: NBIO or error
+ */
+int state_machine_ntls(SSL_CONNECTION *s, int server)
+{
+    BUF_MEM *buf = NULL;
+    void (*cb) (const SSL *ssl, int type, int val) = NULL;
+    OSSL_STATEM *st = &s->statem;
+    int ret = -1;
+    int ssret;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    if (st->state == MSG_FLOW_ERROR) {
+        /* Shouldn't have been called if we're already in the error state */
+        return -1;
+    }
+
+    ERR_clear_error();
+    clear_sys_error();
+
+    cb = get_callback(s);
+
+    st->in_handshake++;
+    if (!SSL_in_init_ntls(ssl) || SSL_in_before_ntls(ssl)) {
+        /*
+         * If we are stateless then we already called SSL_clear() - don't do
+         * it again and clear the STATELESS flag itself.
+         */
+        if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0 && !SSL_clear(ssl))
+            return -1;
+    }
+
+    /* Initialise state machine */
+    if (st->state == MSG_FLOW_UNINITED
+            || st->state == MSG_FLOW_FINISHED) {
+        if (st->state == MSG_FLOW_UNINITED) {
+            st->hand_state = TLS_ST_BEFORE;
+            st->request_state = TLS_ST_BEFORE;
+        }
+
+        s->server = server;
+        if (cb != NULL) {
+            cb(ussl, SSL_CB_HANDSHAKE_START, 1);
+        }
+
+        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {
+            SSLfatal_ntls(s, SSL_AD_NO_ALERT, ERR_R_INTERNAL_ERROR);
+            goto end;
+        }
+
+        if (s->init_buf == NULL) {
+            if ((buf = BUF_MEM_new()) == NULL) {
+                SSLfatal_ntls(s, SSL_AD_NO_ALERT, ERR_R_INTERNAL_ERROR);
+                goto end;
+            }
+            if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
+                SSLfatal_ntls(s, SSL_AD_NO_ALERT, ERR_R_INTERNAL_ERROR);
+                goto end;
+            }
+            s->init_buf = buf;
+            buf = NULL;
+        }
+
+        s->init_num = 0;
+
+        /*
+         * Should have been reset by tls_process_finished_ntls, too.
+         */
+        s->s3.change_cipher_spec = 0;
+
+        /*
+         * Ok, we now need to push on a buffering BIO ...but not with
+         * SCTP
+         */
+#ifndef OPENSSL_NO_SCTP
+        if (!SSL_CONNECTION_IS_DTLS(s) || !BIO_dgram_is_sctp(SSL_get_wbio(s)))
+#endif
+            if (!ssl_init_wbio_buffer(s)) {
+                SSLfatal_ntls(s, SSL_AD_NO_ALERT, ERR_R_INTERNAL_ERROR);
+                goto end;
+            }
+
+        if ((SSL_in_before_ntls(ssl))
+                || s->renegotiate) {
+            if (!tls_setup_handshake_ntls(s)) {
+                /* SSLfatal_ntls() already called */
+                goto end;
+            }
+
+            if (SSL_IS_FIRST_HANDSHAKE(s))
+                st->read_state_first_init = 1;
+        }
+
+        st->state = MSG_FLOW_WRITING;
+        init_write_state_machine_ntls(s);
+    }
+
+    while (st->state != MSG_FLOW_FINISHED) {
+        if (st->state == MSG_FLOW_READING) {
+            ssret = read_state_machine_ntls(s);
+            if (ssret == SUB_STATE_FINISHED) {
+                st->state = MSG_FLOW_WRITING;
+                init_write_state_machine_ntls(s);
+            } else {
+                /* NBIO or error */
+                goto end;
+            }
+        } else if (st->state == MSG_FLOW_WRITING) {
+            ssret = write_state_machine_ntls(s);
+            if (ssret == SUB_STATE_FINISHED) {
+                st->state = MSG_FLOW_READING;
+                init_read_state_machine_ntls(s);
+            } else if (ssret == SUB_STATE_END_HANDSHAKE) {
+                st->state = MSG_FLOW_FINISHED;
+            } else {
+                /* NBIO or error */
+                goto end;
+            }
+        } else {
+            /* Error */
+            check_fatal(s);
+			ERR_raise(ERR_LIB_SSL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+            goto end;
+        }
+    }
+
+    ret = 1;
+
+ end:
+    st->in_handshake--;
+
+    BUF_MEM_free(buf);
+    if (cb != NULL) {
+        if (server)
+            cb(ussl, SSL_CB_ACCEPT_EXIT, ret);
+        else
+            cb(ussl, SSL_CB_CONNECT_EXIT, ret);
+    }
+    return ret;
+}
+
+/*
+ * Initialise the MSG_FLOW_READING sub-state machine
+ */
+static void init_read_state_machine_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    st->read_state = READ_STATE_HEADER;
+}
+
+static int grow_init_buf(SSL_CONNECTION *s, size_t size) {
+
+    size_t msg_offset = (char *)s->init_msg - s->init_buf->data;
+
+    if (!BUF_MEM_grow_clean(s->init_buf, (int)size))
+        return 0;
+
+    if (size < msg_offset)
+        return 0;
+
+    s->init_msg = s->init_buf->data + msg_offset;
+
+    return 1;
+}
+
+/*
+ * This function implements the sub-state machine when the message flow is in
+ * MSG_FLOW_READING. The valid sub-states and transitions are:
+ *
+ * READ_STATE_HEADER <--+<-------------+
+ *        |             |              |
+ *        v             |              |
+ * READ_STATE_BODY -----+-->READ_STATE_POST_PROCESS
+ *        |                            |
+ *        +----------------------------+
+ *        v
+ * [SUB_STATE_FINISHED]
+ *
+ * READ_STATE_HEADER has the responsibility for reading in the message header
+ * and transitioning the state of the handshake state machine.
+ *
+ * READ_STATE_BODY reads in the rest of the message and then subsequently
+ * processes it.
+ *
+ * READ_STATE_POST_PROCESS is an optional step that may occur if some post
+ * processing activity performed on the message may block.
+ *
+ * Any of the above states could result in an NBIO event occurring in which case
+ * control returns to the calling application. When this function is recalled we
+ * will resume in the same state where we left off.
+ */
+static SUB_STATE_RETURN read_state_machine_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+    int ret, mt;
+    size_t len = 0;
+    int (*transition) (SSL_CONNECTION *s, int mt);
+    PACKET pkt;
+    MSG_PROCESS_RETURN(*process_message) (SSL_CONNECTION *s, PACKET *pkt);
+    WORK_STATE(*post_process_message) (SSL_CONNECTION *s, WORK_STATE wst);
+    size_t (*max_message_size) (SSL_CONNECTION *s);
+    void (*cb) (const SSL *ssl, int type, int val) = NULL;
+    SSL *ssl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    cb = get_callback(s);
+
+    if (s->server) {
+        transition = ossl_statem_server_read_transition_ntls;
+        process_message = ossl_statem_server_process_message_ntls;
+        max_message_size = ossl_statem_server_max_message_size_ntls;
+        post_process_message = ossl_statem_server_post_process_message_ntls;
+    } else {
+        transition = ossl_statem_client_read_transition_ntls;
+        process_message = ossl_statem_client_process_message_ntls;
+        max_message_size = ossl_statem_client_max_message_size_ntls;
+        post_process_message = ossl_statem_client_post_process_message_ntls;
+    }
+
+    if (st->read_state_first_init) {
+        s->first_packet = 1;
+        st->read_state_first_init = 0;
+    }
+
+    while (1) {
+        switch (st->read_state) {
+        case READ_STATE_HEADER:
+            /* Get the state the peer wants to move to */
+
+            ret = tls_get_message_header_ntls(s, &mt);
+
+            if (ret == 0) {
+                /* Could be non-blocking IO */
+                return SUB_STATE_ERROR;
+            }
+
+            if (cb != NULL) {
+                /* Notify callback of an impending state change */
+                if (s->server)
+                    cb(ssl, SSL_CB_ACCEPT_LOOP, 1);
+                else
+                    cb(ssl, SSL_CB_CONNECT_LOOP, 1);
+            }
+            /*
+             * Validate that we are allowed to move to the new state and move
+             * to that state if so
+             */
+            if (!transition(s, mt))
+                return SUB_STATE_ERROR;
+
+            if (s->s3.tmp.message_size > max_message_size(s)) {
+                SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                              SSL_R_EXCESSIVE_MESSAGE_SIZE);
+                return SUB_STATE_ERROR;
+            }
+
+            if (s->s3.tmp.message_size > 0
+                && !grow_init_buf(s, s->s3.tmp.message_size
+                                  + SSL3_HM_HEADER_LENGTH)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_BUF_LIB);
+                return SUB_STATE_ERROR;
+            }
+
+            st->read_state = READ_STATE_BODY;
+            /* Fall through */
+
+        case READ_STATE_BODY:
+            ret = tls_get_message_body_ntls(s, &len);
+            if (ret == 0) {
+                /* Could be non-blocking IO */
+                return SUB_STATE_ERROR;
+            }
+
+            s->first_packet = 0;
+            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return SUB_STATE_ERROR;
+            }
+
+            ret = process_message(s, &pkt);
+
+            /* Discard the packet data */
+            s->init_num = 0;
+
+            switch (ret) {
+            case MSG_PROCESS_ERROR:
+                check_fatal(s);
+                return SUB_STATE_ERROR;
+
+            case MSG_PROCESS_FINISHED_READING:
+                return SUB_STATE_FINISHED;
+
+            case MSG_PROCESS_CONTINUE_PROCESSING:
+                st->read_state = READ_STATE_POST_PROCESS;
+                st->read_state_work = WORK_MORE_A;
+                break;
+
+            default:
+                st->read_state = READ_STATE_HEADER;
+                break;
+            }
+            break;
+
+        case READ_STATE_POST_PROCESS:
+            st->read_state_work = post_process_message(s, st->read_state_work);
+            switch (st->read_state_work) {
+            case WORK_ERROR:
+                check_fatal(s);
+                /* Fall through */
+            case WORK_MORE_A:
+            case WORK_MORE_B:
+            case WORK_MORE_C:
+                return SUB_STATE_ERROR;
+
+            case WORK_FINISHED_CONTINUE:
+                st->read_state = READ_STATE_HEADER;
+                break;
+
+            case WORK_FINISHED_STOP:
+                return SUB_STATE_FINISHED;
+            }
+            break;
+
+        default:
+            /* Shouldn't happen */
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return SUB_STATE_ERROR;
+        }
+    }
+}
+
+/*
+ * Send a previously constructed message to the peer.
+ */
+static int statem_do_write(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    if (st->hand_state == TLS_ST_CW_CHANGE
+        || st->hand_state == TLS_ST_SW_CHANGE) {
+        return ssl3_do_write_ntls(s, SSL3_RT_CHANGE_CIPHER_SPEC);
+    } else {
+        return ssl_do_write(s);
+    }
+}
+
+/*
+ * Initialise the MSG_FLOW_WRITING sub-state machine
+ */
+static void init_write_state_machine_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    st->write_state = WRITE_STATE_TRANSITION;
+}
+
+/*
+ * This function implements the sub-state machine when the message flow is in
+ * MSG_FLOW_WRITING. The valid sub-states and transitions are:
+ *
+ * +-> WRITE_STATE_TRANSITION ------> [SUB_STATE_FINISHED]
+ * |             |
+ * |             v
+ * |      WRITE_STATE_PRE_WORK -----> [SUB_STATE_END_HANDSHAKE]
+ * |             |
+ * |             v
+ * |       WRITE_STATE_SEND
+ * |             |
+ * |             v
+ * |     WRITE_STATE_POST_WORK
+ * |             |
+ * +-------------+
+ *
+ * WRITE_STATE_TRANSITION transitions the state of the handshake state machine
+
+ * WRITE_STATE_PRE_WORK performs any work necessary to prepare the later
+ * sending of the message. This could result in an NBIO event occurring in
+ * which case control returns to the calling application. When this function
+ * is recalled we will resume in the same state where we left off.
+ *
+ * WRITE_STATE_SEND sends the message and performs any work to be done after
+ * sending.
+ *
+ * WRITE_STATE_POST_WORK performs any work necessary after the sending of the
+ * message has been completed. As for WRITE_STATE_PRE_WORK this could also
+ * result in an NBIO event.
+ */
+static SUB_STATE_RETURN write_state_machine_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+    int ret;
+    WRITE_TRAN(*transition) (SSL_CONNECTION *s);
+    WORK_STATE(*pre_work) (SSL_CONNECTION *s, WORK_STATE wst);
+    WORK_STATE(*post_work) (SSL_CONNECTION *s, WORK_STATE wst);
+    int (*get_construct_message_f) (SSL_CONNECTION *s, WPACKET *pkt,
+                                    int (**confunc) (SSL_CONNECTION *s, WPACKET *pkt),
+                                    int *mt);
+    void (*cb) (const SSL *ssl, int type, int val) = NULL;
+    int (*confunc) (SSL_CONNECTION *s, WPACKET *pkt);
+    int mt;
+    WPACKET pkt;
+    SSL *ssl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    cb = get_callback(s);
+
+    if (s->server) {
+        transition = ossl_statem_server_write_transition_ntls;
+        pre_work = ossl_statem_server_pre_work_ntls;
+        post_work = ossl_statem_server_post_work_ntls;
+        get_construct_message_f = ossl_statem_server_construct_message_ntls;
+    } else {
+        transition = ossl_statem_client_write_transition_ntls;
+        pre_work = ossl_statem_client_pre_work_ntls;
+        post_work = ossl_statem_client_post_work_ntls;
+        get_construct_message_f = ossl_statem_client_construct_message_ntls;
+    }
+
+    while (1) {
+        switch (st->write_state) {
+        case WRITE_STATE_TRANSITION:
+            if (cb != NULL) {
+                /* Notify callback of an impending state change */
+                if (s->server)
+                    cb(ssl, SSL_CB_ACCEPT_LOOP, 1);
+                else
+                    cb(ssl, SSL_CB_CONNECT_LOOP, 1);
+            }
+            switch (transition(s)) {
+            case WRITE_TRAN_CONTINUE:
+                st->write_state = WRITE_STATE_PRE_WORK;
+                st->write_state_work = WORK_MORE_A;
+                break;
+
+            case WRITE_TRAN_FINISHED:
+                return SUB_STATE_FINISHED;
+                break;
+
+            case WRITE_TRAN_ERROR:
+                check_fatal(s);
+                return SUB_STATE_ERROR;
+            }
+            break;
+
+        case WRITE_STATE_PRE_WORK:
+            switch (st->write_state_work = pre_work(s, st->write_state_work)) {
+            case WORK_ERROR:
+                check_fatal(s);
+                /* Fall through */
+            case WORK_MORE_A:
+            case WORK_MORE_B:
+            case WORK_MORE_C:
+                return SUB_STATE_ERROR;
+
+            case WORK_FINISHED_CONTINUE:
+                st->write_state = WRITE_STATE_SEND;
+                break;
+
+            case WORK_FINISHED_STOP:
+                return SUB_STATE_END_HANDSHAKE;
+            }
+            if (!get_construct_message_f(s, &pkt, &confunc, &mt)) {
+                /* SSLfatal_ntls() already called */
+                return SUB_STATE_ERROR;
+            }
+            if (mt == SSL3_MT_DUMMY) {
+                /* Skip construction and sending. This isn't a "real" state */
+                st->write_state = WRITE_STATE_POST_WORK;
+                st->write_state_work = WORK_MORE_A;
+                break;
+            }
+
+            if (!WPACKET_init(&pkt, s->init_buf)
+                    || !ssl_set_handshake_header(s, &pkt, mt)) {
+                WPACKET_cleanup(&pkt);
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return SUB_STATE_ERROR;
+            }
+            if (confunc != NULL && !confunc(s, &pkt)) {
+                WPACKET_cleanup(&pkt);
+                check_fatal(s);
+                return SUB_STATE_ERROR;
+            }
+            if (!ssl_close_construct_packet(s, &pkt, mt)
+                    || !WPACKET_finish(&pkt)) {
+                WPACKET_cleanup(&pkt);
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return SUB_STATE_ERROR;
+            }
+
+            /* Fall through */
+
+        case WRITE_STATE_SEND:
+            ret = statem_do_write(s);
+            if (ret <= 0) {
+                return SUB_STATE_ERROR;
+            }
+            st->write_state = WRITE_STATE_POST_WORK;
+            st->write_state_work = WORK_MORE_A;
+            /* Fall through */
+
+        case WRITE_STATE_POST_WORK:
+            switch (st->write_state_work = post_work(s, st->write_state_work)) {
+            case WORK_ERROR:
+                check_fatal(s);
+                /* Fall through */
+            case WORK_MORE_A:
+            case WORK_MORE_B:
+            case WORK_MORE_C:
+                return SUB_STATE_ERROR;
+
+            case WORK_FINISHED_CONTINUE:
+                st->write_state = WRITE_STATE_TRANSITION;
+                break;
+
+            case WORK_FINISHED_STOP:
+                return SUB_STATE_END_HANDSHAKE;
+            }
+            break;
+
+        default:
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return SUB_STATE_ERROR;
+        }
+    }
+}
+
+/*
+ * Flush the write BIO
+ */
+int statem_flush_ntls(SSL_CONNECTION *s)
+{
+    s->rwstate = SSL_WRITING;
+    if (BIO_flush(s->wbio) <= 0)
+        return 0;
+
+    s->rwstate = SSL_NOTHING;
+
+    return 1;
+}
+
+/*
+ * Called by the record layer to determine whether application data is
+ * allowed to be received in the current handshake state or not.
+ *
+ * Return values are:
+ *   1: Yes (application data allowed)
+ *   0: No (application data not allowed)
+ */
+int ossl_statem_app_data_allowed_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    if (st->state == MSG_FLOW_UNINITED)
+        return 0;
+
+    if (!s->s3.in_read_app_data || (s->s3.total_renegotiations == 0))
+        return 0;
+
+    if (s->server) {
+        /*
+         * If we're a server and we haven't got as far as writing our
+         * ServerHello yet then we allow app data
+         */
+        if (st->hand_state == TLS_ST_BEFORE
+            || st->hand_state == TLS_ST_SR_CLNT_HELLO)
+            return 1;
+    } else {
+        /*
+         * If we're a client and we haven't read the ServerHello yet then we
+         * allow app data
+         */
+        if (st->hand_state == TLS_ST_CW_CLNT_HELLO)
+            return 1;
+    }
+
+    return 0;
+}
+
+/*
+ * This function returns 1 if TLS exporter is ready to export keying
+ * material, or 0 if otherwise.
+ */
+int ossl_statem_export_allowed_ntls(SSL_CONNECTION *s)
+{
+    return s->s3.previous_server_finished_len != 0
+           && s->statem.hand_state != TLS_ST_SW_FINISHED;
+}
+
+/*
+ * Return 1 if early TLS exporter is ready to export keying material,
+ * or 0 if otherwise.
+ */
+int ossl_statem_export_early_allowed_ntls(SSL_CONNECTION *s)
+{
+    /*
+     * The early exporter secret is only present on the server if we
+     * have accepted early_data. It is present on the client as long
+     * as we have sent early_data.
+     */
+    return s->ext.early_data == SSL_EARLY_DATA_ACCEPTED
+           || (!s->server && s->ext.early_data != SSL_EARLY_DATA_NOT_SENT);
+}
Index: b/ssl/statem_ntls/ntls_statem.h
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_statem.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+/*****************************************************************************
+ *                                                                           *
+ * These enums should be considered PRIVATE to the state machine. No         *
+ * non-state machine code should need to use these                           *
+ *                                                                           *
+ *****************************************************************************/
+/*
+ * Valid return codes used for functions performing work prior to or after
+ * sending or receiving a message
+ */
+
+typedef enum {
+    /* Something went wrong */
+    WORK_ERROR_NTLS,
+    /* We're done working and there shouldn't be anything else to do after */
+    WORK_FINISHED_STOP_NTLS,
+    /* We're done working move onto the next thing */
+    WORK_FINISHED_CONTINUE_NTLS,
+    /* We're working on phase A */
+    WORK_MORE_A_NTLS,
+    /* We're working on phase B */
+    WORK_MORE_B_NTLS,
+    /* We're working on phase C */
+    WORK_MORE_C_NTLS
+} WORK_STATE_NTLS;
+
+/* Write transition return codes */
+typedef enum {
+    /* Something went wrong */
+    WRITE_TRAN_ERROR_NTLS,
+    /* A transition was successfully completed and we should continue */
+    WRITE_TRAN_CONTINUE_NTLS,
+    /* There is no more write work to be done */
+    WRITE_TRAN_FINISHED_NTLS
+} WRITE_TRAN_NTLS;
+
+/* Message flow states */
+typedef enum {
+    /* No handshake in progress */
+    MSG_FLOW_UNINITED_NTLS,
+    /* A permanent error with this connection */
+    MSG_FLOW_ERROR_NTLS,
+    /* We are reading messages */
+    MSG_FLOW_READING_NTLS,
+    /* We are writing messages */
+    MSG_FLOW_WRITING_NTLS,
+    /* Handshake has finished */
+    MSG_FLOW_FINISHED_NTLS
+} MSG_FLOW_STATE_NTLS;
+
+/* Read states */
+typedef enum {
+    READ_STATE_HEADER_NTLS,
+    READ_STATE_BODY_NTLS,
+    READ_STATE_POST_PROCESS_NTLS
+} READ_STATE_NTLS;
+
+/* Write states */
+typedef enum {
+    WRITE_STATE_TRANSITION_NTLS,
+    WRITE_STATE_PRE_WORK_NTLS,
+    WRITE_STATE_SEND_NTLS,
+    WRITE_STATE_POST_WORK_NTLS
+} WRITE_STATE_NTLS;
+
+typedef enum {
+    /* The enc_write_ctx can be used normally */
+    ENC_WRITE_STATE_VALID_NTLS,
+    /* The enc_write_ctx cannot be used */
+    ENC_WRITE_STATE_INVALID_NTLS,
+    /* Write alerts in plaintext, but otherwise use the enc_write_ctx */
+    ENC_WRITE_STATE_WRITE_PLAIN_ALERTS_NTLS
+} ENC_WRITE_STATES_NTLS;
+
+typedef enum {
+    /* The enc_read_ctx can be used normally */
+    ENC_READ_STATE_VALID_NTLS,
+    /* We may receive encrypted or plaintext alerts */
+    ENC_READ_STATE_ALLOW_PLAIN_ALERTS_NTLS
+} ENC_READ_STATES_NTLS;
+
+
+
+/*****************************************************************************
+ *                                                                           *
+ * The following macros/functions represent the libssl internal API to the   *
+ * state machine. Any libssl code may call these functions/macros            *
+ *                                                                           *
+ *****************************************************************************/
+
+__owur int ossl_statem_accept_ntls(SSL *s);
+__owur int ossl_statem_connect_ntls(SSL *s);
+void ossl_statem_clear_ntls(SSL_CONNECTION *s);
+void ossl_statem_set_renegotiate_ntls(SSL_CONNECTION *s);
+void ossl_statem_send_fatal_ntls(SSL_CONNECTION *s, int al);
+void ossl_statem_fatal_ntls(SSL_CONNECTION *s, int al, int reason, const char *fmt, ...);
+# define SSL_AD_NO_ALERT    -1
+# define SSLfatal_alert_ntls(s, al) ossl_statem_send_fatal_ntls((s), (al))
+# define SSLfatal_ntls(s, al, r) SSLfatal_data_ntls((s), (al), (r), NULL)
+# define SSLfatal_data_ntls                                     \
+    (ERR_new(),                                                 \
+     ERR_set_debug(OPENSSL_FILE, OPENSSL_LINE, OPENSSL_FUNC),   \
+     ossl_statem_fatal_ntls)
+
+int ossl_statem_in_error_ntls(const SSL_CONNECTION *s);
+void ossl_statem_set_in_init_ntls(SSL_CONNECTION *s, int init);
+int ossl_statem_get_in_handshake_ntls(SSL_CONNECTION *s);
+void ossl_statem_set_in_handshake_ntls(SSL_CONNECTION *s, int inhand);
+__owur int ossl_statem_skip_early_data_ntls(SSL_CONNECTION *s);
+void ossl_statem_check_finish_init_ntls(SSL_CONNECTION *s, int send);
+void ossl_statem_set_hello_verify_done_ntls(SSL_CONNECTION *s);
+__owur int ossl_statem_app_data_allowed_ntls(SSL_CONNECTION *s);
+__owur int ossl_statem_export_allowed_ntls(SSL_CONNECTION *s);
+__owur int ossl_statem_export_early_allowed_ntls(SSL_CONNECTION *s);
+
+/* Flush the write BIO */
+int statem_flush_ntls(SSL_CONNECTION *s);
+int state_machine_ntls(SSL_CONNECTION *s, int server);
+int SSL_connection_is_ntls(SSL_CONNECTION *s, int is_server);
Index: b/ssl/statem_ntls/ntls_statem_clnt.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_statem_clnt.c
@@ -0,0 +1,2406 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include <stdio.h>
+#include <time.h>
+#include <assert.h>
+#include "ntls_ssl_local.h"
+#include "ntls_statem_local.h"
+#include <openssl/buffer.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/md5.h>
+#include <openssl/dh.h>
+#include <openssl/bn.h>
+#include <openssl/engine.h>
+#include <openssl/param_build.h>
+#include "internal/cryptlib.h"
+#include "internal/tlsgroups.h"
+
+static MSG_PROCESS_RETURN tls_process_as_hello_retry_request(SSL_CONNECTION *s, PACKET *pkt);
+
+static ossl_inline int cert_req_allowed(SSL_CONNECTION *s);
+static int key_exchange_expected(SSL_CONNECTION *s);
+static int ssl_cipher_list_to_bytes(SSL_CONNECTION *s, STACK_OF(SSL_CIPHER) *sk,
+                                    WPACKET *pkt);
+
+/*
+ * Is a CertificateRequest message allowed at the moment or not?
+ *
+ *  Return values are:
+ *  1: Yes
+ *  0: No
+ */
+static ossl_inline int cert_req_allowed(SSL_CONNECTION *s)
+{
+    /* TLS does not like anon-DH with client cert */
+    if ((s->version > SSL3_VERSION
+         && (s->s3.tmp.new_cipher->algorithm_auth & SSL_aNULL))
+        || (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
+        return 0;
+
+    return 1;
+}
+
+/*
+ * Should we expect the ServerKeyExchange message or not?
+ *
+ *  Return values are:
+ *  1: Yes
+ *  0: No
+ */
+static int key_exchange_expected(SSL_CONNECTION *s)
+{
+    return 1;
+}
+
+
+/*
+ * ossl_statem_client_read_transition_ntls() encapsulates the logic for the allowed
+ * handshake state transitions when the client is reading messages from the
+ * server. The message type that the server has sent is provided in |mt|. The
+ * current state is in |s->statem.hand_state|.
+ *
+ * Return values are 1 for success (transition allowed) and  0 on error
+ * (transition not allowed)
+ */
+int ossl_statem_client_read_transition_ntls(SSL_CONNECTION *s, int mt)
+{
+    OSSL_STATEM *st = &s->statem;
+    int ske_expected;
+
+    /*
+     * Note that after writing the first ClientHello we don't know what version
+     * we are going to negotiate yet, so we don't take this branch until later.
+     */
+
+    switch (st->hand_state) {
+    default:
+        break;
+
+    case TLS_ST_CW_CLNT_HELLO:
+        if (mt == SSL3_MT_SERVER_HELLO) {
+            st->hand_state = TLS_ST_CR_SRVR_HELLO;
+            return 1;
+        }
+
+        break;
+
+    case TLS_ST_EARLY_DATA:
+        /*
+         * We've not actually selected TLSv1.3 yet, but we have sent early
+         * data. The only thing allowed now is a ServerHello or a
+         * HelloRetryRequest.
+         */
+        if (mt == SSL3_MT_SERVER_HELLO) {
+            st->hand_state = TLS_ST_CR_SRVR_HELLO;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_CR_SRVR_HELLO:
+        if (s->hit) {
+            if (s->ext.ticket_expected) {
+                if (mt == SSL3_MT_NEWSESSION_TICKET) {
+                    st->hand_state = TLS_ST_CR_SESSION_TICKET;
+                    return 1;
+                }
+            } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+                st->hand_state = TLS_ST_CR_CHANGE;
+                return 1;
+            }
+        } else {
+            if (s->version >= NTLS_VERSION
+                       && s->ext.session_secret_cb != NULL
+                       && s->session->ext.tick != NULL
+                       && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+                /*
+                 * Normally, we can tell if the server is resuming the session
+                 * from the session ID. EAP-FAST (RFC 4851), however, relies on
+                 * the next server message after the ServerHello to determine if
+                 * the server is resuming.
+                 */
+                s->hit = 1;
+                st->hand_state = TLS_ST_CR_CHANGE;
+                return 1;
+            } else if (!(s->s3.tmp.new_cipher->algorithm_auth
+                         & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {
+                if (mt == SSL3_MT_CERTIFICATE) {
+                    st->hand_state = TLS_ST_CR_CERT;
+                    return 1;
+                }
+            } else {
+                ske_expected = key_exchange_expected(s);
+                /* SKE is optional for some PSK ciphersuites */
+                if (ske_expected
+                    || ((s->s3.tmp.new_cipher->algorithm_mkey & SSL_PSK)
+                        && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {
+                    if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {
+                        st->hand_state = TLS_ST_CR_KEY_EXCH;
+                        return 1;
+                    }
+                } else if (mt == SSL3_MT_CERTIFICATE_REQUEST
+                           && cert_req_allowed(s)) {
+                    st->hand_state = TLS_ST_CR_CERT_REQ;
+                    return 1;
+                } else if (mt == SSL3_MT_SERVER_DONE) {
+                    st->hand_state = TLS_ST_CR_SRVR_DONE;
+                    return 1;
+                }
+            }
+        }
+        break;
+
+    case TLS_ST_CR_CERT:
+        /*
+         * The CertificateStatus message is optional even if
+         * |ext.status_expected| is set
+         */
+        if (s->ext.status_expected && mt == SSL3_MT_CERTIFICATE_STATUS) {
+            st->hand_state = TLS_ST_CR_CERT_STATUS;
+            return 1;
+        }
+        /* Fall through */
+
+    case TLS_ST_CR_CERT_STATUS:
+        ske_expected = key_exchange_expected(s);
+        /* SKE is optional for some PSK ciphersuites */
+        if (ske_expected || ((s->s3.tmp.new_cipher->algorithm_mkey & SSL_PSK)
+                             && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {
+            if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {
+                st->hand_state = TLS_ST_CR_KEY_EXCH;
+                return 1;
+            }
+            goto err;
+        }
+        /* Fall through */
+
+    case TLS_ST_CR_KEY_EXCH:
+        if (mt == SSL3_MT_CERTIFICATE_REQUEST) {
+            if (cert_req_allowed(s)) {
+                st->hand_state = TLS_ST_CR_CERT_REQ;
+                return 1;
+            }
+            goto err;
+        }
+        /* Fall through */
+
+    case TLS_ST_CR_CERT_REQ:
+        if (mt == SSL3_MT_SERVER_DONE) {
+            st->hand_state = TLS_ST_CR_SRVR_DONE;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_CW_FINISHED:
+        if (s->ext.ticket_expected) {
+            if (mt == SSL3_MT_NEWSESSION_TICKET) {
+                st->hand_state = TLS_ST_CR_SESSION_TICKET;
+                return 1;
+            }
+        } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+            st->hand_state = TLS_ST_CR_CHANGE;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_CR_SESSION_TICKET:
+        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+            st->hand_state = TLS_ST_CR_CHANGE;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_CR_CHANGE:
+        if (mt == SSL3_MT_FINISHED) {
+            st->hand_state = TLS_ST_CR_FINISHED;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_OK:
+        if (mt == SSL3_MT_HELLO_REQUEST) {
+            st->hand_state = TLS_ST_CR_HELLO_REQ;
+            return 1;
+        }
+        break;
+    }
+
+ err:
+    SSLfatal_ntls(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
+    return 0;
+}
+
+/*
+ * ossl_statem_client_write_transition_ntls() works out what handshake state to
+ * move to next when the client is writing messages to be sent to the server.
+ */
+WRITE_TRAN ossl_statem_client_write_transition_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    /*
+     * Note that immediately before/after a ClientHello we don't know what
+     * version we are going to negotiate yet, so we don't take this branch until
+     * later
+     */
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return WRITE_TRAN_ERROR;
+
+    case TLS_ST_OK:
+        if (!s->renegotiate) {
+            /*
+             * We haven't requested a renegotiation ourselves so we must have
+             * received a message from the server. Better read it.
+             */
+            return WRITE_TRAN_FINISHED;
+        }
+        /* Renegotiation */
+        /* fall thru */
+    case TLS_ST_BEFORE:
+        st->hand_state = TLS_ST_CW_CLNT_HELLO;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_CW_CLNT_HELLO:
+        if (s->early_data_state == SSL_EARLY_DATA_CONNECTING) {
+            /*
+             * We are assuming this is a TLSv1.3 connection, although we haven't
+             * actually selected a version yet.
+             */
+            if ((s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0)
+                st->hand_state = TLS_ST_CW_CHANGE;
+            else
+                st->hand_state = TLS_ST_EARLY_DATA;
+            return WRITE_TRAN_CONTINUE;
+        }
+        /*
+         * No transition at the end of writing because we don't know what
+         * we will be sent
+         */
+        return WRITE_TRAN_FINISHED;
+
+    case TLS_ST_CR_SRVR_HELLO:
+        /*
+         * We only get here in TLSv1.3. We just received an HRR, so issue a
+         * CCS unless middlebox compat mode is off, or we already issued one
+         * because we did early data.
+         */
+        if ((s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0
+                && s->early_data_state != SSL_EARLY_DATA_FINISHED_WRITING)
+            st->hand_state = TLS_ST_CW_CHANGE;
+        else
+            st->hand_state = TLS_ST_CW_CLNT_HELLO;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_EARLY_DATA:
+        return WRITE_TRAN_FINISHED;
+
+    case TLS_ST_CR_SRVR_DONE:
+        if (s->s3.tmp.cert_req)
+            st->hand_state = TLS_ST_CW_CERT;
+        else
+            st->hand_state = TLS_ST_CW_KEY_EXCH;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_CW_CERT:
+        st->hand_state = TLS_ST_CW_KEY_EXCH;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_CW_KEY_EXCH:
+        /*
+         * For TLS, cert_req is set to 2, so a cert chain of nothing is
+         * sent, but no verify packet is sent
+         */
+        /*
+         * XXX: For now, we do not support client authentication in ECDH
+         * cipher suites with ECDH (rather than ECDSA) certificates. We
+         * need to skip the certificate verify message when client's
+         * ECDH public key is sent inside the client certificate.
+         */
+        if (s->s3.tmp.cert_req == 1) {
+            st->hand_state = TLS_ST_CW_CERT_VRFY;
+        } else {
+            st->hand_state = TLS_ST_CW_CHANGE;
+        }
+        if (s->s3.flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {
+            st->hand_state = TLS_ST_CW_CHANGE;
+        }
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_CW_CERT_VRFY:
+        st->hand_state = TLS_ST_CW_CHANGE;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_CW_CHANGE:
+        if (s->hello_retry_request == SSL_HRR_PENDING) {
+            st->hand_state = TLS_ST_CW_CLNT_HELLO;
+        } else if (s->early_data_state == SSL_EARLY_DATA_CONNECTING) {
+            st->hand_state = TLS_ST_EARLY_DATA;
+        } else {
+#if defined(OPENSSL_NO_NEXTPROTONEG)
+            st->hand_state = TLS_ST_CW_FINISHED;
+#else
+            if (s->s3.npn_seen)
+                st->hand_state = TLS_ST_CW_NEXT_PROTO;
+            else
+                st->hand_state = TLS_ST_CW_FINISHED;
+#endif
+        }
+        return WRITE_TRAN_CONTINUE;
+
+#if !defined(OPENSSL_NO_NEXTPROTONEG)
+    case TLS_ST_CW_NEXT_PROTO:
+        st->hand_state = TLS_ST_CW_FINISHED;
+        return WRITE_TRAN_CONTINUE;
+#endif
+
+    case TLS_ST_CW_FINISHED:
+        if (s->hit) {
+            st->hand_state = TLS_ST_OK;
+            return WRITE_TRAN_CONTINUE;
+        } else {
+            return WRITE_TRAN_FINISHED;
+        }
+
+    case TLS_ST_CR_FINISHED:
+        if (s->hit) {
+            st->hand_state = TLS_ST_CW_CHANGE;
+            return WRITE_TRAN_CONTINUE;
+        } else {
+            st->hand_state = TLS_ST_OK;
+            return WRITE_TRAN_CONTINUE;
+        }
+
+    case TLS_ST_CR_HELLO_REQ:
+        /*
+         * If we can renegotiate now then do so, otherwise wait for a more
+         * convenient time.
+         */
+        if (ssl3_renegotiate_check(SSL_CONNECTION_GET_SSL(s), 1)) {
+            if (!tls_setup_handshake_ntls(s)) {
+                /* SSLfatal_ntls() already called */
+                return WRITE_TRAN_ERROR;
+            }
+            st->hand_state = TLS_ST_CW_CLNT_HELLO;
+            return WRITE_TRAN_CONTINUE;
+        }
+        st->hand_state = TLS_ST_OK;
+        return WRITE_TRAN_CONTINUE;
+    }
+}
+
+/*
+ * Perform any pre work that needs to be done prior to sending a message from
+ * the client to the server.
+ */
+WORK_STATE ossl_statem_client_pre_work_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* No pre work to be done */
+        break;
+
+    case TLS_ST_CW_CLNT_HELLO:
+        s->shutdown = 0;
+        break;
+
+    case TLS_ST_CW_CHANGE:
+        break;
+
+    case TLS_ST_PENDING_EARLY_DATA_END:
+        /*
+         * If we've been called by SSL_do_handshake()/SSL_write(), or we did not
+         * attempt to write early data before calling SSL_read() then we press
+         * on with the handshake. Otherwise we pause here.
+         */
+        if (s->early_data_state == SSL_EARLY_DATA_FINISHED_WRITING
+                || s->early_data_state == SSL_EARLY_DATA_NONE)
+            return WORK_FINISHED_CONTINUE;
+        /* Fall through */
+
+    case TLS_ST_EARLY_DATA:
+        return tls_finish_handshake_ntls(s, wst, 0, 1);
+
+    case TLS_ST_OK:
+        /* Calls SSLfatal_ntls() as required */
+        return tls_finish_handshake_ntls(s, wst, 1, 1);
+    }
+
+    return WORK_FINISHED_CONTINUE;
+}
+
+/*
+ * Perform any work that needs to be done after sending a message from the
+ * client to the server.
+ */
+WORK_STATE ossl_statem_client_post_work_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    OSSL_STATEM *st = &s->statem;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    s->init_num = 0;
+
+    switch (st->hand_state) {
+    default:
+        /* No post work to be done */
+        break;
+
+    case TLS_ST_CW_CLNT_HELLO:
+        if (s->early_data_state == SSL_EARLY_DATA_CONNECTING
+                && s->max_early_data > 0) {
+            /*
+             * We haven't selected TLSv1.3 yet so we don't call the change
+             * cipher state function associated with the SSL_METHOD. Instead
+             * we call tls13_change_cipher_state() directly.
+             */
+            if ((s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) == 0) {
+                if (!tls13_change_cipher_state(s,
+                            SSL3_CC_EARLY | SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {
+                    /* SSLfatal_ntls() already called */
+                    return WORK_ERROR;
+                }
+            }
+            /* else we're in compat mode so we delay flushing until after CCS */
+        } else if (!statem_flush_ntls(s)) {
+            return WORK_MORE_A;
+        }
+
+        break;
+
+    case TLS_ST_CW_END_OF_EARLY_DATA:
+        /*
+         * We set the enc_write_ctx back to NULL because we may end up writing
+         * in cleartext again if we get a HelloRetryRequest from the server.
+         */
+        // EVP_CIPHER_CTX_free(s->enc_write_ctx);
+        // s->enc_write_ctx = NULL;
+        break;
+
+    case TLS_ST_CW_KEY_EXCH:
+        if (tls_client_key_exchange_post_work_ntls(s) == 0) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+        break;
+
+    case TLS_ST_CW_CHANGE:
+        if (s->hello_retry_request == SSL_HRR_PENDING)
+            break;
+        if (s->early_data_state == SSL_EARLY_DATA_CONNECTING
+                    && s->max_early_data > 0) {
+            /*
+             * We haven't selected TLSv1.3 yet so we don't call the change
+             * cipher state function associated with the SSL_METHOD. Instead
+             * we call tls13_change_cipher_state() directly.
+             */
+            if (!tls13_change_cipher_state(s,
+                        SSL3_CC_EARLY | SSL3_CHANGE_CIPHER_CLIENT_WRITE))
+                return WORK_ERROR;
+            break;
+        }
+        s->session->cipher = s->s3.tmp.new_cipher;
+#ifdef OPENSSL_NO_COMP
+        s->session->compress_meth = 0;
+#else
+        if (s->s3.tmp.new_compression == NULL)
+            s->session->compress_meth = 0;
+        else
+            s->session->compress_meth = s->s3.tmp.new_compression->id;
+#endif
+        if (!ssl->method->ssl3_enc->setup_key_block(s)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+
+        if (!ssl->method->ssl3_enc->change_cipher_state(s,
+                                          SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+
+        break;
+
+    case TLS_ST_CW_FINISHED:
+        if (statem_flush_ntls(s) != 1)
+            return WORK_MORE_B;
+        break;
+
+    case TLS_ST_CW_KEY_UPDATE:
+        if (statem_flush_ntls(s) != 1)
+            return WORK_MORE_A;
+        if (!tls13_update_key(s, 1)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+        break;
+    }
+
+    return WORK_FINISHED_CONTINUE;
+}
+
+/*
+ * Get the message construction function and message type for sending from the
+ * client
+ *
+ * Valid return values are:
+ *   1: Success
+ *   0: Error
+ */
+int ossl_statem_client_construct_message_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         confunc_f *confunc, int *mt)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_HANDSHAKE_STATE);
+        return 0;
+
+    case TLS_ST_CW_CHANGE:
+        *confunc = tls_construct_change_cipher_spec_ntls;
+        *mt = SSL3_MT_CHANGE_CIPHER_SPEC;
+        break;
+
+    case TLS_ST_CW_CLNT_HELLO:
+        *confunc = tls_construct_client_hello_ntls;
+        *mt = SSL3_MT_CLIENT_HELLO;
+        break;
+
+    case TLS_ST_CW_END_OF_EARLY_DATA:
+        *confunc = tls_construct_end_of_early_data_ntls;
+        *mt = SSL3_MT_END_OF_EARLY_DATA;
+        break;
+
+    case TLS_ST_PENDING_EARLY_DATA_END:
+        *confunc = NULL;
+        *mt = SSL3_MT_DUMMY;
+        break;
+
+    case TLS_ST_CW_CERT:
+        *confunc = tls_construct_client_certificate_ntls;
+        *mt = SSL3_MT_CERTIFICATE;
+        break;
+
+    case TLS_ST_CW_KEY_EXCH:
+        *confunc = tls_construct_client_key_exchange_ntls;
+        *mt = SSL3_MT_CLIENT_KEY_EXCHANGE;
+        break;
+
+    case TLS_ST_CW_CERT_VRFY:
+        *confunc = tls_construct_cert_verify_ntls;
+        *mt = SSL3_MT_CERTIFICATE_VERIFY;
+        break;
+
+#if !defined(OPENSSL_NO_NEXTPROTONEG)
+    case TLS_ST_CW_NEXT_PROTO:
+        *confunc = tls_construct_next_proto_ntls;
+        *mt = SSL3_MT_NEXT_PROTO;
+        break;
+#endif
+    case TLS_ST_CW_FINISHED:
+        *confunc = tls_construct_finished_ntls;
+        *mt = SSL3_MT_FINISHED;
+        break;
+    }
+    return 1;
+}
+
+/*
+ * Returns the maximum allowed length for the current message that we are
+ * reading. Excludes the message header.
+ */
+size_t ossl_statem_client_max_message_size_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        return 0;
+
+    case TLS_ST_CR_SRVR_HELLO:
+        return SERVER_HELLO_MAX_LENGTH;
+
+    case TLS_ST_CR_CERT:
+        return s->max_cert_list;
+
+    case TLS_ST_CR_CERT_STATUS:
+        return SSL3_RT_MAX_PLAIN_LENGTH;
+
+    case TLS_ST_CR_KEY_EXCH:
+        return SERVER_KEY_EXCH_MAX_LENGTH;
+
+    case TLS_ST_CR_CERT_REQ:
+        /*
+         * Set to s->max_cert_list for compatibility with previous releases. In
+         * practice these messages can get quite long if servers are configured
+         * to provide a long list of acceptable CAs
+         */
+        return s->max_cert_list;
+
+    case TLS_ST_CR_SRVR_DONE:
+        return SERVER_HELLO_DONE_MAX_LENGTH;
+
+    case TLS_ST_CR_CHANGE:
+        return CCS_MAX_LENGTH;
+
+    case TLS_ST_CR_SESSION_TICKET:
+        return SESSION_TICKET_MAX_LENGTH_TLS12;
+
+    case TLS_ST_CR_FINISHED:
+        return FINISHED_MAX_LENGTH;
+
+    case TLS_ST_CR_ENCRYPTED_EXTENSIONS:
+        return ENCRYPTED_EXTENSIONS_MAX_LENGTH;
+
+    case TLS_ST_CR_KEY_UPDATE:
+        return KEY_UPDATE_MAX_LENGTH;
+    }
+}
+
+/*
+ * Process a message that the client has received from the server.
+ */
+MSG_PROCESS_RETURN ossl_statem_client_process_message_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+
+    case TLS_ST_CR_SRVR_HELLO:
+        return tls_process_server_hello_ntls(s, pkt);
+
+    case TLS_ST_CR_CERT:
+        return tls_process_server_certificate_ntls(s, pkt);
+
+    case TLS_ST_CR_CERT_STATUS:
+        return tls_process_cert_status_ntls(s, pkt);
+
+    case TLS_ST_CR_KEY_EXCH:
+        return tls_process_key_exchange_ntls(s, pkt);
+
+    case TLS_ST_CR_CERT_REQ:
+        return tls_process_certificate_request_ntls(s, pkt);
+
+    case TLS_ST_CR_SRVR_DONE:
+        return tls_process_server_done_ntls(s, pkt);
+
+    case TLS_ST_CR_CHANGE:
+        return tls_process_change_cipher_spec_ntls(s, pkt);
+
+    case TLS_ST_CR_SESSION_TICKET:
+        return tls_process_new_session_ticket_ntls(s, pkt);
+
+    case TLS_ST_CR_FINISHED:
+        return tls_process_finished_ntls(s, pkt);
+
+    case TLS_ST_CR_HELLO_REQ:
+        return tls_process_hello_req_ntls(s, pkt);
+    }
+}
+
+/*
+ * Perform any further processing required following the receipt of a message
+ * from the server
+ */
+WORK_STATE ossl_statem_client_post_process_message_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return WORK_ERROR;
+
+    case TLS_ST_CR_CERT:
+        return tls_post_process_server_certificate_ntls(s, wst);
+
+    case TLS_ST_CR_CERT_REQ:
+        return tls_prepare_client_certificate_ntls(s, wst);
+    }
+}
+
+int tls_construct_client_hello_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    unsigned char *p;
+    size_t sess_id_len;
+    int i, protverr;
+    SSL_SESSION *sess = s->session;
+    unsigned char *session_id;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /* Work out what SSL/TLS version to use */
+    protverr = ssl_set_client_hello_version_ntls(s);
+    if (protverr != 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, protverr);
+        return 0;
+    }
+
+    if (sess == NULL
+            || !ssl_version_supported_ntls(s, sess->ssl_version, NULL)
+            || !SSL_SESSION_is_resumable(sess)) {
+        if (s->hello_retry_request == SSL_HRR_NONE
+                && !ssl_get_new_session(s, 0)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+    /* else use the pre-loaded session */
+
+    p = s->s3.client_random;
+    i = (s->hello_retry_request == SSL_HRR_NONE);
+
+    if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3.client_random),
+                                   DOWNGRADE_NONE) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /*-
+     * version indicates the negotiated version: for example from
+     * an SSLv2/v3 compatible client hello). The client_version
+     * field is the maximum version we permit and it is also
+     * used in RSA encrypted premaster secrets. Some servers can
+     * choke if we initially report a higher version then
+     * renegotiate to a lower one in the premaster secret. This
+     * didn't happen with TLS 1.0 as most servers supported it
+     * but it can with TLS 1.1 or later if the server only supports
+     * 1.0.
+     *
+     * Possible scenario with previous logic:
+     *      1. Client hello indicates TLS 1.2
+     *      2. Server hello says TLS 1.0
+     *      3. RSA encrypted premaster secret uses 1.2.
+     *      4. Handshake proceeds using TLS 1.0.
+     *      5. Server sends hello request to renegotiate.
+     *      6. Client hello indicates TLS v1.0 as we now
+     *         know that is maximum server supports.
+     *      7. Server chokes on RSA encrypted premaster secret
+     *         containing version 1.0.
+     *
+     * For interoperability it should be OK to always use the
+     * maximum version we support in client hello and then rely
+     * on the checking of version to ensure the servers isn't
+     * being inconsistent: for example initially negotiating with
+     * TLS 1.0 and renegotiating with TLS 1.2. We do this by using
+     * client_version in client hello and not resetting it to
+     * the negotiated version.
+     *
+     * For TLS 1.3 we always set the ClientHello version to 1.2 and rely on the
+     * supported_versions extension for the real supported versions.
+     */
+    if (!WPACKET_put_bytes_u16(pkt, s->client_version)
+            || !WPACKET_memcpy(pkt, s->s3.client_random, SSL3_RANDOM_SIZE)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* Session ID */
+    session_id = s->session->session_id;
+    if (s->new_session || s->session->ssl_version == TLS1_3_VERSION) {
+        if (s->version == TLS1_3_VERSION
+                && (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0) {
+            sess_id_len = sizeof(s->tmp_session_id);
+            s->tmp_session_id_len = sess_id_len;
+            session_id = s->tmp_session_id;
+            if (s->hello_retry_request == SSL_HRR_NONE
+                    && RAND_bytes_ex(sctx->libctx, s->tmp_session_id,
+					                 sess_id_len, 0) <= 0) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+        } else {
+            sess_id_len = 0;
+        }
+    } else {
+        assert(s->session->session_id_length <= sizeof(s->session->session_id));
+        sess_id_len = s->session->session_id_length;
+        if (s->version == TLS1_3_VERSION) {
+            s->tmp_session_id_len = sess_id_len;
+            memcpy(s->tmp_session_id, s->session->session_id, sess_id_len);
+        }
+    }
+    if (!WPACKET_start_sub_packet_u8(pkt)
+            || (sess_id_len != 0 && !WPACKET_memcpy(pkt, session_id,
+                                                    sess_id_len))
+            || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* Ciphers supported */
+    if (!WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (!ssl_cipher_list_to_bytes(s, SSL_get_ciphers(SSL_CONNECTION_GET_SSL(s)), pkt)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* COMPRESSION */
+    if (!WPACKET_start_sub_packet_u8(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* Add the NULL method */
+    if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* TLS extensions */
+    if (!tls_construct_extensions_ntls(s, pkt, SSL_EXT_CLIENT_HELLO, NULL, 0)) {
+        /* SSLfatal() already called */
+        return 0;
+    }
+
+    return 1;
+}
+
+static int set_client_ciphersuite_ntls(SSL_CONNECTION *s, const unsigned char *cipherchars)
+{
+    STACK_OF(SSL_CIPHER) *sk;
+    const SSL_CIPHER *c;
+    int i;
+
+    c = ssl_get_cipher_by_char(s, cipherchars, 0);
+    if (c == NULL) {
+        /* unknown cipher */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CIPHER_RETURNED);
+        return 0;
+    }
+    /*
+     * If it is a disabled cipher we either didn't send it in client hello,
+     * or it's not allowed for the selected protocol. So we return an error.
+     */
+    if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK, 1)) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);
+        return 0;
+    }
+
+    sk = ssl_get_ciphers_by_id(s);
+    i = sk_SSL_CIPHER_find(sk, c);
+    if (i < 0) {
+        /* we did not say we would use this cipher */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);
+        return 0;
+    }
+
+    /*
+     * Depending on the session caching (internal/external), the cipher
+     * and/or cipher_id values may not be set. Make sure that cipher_id is
+     * set and use it for comparison.
+     */
+    if (s->session->cipher != NULL)
+        s->session->cipher_id = s->session->cipher->id;
+    if (s->hit && (s->session->cipher_id != c->id)) {
+        /*
+         * Prior to TLSv1.3 resuming a session always meant using the same
+         * ciphersuite.
+         */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                      SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
+        return 0;
+    }
+    s->s3.tmp.new_cipher = c;
+
+    return 1;
+}
+
+MSG_PROCESS_RETURN tls_process_server_hello_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    PACKET session_id, extpkt;
+    size_t session_id_len;
+    const unsigned char *cipherchars;
+    int hrr = 0;
+    unsigned int compression;
+    unsigned int sversion;
+    unsigned int context;
+    RAW_EXTENSION *extensions = NULL;
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    if (!PACKET_get_net_2(pkt, &sversion)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    /* load the server random */
+    if (s->version == TLS1_3_VERSION
+            && sversion == TLS1_2_VERSION
+            && PACKET_remaining(pkt) >= SSL3_RANDOM_SIZE
+            && memcmp(hrrrandom_ntls, PACKET_data(pkt), SSL3_RANDOM_SIZE) == 0) {
+        s->hello_retry_request = SSL_HRR_PENDING;
+        hrr = 1;
+        if (!PACKET_forward(pkt, SSL3_RANDOM_SIZE)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+    } else {
+        if (!PACKET_copy_bytes(pkt, s->s3.server_random, SSL3_RANDOM_SIZE)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+    }
+
+    /* Get the session-id. */
+    if (!PACKET_get_length_prefixed_1(pkt, &session_id)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+    session_id_len = PACKET_remaining(&session_id);
+    if (session_id_len > sizeof(s->session->session_id)
+        || session_id_len > SSL3_SESSION_ID_SIZE) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_SESSION_ID_TOO_LONG);
+        goto err;
+    }
+
+    if (!PACKET_get_bytes(pkt, &cipherchars, TLS_CIPHER_LEN)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    if (!PACKET_get_1(pkt, &compression)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    /* TLS extensions */
+    if (PACKET_remaining(pkt) == 0 && !hrr) {
+        PACKET_null_init(&extpkt);
+    } else if (!PACKET_as_length_prefixed_2(pkt, &extpkt)
+               || PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);
+        goto err;
+    }
+
+    if (!hrr) {
+        if (!tls_collect_extensions_ntls(s, &extpkt,
+                                    SSL_EXT_TLS1_2_SERVER_HELLO
+                                    | SSL_EXT_TLS1_3_SERVER_HELLO,
+                                    &extensions, NULL, 1)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+
+        if (!ssl_choose_client_version_ntls(s, sversion, extensions)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    }
+
+    if (hrr) {
+        if (compression != 0) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                     SSL_R_INVALID_COMPRESSION_ALGORITHM);
+            goto err;
+        }
+
+        if (session_id_len != s->tmp_session_id_len
+                || memcmp(PACKET_data(&session_id), s->tmp_session_id,
+                          session_id_len) != 0) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_SESSION_ID);
+            goto err;
+        }
+    }
+
+    if (hrr) {
+        if (!set_client_ciphersuite_ntls(s, cipherchars)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+
+        return tls_process_as_hello_retry_request(s, &extpkt);
+    }
+
+    /*
+     * Now we have chosen the version we need to check again that the extensions
+     * are appropriate for this version.
+     */
+    context = SSL_EXT_TLS1_2_SERVER_HELLO;
+    if (!tls_validate_all_contexts_ntls(s, context, extensions)) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);
+        goto err;
+    }
+
+    s->hit = 0;
+
+    /*
+    * Check if we can resume the session based on external pre-shared
+    * secret. EAP-FAST (RFC 4851) supports two types of session resumption.
+    * Resumption based on server-side state works with session IDs.
+    * Resumption based on pre-shared Protected Access Credentials (PACs)
+    * works by overriding the SessionTicket extension at the application
+    * layer, and does not send a session ID. (We do not know whether
+    * EAP-FAST servers would honour the session ID.) Therefore, the session
+    * ID alone is not a reliable indicator of session resumption, so we
+    * first check if we can resume, and later peek at the next handshake
+    * message to see if the server wants to resume.
+    */
+    if (s->version >= NTLS_VERSION
+            && s->ext.session_secret_cb != NULL && s->session->ext.tick) {
+        const SSL_CIPHER *pref_cipher = NULL;
+        /*
+         * s->session->master_key_length is a size_t, but this is an int for
+         * backwards compat reasons
+         */
+        int master_key_length;
+        master_key_length = sizeof(s->session->master_key);
+        if (s->ext.session_secret_cb(ussl, s->session->master_key,
+                                     &master_key_length,
+                                     NULL, &pref_cipher,
+                                     s->ext.session_secret_cb_arg)
+                                     && master_key_length > 0) {
+            s->session->master_key_length = master_key_length;
+            s->session->cipher = pref_cipher ?
+                pref_cipher : ssl_get_cipher_by_char(s, cipherchars, 0);
+        } else {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+    }
+
+    if (session_id_len != 0
+            && session_id_len == s->session->session_id_length
+            && memcmp(PACKET_data(&session_id), s->session->session_id,
+                      session_id_len) == 0)
+        s->hit = 1;
+
+    if (s->hit) {
+        if (s->sid_ctx_length != s->session->sid_ctx_length
+                || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {
+            /* actually a client application bug */
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                          SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
+            goto err;
+        }
+    } else {
+        /*
+         * If we were trying for session-id reuse but the server
+         * didn't resume, make a new SSL_SESSION.
+         * In the case of EAP-FAST and PAC, we do not send a session ID,
+         * so the PAC-based session secret is always preserved. It'll be
+         * overwritten if the server refuses resumption.
+         */
+        if (s->session->session_id_length > 0) {
+            ssl_tsan_counter(s->session_ctx, &s->session_ctx->stats.sess_miss);
+            if (!ssl_get_new_session(s, 0)) {
+                /* SSLfatal_ntls() already called */
+                goto err;
+            }
+        }
+
+        s->session->ssl_version = s->version;
+        /*
+         * In TLSv1.2 and below we save the session id we were sent so we can
+         * resume it later. In TLSv1.3 the session id we were sent is just an
+         * echo of what we originally sent in the ClientHello and should not be
+         * used for resumption.
+         */
+        s->session->session_id_length = session_id_len;
+        /* session_id_len could be 0 */
+        if (session_id_len > 0)
+            memcpy(s->session->session_id, PACKET_data(&session_id),
+                    session_id_len);
+    }
+
+    /* Session version and negotiated protocol version should match */
+    if (s->version != s->session->ssl_version) {
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION,
+                 SSL_R_SSL_SESSION_VERSION_MISMATCH);
+        goto err;
+    }
+    /*
+     * Now that we know the version, update the check to see if it's an allowed
+     * version.
+     */
+    s->s3.tmp.min_ver = s->version;
+    s->s3.tmp.max_ver = s->version;
+
+    if (!set_client_ciphersuite_ntls(s, cipherchars)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    if (compression != 0) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+		              SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+        goto err;
+    }
+    /*
+     * If compression is disabled we'd better not try to resume a session
+     * using compression.
+     */
+    if (s->session->compress_meth != 0) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_INCONSISTENT_COMPRESSION);
+        goto err;
+    }
+
+
+    if (!tls_parse_all_extensions_ntls(s, context, extensions, NULL, 0, 1)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    /*
+     * In TLSv1.3 we have some post-processing to change cipher state, otherwise
+     * we're done with this message
+     */
+    OPENSSL_free(extensions);
+    return MSG_PROCESS_CONTINUE_READING;
+ err:
+    OPENSSL_free(extensions);
+    return MSG_PROCESS_ERROR;
+}
+
+static MSG_PROCESS_RETURN tls_process_as_hello_retry_request(SSL_CONNECTION *s,
+                                                             PACKET *extpkt)
+{
+    RAW_EXTENSION *extensions = NULL;
+
+
+    if (!tls_collect_extensions_ntls(s, extpkt, SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST,
+                                &extensions, NULL, 1)
+            || !tls_parse_all_extensions_ntls(s, SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST,
+                                         extensions, NULL, 0, 1)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    OPENSSL_free(extensions);
+    extensions = NULL;
+
+    if (s->ext.tls13_cookie_len == 0 && s->s3.tmp.pkey != NULL) {
+        /*
+         * We didn't receive a cookie or a new key_share so the next
+         * ClientHello will not change
+         */
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_NO_CHANGE_FOLLOWING_HRR);
+        goto err;
+    }
+
+    /*
+     * Re-initialise the Transcript Hash. We're going to prepopulate it with
+     * a synthetic message_hash in place of ClientHello1.
+     */
+    if (!create_synthetic_message_hash_ntls(s, NULL, 0, NULL, 0)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    /*
+     * Add this message to the Transcript Hash. Normally this is done
+     * automatically prior to the message processing stage. However due to the
+     * need to create the synthetic message hash, we defer that step until now
+     * for HRR messages.
+     */
+    if (!ssl3_finish_mac(s, (unsigned char *)s->init_buf->data,
+                                s->init_num + SSL3_HM_HEADER_LENGTH)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    return MSG_PROCESS_FINISHED_READING;
+ err:
+    OPENSSL_free(extensions);
+    return MSG_PROCESS_ERROR;
+}
+
+/* prepare server cert verification by setting s->session->peer_chain from pkt */
+MSG_PROCESS_RETURN tls_process_server_certificate_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    unsigned long cert_list_len, cert_len;
+    X509 *x = NULL;
+    const unsigned char *certstart, *certbytes;
+    size_t chainidx;
+    unsigned int context = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if ((s->session->peer_chain = sk_X509_new_null()) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (context != 0
+        || !PACKET_get_net_3(pkt, &cert_list_len)
+        || PACKET_remaining(pkt) != cert_list_len
+        || PACKET_remaining(pkt) == 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+    for (chainidx = 0; PACKET_remaining(pkt); chainidx++) {
+        if (!PACKET_get_net_3(pkt, &cert_len)
+            || !PACKET_get_bytes(pkt, &certbytes, cert_len)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        certstart = certbytes;
+        x = X509_new_ex(sctx->libctx, sctx->propq);
+        if (x == NULL) {
+            SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+        if (d2i_X509(&x, (const unsigned char **)&certbytes,
+                     cert_len) == NULL) {
+            SSLfatal_ntls(s, SSL_AD_BAD_CERTIFICATE, ERR_R_ASN1_LIB);
+            goto err;
+        }
+
+        if (certbytes != (certstart + cert_len)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (!sk_X509_push(s->session->peer_chain, x)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+        x = NULL;
+    }
+
+# ifndef OPENSSL_NO_SM2
+    {
+        EVP_PKEY *pkey = NULL;
+        int n = sk_X509_num(s->session->peer_chain) - 1;
+
+        x = sk_X509_value(s->session->peer_chain, 0);
+        pkey = X509_get0_pubkey(x);
+
+        if (pkey != NULL && EVP_PKEY_is_a(pkey, "SM2")) {
+            while (n >= 0) {
+                X509 *cert = sk_X509_value(s->session->peer_chain, n);
+                ASN1_OCTET_STRING *sm2_id;
+                sm2_id = ASN1_OCTET_STRING_new();
+
+                if (sm2_id == NULL) {
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+                    goto err;
+                }
+
+                if (!ASN1_OCTET_STRING_set(sm2_id,
+                                           (const unsigned char *)CERTVRIFY_SM2_ID,
+                                           CERTVRIFY_SM2_ID_LEN)) {
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    ASN1_OCTET_STRING_free(sm2_id);
+                    goto err;
+                }
+
+                X509_set0_sm2_id(cert, sm2_id);
+                n--;
+            }
+        }
+    }
+# endif
+
+    return MSG_PROCESS_CONTINUE_PROCESSING;
+
+ err:
+    X509_free(x);
+    sk_X509_pop_free(s->session->peer_chain, X509_free);
+    s->session->peer_chain = NULL;
+    return MSG_PROCESS_ERROR;
+}
+
+/*
+ * Verify the s->session->peer_chain and check server cert type.
+ * On success set s->session->peer and s->session->verify_result.
+ * Else the peer certificate verification callback may request retry.
+ */
+WORK_STATE tls_post_process_server_certificate_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    X509 *x = NULL;
+    EVP_PKEY *pkey = NULL;
+    STACK_OF(X509) *sk = s->session->peer_chain;
+    const SSL_CERT_LOOKUP *clu;
+    size_t certidx;
+    int i, j;
+
+    if (s->rwstate == SSL_RETRY_VERIFY)
+        s->rwstate = SSL_NOTHING;
+
+    if (sk_X509_num(sk) >= 2) {
+        for (j = 0; j < 2; j++) {
+            if (j == 0)
+                sk_X509_push(sk, sk_X509_shift(sk));
+            if (j == 1)
+                sk_X509_unshift(sk, sk_X509_pop(sk));
+
+            i = ssl_verify_cert_chain(s, sk);
+            if (i > 0 && s->rwstate == SSL_RETRY_VERIFY) {
+                return WORK_MORE_A;
+            }
+
+            /*
+             * The documented interface is that SSL_VERIFY_PEER should be set in order
+             * for client side verification of the server certificate to take place.
+             * However, historically the code has only checked that *any* flag is set
+             * to cause server verification to take place. Use of the other flags makes
+             * no sense in client mode. An attempt to clean up the semantics was
+             * reverted because at least one application *only* set
+             * SSL_VERIFY_FAIL_IF_NO_PEER_CERT. Prior to the clean up this still caused
+             * server verification to take place, after the clean up it silently did
+             * nothing. SSL_CTX_set_verify()/SSL_set_verify() cannot validate the flags
+             * sent to them because they are void functions. Therefore, we now use the
+             * (less clean) historic behaviour of performing validation if any flag is
+             * set. The *documented* interface remains the same.
+             */
+            if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {
+                SSLfatal_ntls(s, ssl_x509err2alert_ntls(s->verify_result),
+                              SSL_R_CERTIFICATE_VERIFY_FAILED);
+                return WORK_ERROR;
+            }
+        }
+
+        ERR_clear_error();          /* but we keep s->verify_result */
+
+        /*
+         * Inconsistency alert: cert_chain does include the peer's certificate,
+         * which we don't include in statem_srvr.c
+         */
+        x = sk_X509_value(sk, 0);
+
+        pkey = X509_get0_pubkey(x);
+
+        if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                          SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
+            return WORK_ERROR;
+        }
+
+        if ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx, SSL_CONNECTION_GET_CTX(s))) == NULL) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                          SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            return WORK_ERROR;
+        }
+
+        /*
+         * Check certificate type is consistent with ciphersuite. For TLS 1.3
+         * skip check since TLS 1.3 ciphersuites can be used with any certificate
+         * type.
+         */
+        if ((clu->amask & s->s3.tmp.new_cipher->algorithm_auth) == 0) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CERTIFICATE_TYPE);
+            return WORK_ERROR;
+        }
+    } else {
+        if (s->verify_mode != SSL_VERIFY_NONE) {
+            SSLfatal_ntls(s, ssl_x509err2alert_ntls(s->verify_result),
+                          SSL_R_CERTIFICATE_VERIFY_FAILED);
+            return WORK_ERROR;
+        }
+    }
+
+    X509_free(s->session->peer);
+    X509_up_ref(x);
+    s->session->peer = x;
+    s->session->verify_result = s->verify_result;
+
+    return WORK_FINISHED_CONTINUE;
+}
+
+static int tls_process_ske_sm2dhe_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    PACKET encoded_pt;
+    unsigned int curve_type, curve_id;
+
+    if (!PACKET_get_1(pkt, &curve_type) || !PACKET_get_net_2(pkt, &curve_id)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);
+        return 0;
+    }
+
+    if ((s->s3.peer_tmp =
+            ssl_generate_param_group(s, OSSL_TLS_GROUP_ID_sm2)) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                      SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
+        return 0;
+    }
+
+    if (!PACKET_get_length_prefixed_1(pkt, &encoded_pt)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    if (EVP_PKEY_set1_encoded_public_key(s->s3.peer_tmp,
+                                         PACKET_data(&encoded_pt),
+                                         PACKET_remaining(&encoded_pt)) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_ECPOINT);
+        return 0;
+    }
+
+    /* Cache the agreed upon group in the SSL_SESSION */
+    s->session->kex_group = curve_id;
+    return 1;
+}
+
+MSG_PROCESS_RETURN tls_process_key_exchange_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    long alg_k;
+    EVP_PKEY *pkey = NULL;
+    EVP_MD_CTX *md_ctx = NULL;
+    EVP_PKEY_CTX *pctx = NULL;
+    PACKET save_param_start, signature;
+    unsigned char *buf = NULL;
+    size_t buflen;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;
+
+    save_param_start = *pkt;
+
+    EVP_PKEY_free(s->s3.peer_tmp);
+    s->s3.peer_tmp = NULL;
+
+    if (alg_k & SSL_kSM2DHE) {
+        if (!tls_process_ske_sm2dhe_ntls(s, pkt)) {
+            /* SSLfatal_ntls already called */
+            goto err;
+        }
+    }
+
+    /* get peer signing pkey */
+    pkey = X509_get0_pubkey(s->session->peer);
+
+    /* if it was signed, check the signature */
+    if (pkey != NULL) {
+        PACKET params;
+        const EVP_MD *md = NULL;
+        unsigned char *tbs;
+        size_t tbslen;
+        X509 *x509;
+        int rv;
+
+        if (alg_k & SSL_kSM2DHE) {
+		    /*
+             * |pkt| now points to the beginning of the signature, so the difference
+             * equals the length of the parameters.
+             */
+            if (!PACKET_get_sub_packet(&save_param_start, &params,
+                                       PACKET_remaining(&save_param_start) -
+                                       PACKET_remaining(pkt))) {
+                SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+        } else if (alg_k & (SSL_kSM2 | SSL_kRSA)) {
+            /* get peer's encryption cert */
+            x509 = sk_X509_value(s->session->peer_chain, 1);
+            if (x509 == NULL
+                || (buf = x509_to_asn1_ntls(x509, &buflen)) == NULL
+                || !PACKET_buf_init(&params, buf, buflen)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+                goto err;
+            }
+        } else {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        if (!tls1_set_peer_legacy_sigalg(s, pkey)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        if (!tls1_lookup_md(sctx, s->s3.tmp.peer_sigalg, &md)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                          SSL_R_NO_SUITABLE_DIGEST_ALGORITHM);
+            goto err;
+        }
+
+        if (!PACKET_get_length_prefixed_2(pkt, &signature)
+            || PACKET_remaining(pkt) != 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        md_ctx = EVP_MD_CTX_new();
+        if (md_ctx == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+
+        if (EVP_DigestVerifyInit_ex(md_ctx, &pctx,
+                                    md == NULL ? NULL : EVP_MD_get0_name(md),
+                                    sctx->libctx, sctx->propq, pkey,
+                                    NULL) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+            goto err;
+        }
+
+        if (EVP_PKEY_is_a(pkey, "SM2")) {
+            if (EVP_PKEY_CTX_set1_id(pctx, SM2_DEFAULT_ID,
+                                     SM2_DEFAULT_ID_LEN) <= 0) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+                goto err;
+            }
+        }
+
+        tbslen = construct_key_exchange_tbs_ntls(s, &tbs, PACKET_data(&params),
+                                                 PACKET_remaining(&params));
+        if (tbslen == 0) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+        OPENSSL_free(buf);
+        buf = NULL;
+
+        rv = EVP_DigestVerify(md_ctx, PACKET_data(&signature),
+                              PACKET_remaining(&signature), tbs, tbslen);
+        OPENSSL_free(tbs);
+        if (rv <= 0) {
+            SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_BAD_SIGNATURE);
+            goto err;
+        }
+        EVP_MD_CTX_free(md_ctx);
+        md_ctx = NULL;
+    } else {
+        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_MISSING_SIGNING_CERT);
+        goto err;
+    }
+
+    return MSG_PROCESS_CONTINUE_READING;
+ err:
+    OPENSSL_free(buf);
+    EVP_MD_CTX_free(md_ctx);
+    return MSG_PROCESS_ERROR;
+}
+
+MSG_PROCESS_RETURN tls_process_certificate_request_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    /* Clear certificate validity flags */
+    if (s->s3.tmp.valid_flags != NULL)
+        memset(s->s3.tmp.valid_flags, 0, s->ssl_pkey_num * sizeof(uint32_t));
+    else
+        s->s3.tmp.valid_flags = OPENSSL_zalloc(s->ssl_pkey_num * sizeof(uint32_t));
+
+    /* Give up for good if allocation didn't work */
+    if (s->s3.tmp.valid_flags == NULL)
+        return 0;
+
+    PACKET ctypes;
+
+    /* get the certificate types */
+    if (!PACKET_get_length_prefixed_1(pkt, &ctypes)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (!PACKET_memdup(&ctypes, &s->s3.tmp.ctype, &s->s3.tmp.ctype_len)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (SSL_USE_SIGALGS(s)) {
+        PACKET sigalgs;
+
+        if (!PACKET_get_length_prefixed_2(pkt, &sigalgs)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            return MSG_PROCESS_ERROR;
+        }
+
+        /*
+         * Despite this being for certificates, preserve compatibility
+         * with pre-TLS 1.3 and use the regular sigalgs field.
+         */
+        if (!tls1_save_sigalgs(s, &sigalgs, 0)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+				              SSL_R_SIGNATURE_ALGORITHMS_ERROR);
+            return MSG_PROCESS_ERROR;
+        }
+        if (!tls1_process_sigalgs(s)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            return MSG_PROCESS_ERROR;
+        }
+    }
+
+    /* get the CA RDNs */
+    if (!parse_ca_names_ntls(s, pkt)) {
+        /* SSLfatal_ntls() already called */
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    /* we should setup a certificate to return.... */
+    s->s3.tmp.cert_req = 1;
+
+    return MSG_PROCESS_CONTINUE_PROCESSING;
+}
+
+MSG_PROCESS_RETURN tls_process_new_session_ticket_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    unsigned int ticklen;
+    unsigned long ticket_lifetime_hint, age_add = 0;
+    unsigned int sess_len;
+    RAW_EXTENSION *exts = NULL;
+    PACKET nonce;
+    EVP_MD *sha256 = NULL;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    PACKET_null_init(&nonce);
+
+    if (!PACKET_get_net_4(pkt, &ticket_lifetime_hint)
+        || !PACKET_get_net_2(pkt, &ticklen)
+        || (PACKET_remaining(pkt) != ticklen)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    /*
+     * Server is allowed to change its mind (in <=TLSv1.2) and send an empty
+     * ticket. We already checked this TLSv1.3 case above, so it should never
+     * be 0 here in that instance
+     */
+    if (ticklen == 0)
+        return MSG_PROCESS_CONTINUE_READING;
+
+    /*
+     * Sessions must be immutable once they go into the session cache. Otherwise
+     * we can get multi-thread problems. Therefore we don't "update" sessions,
+     * we replace them with a duplicate. In TLSv1.3 we need to do this every
+     * time a NewSessionTicket arrives because those messages arrive
+     * post-handshake and the session may have already gone into the session
+     * cache.
+     */
+    if (s->session->session_id_length > 0) {
+        SSL_SESSION *new_sess;
+
+        /*
+         * We reused an existing session, so we need to replace it with a new
+         * one
+         */
+        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+
+        if ((s->session_ctx->session_cache_mode & SSL_SESS_CACHE_CLIENT) != 0) {
+            /*
+             * In TLSv1.2 and below the arrival of a new tickets signals that
+             * any old ticket we were using is now out of date, so we remove the
+             * old session from the cache. We carry on if this fails
+             */
+            SSL_CTX_remove_session(s->session_ctx, s->session);
+        }
+
+        SSL_SESSION_free(s->session);
+        s->session = new_sess;
+    }
+
+    s->session->time = ossl_time_now();
+    ssl_session_calculate_timeout(s->session);
+
+    OPENSSL_free(s->session->ext.tick);
+    s->session->ext.tick = NULL;
+    s->session->ext.ticklen = 0;
+
+    s->session->ext.tick = OPENSSL_malloc(ticklen);
+    if (s->session->ext.tick == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    if (!PACKET_copy_bytes(pkt, s->session->ext.tick, ticklen)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    s->session->ext.tick_lifetime_hint = ticket_lifetime_hint;
+    s->session->ext.tick_age_add = age_add;
+    s->session->ext.ticklen = ticklen;
+
+    /*
+     * There are two ways to detect a resumed ticket session. One is to set
+     * an appropriate session ID and then the server must return a match in
+     * ServerHello. This allows the normal client session ID matching to work
+     * and we know much earlier that the ticket has been accepted. The
+     * other way is to set zero length session ID when the ticket is
+     * presented and rely on the handshake to determine session resumption.
+     * We choose the former approach because this fits in with assumptions
+     * elsewhere in OpenSSL. The session ID is set to the SHA256 hash of the
+     * ticket.
+     */
+    sha256 = EVP_MD_fetch(sctx->libctx, "SHA2-256", sctx->propq);
+    if (sha256 == NULL) {
+        /* Error is already recorded */
+        SSLfatal_alert_ntls(s, SSL_AD_INTERNAL_ERROR);
+        goto err;
+    }
+    /*
+     * We use sess_len here because EVP_Digest expects an int
+     * but s->session->session_id_length is a size_t
+     */
+    if (!EVP_Digest(s->session->ext.tick, ticklen,
+                    s->session->session_id, &sess_len,
+                    sha256, NULL)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+    EVP_MD_free(sha256);
+    sha256 = NULL;
+    s->session->session_id_length = sess_len;
+    s->session->not_resumable = 0;
+
+    return MSG_PROCESS_CONTINUE_READING;
+ err:
+    EVP_MD_free(sha256);
+    OPENSSL_free(exts);
+    return MSG_PROCESS_ERROR;
+}
+
+/*
+ * In TLSv1.3 this is called from the extensions code, otherwise it is used to
+ * parse a separate message. Returns 1 on success or 0 on failure
+ */
+int tls_process_cert_status_body_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    size_t resplen;
+    unsigned int type;
+
+    if (!PACKET_get_1(pkt, &type)
+        || type != TLSEXT_STATUSTYPE_ocsp) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_UNSUPPORTED_STATUS_TYPE);
+        return 0;
+    }
+    if (!PACKET_get_net_3_len(pkt, &resplen)
+        || PACKET_remaining(pkt) != resplen) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+    s->ext.ocsp.resp = OPENSSL_malloc(resplen);
+    if (s->ext.ocsp.resp == NULL) {
+        s->ext.ocsp.resp_len = 0;
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    s->ext.ocsp.resp_len = resplen;
+    if (!PACKET_copy_bytes(pkt, s->ext.ocsp.resp, resplen)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    return 1;
+}
+
+
+MSG_PROCESS_RETURN tls_process_cert_status_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    if (!tls_process_cert_status_body_ntls(s, pkt)) {
+        /* SSLfatal_ntls() already called */
+        return MSG_PROCESS_ERROR;
+    }
+
+    return MSG_PROCESS_CONTINUE_READING;
+}
+
+/*
+ * Perform miscellaneous checks and processing after we have received the
+ * server's initial flight. In TLS1.3 this is after the Server Finished message.
+ * In <=TLS1.2 this is after the ServerDone message. Returns 1 on success or 0
+ * on failure.
+ */
+int tls_process_initial_server_flight_ntls(SSL_CONNECTION *s)
+{
+    /*
+     * at this point we check that we have the required stuff from
+     * the server
+     */
+    if (!ssl3_check_cert_and_algorithm_ntls(s)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    /*
+     * Call the ocsp status callback if needed. The |ext.ocsp.resp| and
+     * |ext.ocsp.resp_len| values will be set if we actually received a status
+     * message, or NULL and -1 otherwise
+     */
+    if (s->ext.status_type != TLSEXT_STATUSTYPE_nothing
+            && sctx->ext.status_cb != NULL) {
+        int ret = sctx->ext.status_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                        sctx->ext.status_arg);
+
+        if (ret == 0) {
+            SSLfatal_ntls(s, SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE,
+                          SSL_R_INVALID_STATUS_RESPONSE);
+            return 0;
+        }
+        if (ret < 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                          SSL_R_OCSP_CALLBACK_FAILURE);
+            return 0;
+        }
+    }
+#ifndef OPENSSL_NO_CT
+    if (s->ct_validation_callback != NULL) {
+        /* Note we validate the SCTs whether or not we abort on error */
+        if (!ssl_validate_ct(s) && (s->verify_mode & SSL_VERIFY_PEER)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+#endif
+
+    return 1;
+}
+
+MSG_PROCESS_RETURN tls_process_server_done_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    if (PACKET_remaining(pkt) > 0) {
+        /* should contain no data */
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (!tls_process_initial_server_flight_ntls(s)) {
+        /* SSLfatal_ntls() already called */
+        return MSG_PROCESS_ERROR;
+    }
+
+    return MSG_PROCESS_FINISHED_READING;
+}
+
+/* construct encrypted pre master secret for kRSA or kSM2 */
+static int tls_construct_cke_pms_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned long alg_k)
+{
+    unsigned char *encbytes1, *encbytes2;
+    EVP_PKEY *pkey = NULL;
+    EVP_PKEY_CTX *pctx = NULL;
+    size_t enclen;
+    unsigned char *pms = NULL;
+    size_t pmslen = 0;
+    X509 *x509;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /*
+     * for client side, s->session->peer == s->session->peer_chain[0] is
+     * the server signing certificate.
+     *
+     * s->session->peer_chain[1] is the server encryption certificate
+     */
+    if (s->session->peer_chain == NULL
+            || (x509 = sk_X509_value(s->session->peer_chain, 1)) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    pkey = X509_get0_pubkey(x509);
+    if (((alg_k & SSL_kRSA) && !EVP_PKEY_is_a(pkey, "RSA"))
+            || ((alg_k & SSL_kSM2) && !EVP_PKEY_is_a(pkey, "SM2"))) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    pmslen = SSL_MAX_MASTER_KEY_LENGTH;
+    pms = OPENSSL_malloc(pmslen);
+    if (pms == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    pms[0] = s->client_version >> 8;
+    pms[1] = s->client_version & 0xff;
+    if (RAND_bytes_ex(SSL_CONNECTION_GET_CTX(s)->libctx, pms + 2, pmslen - 2, 0) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    pctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, pkey, sctx->propq);
+    if (pctx == NULL || EVP_PKEY_encrypt_init(pctx) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    if ((alg_k & SSL_kRSA)
+            && EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PADDING) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    if (EVP_PKEY_encrypt(pctx, NULL, &enclen, pms, pmslen) <= 0
+            || !WPACKET_sub_reserve_bytes_u16(pkt, enclen, &encbytes1)
+            || EVP_PKEY_encrypt(pctx, encbytes1, &enclen, pms, pmslen) <= 0
+			|| !WPACKET_sub_allocate_bytes_u16(pkt, enclen, &encbytes2)
+			|| encbytes1 != encbytes2) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_RSA_ENCRYPT);
+        goto err;
+    }
+    EVP_PKEY_CTX_free(pctx);
+    pctx = NULL;
+    /* Log the premaster secret, if logging is enabled. */
+    if ((alg_k & SSL_kRSA)
+        && !ssl_log_rsa_client_key_exchange(s, encbytes1, enclen, pms, pmslen))
+    {
+        /* SSLfatal() already called */
+        goto err;
+    }
+
+    s->s3.tmp.pms = pms;
+    s->s3.tmp.pmslen = pmslen;
+
+    return 1;
+ err:
+    OPENSSL_clear_free(pms, pmslen);
+    EVP_PKEY_CTX_free(pctx);
+
+    return 0;
+}
+
+static int tls_construct_cke_sm2dhe_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    unsigned char *encodedPoint = NULL;
+    size_t encoded_pt_len = 0;
+    EVP_PKEY *ckey = NULL, *skey = NULL;
+    int ret = 0;
+    int curve_id;
+
+    skey = s->s3.peer_tmp;
+    if (skey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    ckey = ssl_generate_pkey(s, skey);
+    if (ckey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (ssl_derive_ntls(s, ckey, skey, 0) == 0) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    /* Generate encoding of client key */
+    encoded_pt_len = EVP_PKEY_get1_encoded_public_key(ckey, &encodedPoint);
+    if (encoded_pt_len == 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
+        goto err;
+    }
+
+    curve_id = tls1_shared_group(s, -2);
+
+    if (!WPACKET_put_bytes_u8(pkt, NAMED_CURVE_TYPE)
+            || !WPACKET_put_bytes_u8(pkt, 0)
+            || !WPACKET_put_bytes_u8(pkt, curve_id)
+            || !WPACKET_sub_memcpy_u8(pkt, encodedPoint, encoded_pt_len)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    ret = 1;
+ err:
+    OPENSSL_free(encodedPoint);
+    EVP_PKEY_free(ckey);
+    return ret;
+}
+
+int tls_construct_client_key_exchange_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    unsigned long alg_k;
+
+    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;
+
+    if (alg_k & (SSL_kRSA | SSL_kSM2)) {
+        if (!tls_construct_cke_pms_ntls(s, pkt, alg_k)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    } else if (alg_k & (SSL_kSM2DHE)) {
+        if (!tls_construct_cke_sm2dhe_ntls(s, pkt)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    } else {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    return 1;
+err:
+    OPENSSL_clear_free(s->s3.tmp.pms, s->s3.tmp.pmslen);
+    s->s3.tmp.pms = NULL;
+    s->s3.tmp.pmslen = 0;
+    return 0;
+}
+
+int tls_client_key_exchange_post_work_ntls(SSL_CONNECTION *s)
+{
+    unsigned char *pms = NULL;
+    size_t pmslen = 0;
+
+    pms = s->s3.tmp.pms;
+    pmslen = s->s3.tmp.pmslen;
+
+    if (pms == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    if (!ssl_generate_master_secret(s, pms, pmslen, 1)) {
+        /* SSLfatal_ntls() already called */
+        /* ssl_generate_master_secret frees the pms even on error */
+        pms = NULL;
+        pmslen = 0;
+        goto err;
+    }
+    pms = NULL;
+    pmslen = 0;
+
+    return 1;
+ err:
+    OPENSSL_clear_free(pms, pmslen);
+    s->s3.tmp.pms = NULL;
+    s->s3.tmp.pmslen = 0;
+    return 0;
+}
+
+/*
+ * Check a certificate can be used for client authentication. Currently check
+ * cert exists, if we have a suitable digest for TLS 1.2 if static DH client
+ * certificates can be used and optionally checks suitability for Suite B.
+ */
+static int ssl3_check_client_certificate_ntls(SSL_CONNECTION *s)
+{
+    /* If no suitable signature algorithm can't use certificate */
+    if (!tls_choose_sigalg_ntls(s, 0) || s->s3.tmp.sigalg == NULL)
+        return 0;
+
+    /*
+     * If strict mode check suitability of chain before using it. This also
+     * adjusts suite B digest if necessary.
+     */
+    if (s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT &&
+        !tls1_check_chain(s, NULL, NULL, NULL, -2))
+        return 0;
+    return 1;
+}
+
+WORK_STATE tls_prepare_client_certificate_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    X509 *x509 = NULL;
+    EVP_PKEY *pkey = NULL;
+    int i;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    if (wst == WORK_MORE_A) {
+        /* Let cert callback update client certificates if required */
+        if (s->cert->cert_cb) {
+            i = s->cert->cert_cb(ssl, s->cert->cert_cb_arg);
+            if (i < 0) {
+                s->rwstate = SSL_X509_LOOKUP;
+                return WORK_MORE_A;
+            }
+            if (i == 0) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_CALLBACK_FAILED);
+                return WORK_ERROR;
+            }
+            s->rwstate = SSL_NOTHING;
+        }
+        if (ssl3_check_client_certificate_ntls(s)) {
+            if (s->post_handshake_auth == SSL_PHA_REQUESTED) {
+                return WORK_FINISHED_STOP;
+            }
+            return WORK_FINISHED_CONTINUE;
+        }
+
+        /* Fall through to WORK_MORE_B */
+        wst = WORK_MORE_B;
+    }
+
+    /* We need to get a client cert */
+    if (wst == WORK_MORE_B) {
+        /*
+         * If we get an error, we need to ssl->rwstate=SSL_X509_LOOKUP;
+         * return(-1); We then get retied later
+         */
+        i = ssl_do_client_cert_cb_ntls(s, &x509, &pkey);
+        if (i < 0) {
+            s->rwstate = SSL_X509_LOOKUP;
+            return WORK_MORE_B;
+        }
+        s->rwstate = SSL_NOTHING;
+        if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {
+            if (!SSL_use_certificate(ssl, x509) || !SSL_use_PrivateKey(ssl, pkey))
+                i = 0;
+        } else if (i == 1) {
+            i = 0;
+            ERR_raise(ERR_LIB_SSL, SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
+        }
+
+        X509_free(x509);
+        EVP_PKEY_free(pkey);
+        if (i && !ssl3_check_client_certificate_ntls(s))
+            i = 0;
+        if (i == 0) {
+            s->s3.tmp.cert_req = 2;
+            if (!ssl3_digest_cached_records(s, 0)) {
+                /* SSLfatal_ntls() already called */
+                return WORK_ERROR;
+            }
+        }
+
+        if (s->post_handshake_auth == SSL_PHA_REQUESTED)
+            return WORK_FINISHED_STOP;
+        return WORK_FINISHED_CONTINUE;
+    }
+
+    /* Shouldn't ever get here */
+    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+    return WORK_ERROR;
+}
+
+int tls_construct_client_certificate_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    if (!ssl3_output_cert_chain_ntls(s, pkt,
+            (s->s3.tmp.cert_req == 2) ? NULL : s->s3.tmp.sign_cert,
+            (s->s3.tmp.cert_req == 2) ? NULL : s->s3.tmp.enc_cert)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    return 1;
+}
+
+int ssl3_check_cert_and_algorithm_ntls(SSL_CONNECTION *s)
+{
+    const SSL_CERT_LOOKUP *clu;
+    size_t idx;
+    long alg_k, alg_a;
+
+    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;
+    alg_a = s->s3.tmp.new_cipher->algorithm_auth;
+
+    /* we don't have a certificate */
+    if (!(alg_a & SSL_aCERT))
+        return 1;
+
+    /* This is the passed certificate */
+    clu = ssl_cert_lookup_by_pkey(X509_get0_pubkey(s->session->peer),
+                                  &idx,
+                                  SSL_CONNECTION_GET_CTX(s));
+
+    /* Check certificate is recognised and suitable for cipher */
+    if (clu == NULL || (alg_a & clu->amask) == 0) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_SIGNING_CERT);
+        return 0;
+    }
+
+    if (clu->amask & SSL_aECDSA) {
+        if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s))
+            return 1;
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_ECC_CERT);
+        return 0;
+    }
+
+    if (alg_k & (SSL_kRSA | SSL_kRSAPSK) && idx != SSL_PKEY_RSA) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+		              SSL_R_MISSING_RSA_ENCRYPTING_CERT);
+        return 0;
+    }
+
+    if ((alg_k & SSL_kDHE) && (s->s3.peer_tmp == NULL)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+int tls_construct_next_proto_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    size_t len, padding_len;
+    unsigned char *padding = NULL;
+
+    len = s->ext.npn_len;
+    padding_len = 32 - ((len + 2) % 32);
+
+    if (!WPACKET_sub_memcpy_u8(pkt, s->ext.npn, len)
+            || !WPACKET_sub_allocate_bytes_u8(pkt, padding_len, &padding)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    memset(padding, 0, padding_len);
+
+    return 1;
+}
+#endif
+
+MSG_PROCESS_RETURN tls_process_hello_req_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    if (PACKET_remaining(pkt) > 0) {
+        /* should contain no data */
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if ((s->options & SSL_OP_NO_RENEGOTIATION)) {
+        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
+        return MSG_PROCESS_FINISHED_READING;
+    }
+
+    /*
+     * This is a historical discrepancy (not in the RFC) maintained for
+     * compatibility reasons. If a TLS client receives a HelloRequest it will
+     * attempt an abbreviated handshake. However if a DTLS client receives a
+     * HelloRequest it will do a full handshake. Either behaviour is reasonable
+     * but doing one for TLS and another for DTLS is odd.
+     */
+    SSL_renegotiate_abbreviated(ssl);
+
+    return MSG_PROCESS_FINISHED_READING;
+}
+
+int ssl_do_client_cert_cb_ntls(SSL_CONNECTION *s, X509 **px509, EVP_PKEY **ppkey)
+{
+    int i = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+#ifndef OPENSSL_NO_ENGINE
+    if (sctx->client_cert_engine) {
+        i = tls_engine_load_ssl_client_cert(s, px509, ppkey);
+        if (i != 0)
+            return i;
+    }
+#endif
+    if (sctx->client_cert_cb)
+        i = sctx->client_cert_cb(SSL_CONNECTION_GET_USER_SSL(s), px509, ppkey);
+    return i;
+}
+
+int ssl_cipher_list_to_bytes(SSL_CONNECTION *s, STACK_OF(SSL_CIPHER) *sk, WPACKET *pkt)
+{
+    int i;
+    size_t totlen = 0, len, maxlen, maxverok = 0;
+    int empty_reneg_info_scsv = !s->renegotiate;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    /* Set disabled masks for this session */
+    if (!ssl_set_client_disabled(s)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_NO_PROTOCOLS_AVAILABLE);
+        return 0;
+    }
+
+    if (sk == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
+# if OPENSSL_MAX_TLS1_2_CIPHER_LENGTH < 6
+#  error Max cipher length too short
+# endif
+    /*
+     * Some servers hang if client hello > 256 bytes as hack workaround
+     * chop number of supported ciphers to keep it well below this if we
+     * use TLS v1.2
+     */
+    if (TLS1_get_version(s) >= TLS1_2_VERSION)
+        maxlen = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
+    else
+#endif
+        /* Maximum length that can be stored in 2 bytes. Length must be even */
+        maxlen = 0xfffe;
+
+    if (empty_reneg_info_scsv)
+        maxlen -= 2;
+    if (s->mode & SSL_MODE_SEND_FALLBACK_SCSV)
+        maxlen -= 2;
+
+    for (i = 0; i < sk_SSL_CIPHER_num(sk) && totlen < maxlen; i++) {
+        const SSL_CIPHER *c;
+
+        c = sk_SSL_CIPHER_value(sk, i);
+        /* Skip disabled ciphers */
+        if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_SUPPORTED, 0))
+            continue;
+
+        if (!ssl->method->put_cipher_by_char(c, pkt, &len)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+
+        /* Sanity check that the maximum version we offer has ciphers enabled */
+        if (!maxverok) {
+            if (c->max_tls >= s->s3.tmp.max_ver
+                    && c->min_tls <= s->s3.tmp.max_ver)
+                maxverok = 1;
+
+        }
+
+        totlen += len;
+    }
+
+    if (totlen == 0 || !maxverok) {
+        const char *maxvertext =
+            !maxverok
+            ? "No ciphers enabled for max supported SSL/TLS version"
+            : NULL;
+
+        SSLfatal_data_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_NO_CIPHERS_AVAILABLE,
+                      maxvertext);
+        return 0;
+    }
+
+    if (totlen != 0) {
+        if (empty_reneg_info_scsv) {
+            static SSL_CIPHER scsv = {
+                0, NULL, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
+            };
+            if (!ssl->method->put_cipher_by_char(&scsv, pkt, &len)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+        }
+        if (s->mode & SSL_MODE_SEND_FALLBACK_SCSV) {
+            static SSL_CIPHER scsv = {
+                0, NULL, NULL, SSL3_CK_FALLBACK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
+            };
+            if (!ssl->method->put_cipher_by_char(&scsv, pkt, &len)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+
+int tls_construct_end_of_early_data_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    if (s->early_data_state != SSL_EARLY_DATA_WRITE_RETRY
+            && s->early_data_state != SSL_EARLY_DATA_FINISHED_WRITING) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        return 0;
+    }
+
+    s->early_data_state = SSL_EARLY_DATA_FINISHED_WRITING;
+    return 1;
+}
Index: b/ssl/statem_ntls/ntls_statem_lib.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_statem_lib.c
@@ -0,0 +1,2127 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include <limits.h>
+#include <string.h>
+#include <stdio.h>
+#include <openssl/core_names.h>
+#include "ntls_ssl_local.h"
+#include "ntls_statem_local.h"
+#include "internal/cryptlib.h"
+#include <openssl/buffer.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/trace.h>
+#include "internal/sockets.h"
+
+static int ssl_add_cert_to_wpacket_ntls(SSL_CONNECTION *s, WPACKET *pkt, X509 *x);
+/*
+ * Map error codes to TLS/SSL alart types.
+ */
+typedef struct x509err2alert_st {
+    int x509err;
+    int alert;
+} X509ERR2ALERT;
+
+/* Fixed value used in the ServerHello random field to identify an HRR */
+const unsigned char hrrrandom_ntls[] = {
+    0xcf, 0x21, 0xad, 0x74, 0xe5, 0x9a, 0x61, 0x11, 0xbe, 0x1d, 0x8c, 0x02,
+    0x1e, 0x65, 0xb8, 0x91, 0xc2, 0xa2, 0x11, 0x16, 0x7a, 0xbb, 0x8c, 0x5e,
+    0x07, 0x9e, 0x09, 0xe2, 0xc8, 0xa8, 0x33, 0x9c
+};
+
+/*
+ * send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or
+ * SSL3_RT_CHANGE_CIPHER_SPEC)
+ */
+int ssl3_do_write_ntls(SSL_CONNECTION *s, int type)
+{
+    int ret;
+    size_t written = 0;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    ret = ssl3_write_bytes(ssl, type, &s->init_buf->data[s->init_off],
+                           s->init_num, &written);
+    if (ret < 0)
+        return -1;
+    if (type == SSL3_RT_HANDSHAKE)
+        /*
+         * should not be done for 'Hello Request's, but in that case we'll
+         * ignore the result anyway
+         */
+        if (!ssl3_finish_mac(s,
+                             (unsigned char *)&s->init_buf->data[s->init_off],
+                             written))
+            return -1;
+    if (written == s->init_num) {
+        if (s->msg_callback)
+            s->msg_callback(1, s->version, type, s->init_buf->data,
+                            (size_t)(s->init_off + s->init_num), ussl,
+                            s->msg_callback_arg);
+        return 1;
+    }
+    s->init_off += written;
+    s->init_num -= written;
+    return 0;
+}
+
+int tls_close_construct_packet_ntls(SSL_CONNECTION *s, WPACKET *pkt, int htype)
+{
+    size_t msglen;
+
+    if ((htype != SSL3_MT_CHANGE_CIPHER_SPEC && !WPACKET_close(pkt))
+            || !WPACKET_get_length(pkt, &msglen)
+            || msglen > INT_MAX)
+        return 0;
+    s->init_num = (int)msglen;
+    s->init_off = 0;
+
+    return 1;
+}
+
+int tls_setup_handshake_ntls(SSL_CONNECTION *s)
+{
+    int ver_min, ver_max, ok;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (!ssl3_init_finished_mac(s)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    /* Reset any extension flags */
+    memset(s->ext.extflags, 0, sizeof(s->ext.extflags));
+
+    if (ssl_get_min_max_version(s, &ver_min, &ver_max, NULL) != 0) {
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_NO_PROTOCOLS_AVAILABLE);
+        return 0;
+    }
+    ok = 0;
+    if (s->server) {
+        STACK_OF(SSL_CIPHER) *ciphers = SSL_get_ciphers(ssl);
+        int i;
+
+        /*
+         * Sanity check that the maximum version we accept has ciphers
+         * enabled. For clients we do this check during construction of the
+         * ClientHello.
+         */
+        for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
+            const SSL_CIPHER *c = sk_SSL_CIPHER_value(ciphers, i);
+
+            if (ver_max >= c->min_tls && ver_max <= c->max_tls) {
+                ok = 1;
+            }
+            if (ok)
+                break;
+        }
+        if (!ok) {
+            SSLfatal_data_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                          SSL_R_NO_CIPHERS_AVAILABLE,
+                          "No ciphers enabled for max supported "
+                          "SSL/TLS version");
+            return 0;
+        }
+        if (SSL_IS_FIRST_HANDSHAKE(s)) {
+            /* N.B. s->session_ctx == s->ctx here */
+            ssl_tsan_counter(s->session_ctx, &s->session_ctx->stats.sess_accept);
+        } else {
+            /* N.B. s->ctx may not equal s->session_ctx */
+            ssl_tsan_counter(sctx, &sctx->stats.sess_accept_renegotiate);
+
+            s->s3.tmp.cert_request = 0;
+        }
+    } else {
+        if (SSL_IS_FIRST_HANDSHAKE(s))
+            ssl_tsan_counter(s->session_ctx, &s->session_ctx->stats.sess_connect);
+        else
+            ssl_tsan_counter(s->session_ctx,
+                         &s->session_ctx->stats.sess_connect_renegotiate);
+
+        /* mark client_random uninitialized */
+        memset(s->s3.client_random, 0, sizeof(s->s3.client_random));
+        s->hit = 0;
+
+        s->s3.tmp.cert_req = 0;
+
+    }
+
+    return 1;
+}
+
+/*
+ * Size of the to-be-signed TLS13 data, without the hash size itself:
+ * 64 bytes of value 32, 33 context bytes, 1 byte separator
+ */
+#define TLS13_TBS_START_SIZE            64
+#define TLS13_TBS_PREAMBLE_SIZE         (TLS13_TBS_START_SIZE + 33 + 1)
+
+static int get_cert_verify_tbs_data_ntls(SSL_CONNECTION *s, void **hdata, size_t *hdatalen)
+{
+    size_t retlen;
+    long retlen_l;
+
+    retlen = retlen_l = BIO_get_mem_data(s->s3.handshake_buffer, hdata);
+    if (retlen_l <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    *hdatalen = retlen;
+
+    return 1;
+}
+
+int tls_construct_cert_verify_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    EVP_PKEY *pkey = NULL;
+    const EVP_MD *md = NULL;
+    EVP_MD_CTX *mctx = NULL;
+    EVP_MD_CTX *mctx2 = NULL;
+    EVP_PKEY_CTX *pctx = NULL;
+    size_t hdatalen = 0, siglen = 0;
+    void *hdata;
+    unsigned char *sig = NULL;
+    unsigned char out[EVP_MAX_MD_SIZE];
+    size_t outlen = 0;
+    const SIGALG_LOOKUP *lu = s->s3.tmp.sigalg;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (lu == NULL || s->s3.tmp.sign_cert == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    pkey = s->s3.tmp.sign_cert->privatekey;
+
+    if (pkey == NULL || !tls1_lookup_md(sctx, lu, &md)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    mctx = EVP_MD_CTX_new();
+    mctx2 = EVP_MD_CTX_new();
+    if (mctx == NULL || mctx2 == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    /* Get the data to be signed */
+    if (!get_cert_verify_tbs_data_ntls(s, &hdata, &hdatalen)) {
+        /* SSLfatal() already called */
+        goto err;
+    }
+
+    if (!EVP_DigestInit_ex(mctx2, md, NULL)
+            || !EVP_DigestUpdate(mctx2, hdata, hdatalen)
+            || !EVP_DigestFinal(mctx2, out, (unsigned int *)&outlen)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    if (EVP_DigestSignInit_ex(mctx, &pctx,
+                              md == NULL ? NULL : EVP_MD_get0_name(md),
+                              sctx->libctx, sctx->propq, pkey,
+                              NULL) <= 0) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2")) {
+        if (EVP_PKEY_CTX_set1_id(pctx, SM2_DEFAULT_ID,
+                                 SM2_DEFAULT_ID_LEN) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+            goto err;
+        }
+    }
+
+    if (EVP_DigestSign(mctx, NULL, &siglen, out, outlen) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+    sig = OPENSSL_malloc(siglen);
+    if (sig == NULL
+            || EVP_DigestSign(mctx, sig, &siglen, out, outlen) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    if (!WPACKET_sub_memcpy_u16(pkt, sig, siglen)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /* Digest cached records and discard handshake buffer */
+    if (!ssl3_digest_cached_records(s, 0)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    OPENSSL_free(sig);
+    EVP_MD_CTX_free(mctx);
+    EVP_MD_CTX_free(mctx2);
+    return 1;
+err:
+    OPENSSL_free(sig);
+    EVP_MD_CTX_free(mctx);
+    EVP_MD_CTX_free(mctx2);
+    return 0;
+}
+
+MSG_PROCESS_RETURN tls_process_cert_verify_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    EVP_PKEY *pkey = NULL;
+    const unsigned char *data;
+    MSG_PROCESS_RETURN ret = MSG_PROCESS_ERROR;
+    int j;
+    unsigned int len;
+    X509 *peer;
+    const EVP_MD *md = NULL;
+    size_t hdatalen = 0;
+    void *hdata;
+    EVP_MD_CTX *mctx = EVP_MD_CTX_new();
+    EVP_MD_CTX *mctx2 = EVP_MD_CTX_new();
+    EVP_PKEY_CTX *pctx = NULL;
+    unsigned char out[EVP_MAX_MD_SIZE];
+    size_t outlen = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (mctx == NULL || mctx2 == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    /* For NTLS server, s->session->peer stores the client signing certificate */
+    peer = s->session->peer;
+    pkey = X509_get0_pubkey(peer);
+    if (pkey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (ssl_cert_lookup_by_pkey(pkey, NULL, SSL_CONNECTION_GET_CTX(s)) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                      SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
+        goto err;
+    }
+
+    if (!tls1_set_peer_legacy_sigalg(s, pkey)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!tls1_lookup_md(sctx, s->s3.tmp.peer_sigalg, &md)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!PACKET_get_net_2(pkt, &len)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    if (!PACKET_get_bytes(pkt, &data, len)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    if (!get_cert_verify_tbs_data_ntls(s, &hdata, &hdatalen)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    OSSL_TRACE1(TLS, "Using client verify alg %s\n",
+                md == NULL ? "n/a" : EVP_MD_get0_name(md));
+
+#ifndef OPENSSL_NO_SM2
+    if (EVP_PKEY_is_a(pkey, "SM2"))  {
+        if (pkey != NULL) {
+            pctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, pkey, sctx->propq);
+            if (pctx == NULL) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+
+            if (EVP_PKEY_CTX_set1_id(pctx, HANDSHAKE_SM2_ID,
+                                     HANDSHAKE_SM2_ID_LEN) != 1) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+                goto err;
+            }
+
+            EVP_MD_CTX_set_pkey_ctx(mctx, pctx);
+        }
+    }
+#endif
+
+    if (EVP_DigestVerifyInit_ex(mctx, &pctx,
+                                md == NULL ? NULL : EVP_MD_get0_name(md),
+                                sctx->libctx, sctx->propq, pkey,
+                                NULL) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+
+    if (!EVP_DigestInit_ex(mctx2, md, NULL)
+            || !EVP_DigestUpdate(mctx2, hdata, hdatalen)
+            || !EVP_DigestFinal(mctx2, out, (unsigned int *)&outlen)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    if (EVP_PKEY_is_a(pkey, "SM2")) {
+        if (EVP_PKEY_CTX_set1_id(pctx, SM2_DEFAULT_ID, SM2_DEFAULT_ID_LEN) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+            goto err;
+        }
+    }
+
+
+    j = EVP_DigestVerify(mctx, data, len, out, outlen);
+    if (j <= 0) {
+        SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_BAD_SIGNATURE);
+        goto err;
+    }
+
+    ret = MSG_PROCESS_CONTINUE_READING;
+
+ err:
+    BIO_free(s->s3.handshake_buffer);
+    s->s3.handshake_buffer = NULL;
+    EVP_MD_CTX_free(mctx2);
+    EVP_MD_CTX_free(mctx);
+#ifndef OPENSSL_NO_SM2
+    /*other sig call EVP_PKEY_CTX_free there may cause segfault */
+    if (pkey != NULL && EVP_PKEY_is_a(pkey, "SM2"))
+        EVP_PKEY_CTX_free(pctx);
+#endif
+
+    return ret;
+}
+
+int tls_construct_finished_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    size_t finish_md_len;
+    const char *sender;
+    size_t slen;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    /* This is a real handshake so make sure we clean it up at the end */
+    if (!s->server && s->post_handshake_auth != SSL_PHA_REQUESTED)
+        s->statem.cleanuphand = 1;
+
+    if (s->server) {
+        sender = ssl->method->ssl3_enc->server_finished_label;
+        slen = ssl->method->ssl3_enc->server_finished_label_len;
+    } else {
+        sender = ssl->method->ssl3_enc->client_finished_label;
+        slen = ssl->method->ssl3_enc->client_finished_label_len;
+    }
+
+    finish_md_len = ssl->method->ssl3_enc->final_finish_mac(s,
+                                                          sender, slen,
+                                                          s->s3.tmp.finish_md);
+    if (finish_md_len == 0) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    s->s3.tmp.finish_md_len = finish_md_len;
+
+    if (!WPACKET_memcpy(pkt, s->s3.tmp.finish_md, finish_md_len)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /*
+     * Log the master secret, if logging is enabled. We don't log it for
+     * TLSv1.3: there's a different key schedule for that.
+     */
+    if (!ssl_log_secret(s, MASTER_SECRET_LABEL,
+                        s->session->master_key,
+                        s->session->master_key_length)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    /*
+     * Copy the finished so we can use it for renegotiation checks
+     */
+    if (!ossl_assert(finish_md_len <= EVP_MAX_MD_SIZE)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    if (!s->server) {
+        memcpy(s->s3.previous_client_finished, s->s3.tmp.finish_md,
+               finish_md_len);
+        s->s3.previous_client_finished_len = finish_md_len;
+    } else {
+        memcpy(s->s3.previous_server_finished, s->s3.tmp.finish_md,
+               finish_md_len);
+        s->s3.previous_server_finished_len = finish_md_len;
+    }
+
+    return 1;
+}
+
+/*
+ * ssl3_take_mac_ntls calculates the Finished MAC for the handshakes messages seen
+ * to far.
+ */
+int ssl3_take_mac_ntls(SSL_CONNECTION *s)
+{
+    const char *sender;
+    size_t slen;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    if (!s->server) {
+        sender = ssl->method->ssl3_enc->server_finished_label;
+        slen = ssl->method->ssl3_enc->server_finished_label_len;
+    } else {
+        sender = ssl->method->ssl3_enc->client_finished_label;
+        slen = ssl->method->ssl3_enc->client_finished_label_len;
+    }
+
+    s->s3.tmp.peer_finish_md_len =
+        ssl->method->ssl3_enc->final_finish_mac(s, sender, slen,
+                                              s->s3.tmp.peer_finish_md);
+
+    if (s->s3.tmp.peer_finish_md_len == 0) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    return 1;
+}
+
+MSG_PROCESS_RETURN tls_process_change_cipher_spec_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    size_t remain;
+
+    remain = PACKET_remaining(pkt);
+    /*
+     * 'Change Cipher Spec' is just a single byte, which should already have
+     * been consumed by ssl_get_message() so there should be no bytes left,
+     */
+    if (remain != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_CHANGE_CIPHER_SPEC);
+        return MSG_PROCESS_ERROR;
+    }
+
+    /* Check we have a cipher to change to */
+    if (s->s3.tmp.new_cipher == NULL) {
+        SSLfatal_ntls(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_CCS_RECEIVED_EARLY);
+        return MSG_PROCESS_ERROR;
+    }
+
+    s->s3.change_cipher_spec = 1;
+    if (!ssl3_do_change_cipher_spec(s)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+    }
+
+    return MSG_PROCESS_CONTINUE_READING;
+}
+
+MSG_PROCESS_RETURN tls_process_finished_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    size_t md_len;
+
+
+    /* This is a real handshake so make sure we clean it up at the end */
+    if (s->server) {
+        /*
+        * To get this far we must have read encrypted data from the client. We
+        * no longer tolerate unencrypted alerts. This value is ignored if less
+        * than TLSv1.3
+        */
+        if (s->post_handshake_auth != SSL_PHA_REQUESTED)
+            s->statem.cleanuphand = 1;
+    }
+
+    /* If this occurs, we have missed a message */
+    if (!s->s3.change_cipher_spec) {
+        SSLfatal_ntls(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_GOT_A_FIN_BEFORE_A_CCS);
+        return MSG_PROCESS_ERROR;
+    }
+    s->s3.change_cipher_spec = 0;
+
+    md_len = s->s3.tmp.peer_finish_md_len;
+
+    if (md_len != PACKET_remaining(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_DIGEST_LENGTH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (CRYPTO_memcmp(PACKET_data(pkt), s->s3.tmp.peer_finish_md,
+                      md_len) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_DIGEST_CHECK_FAILED);
+        return MSG_PROCESS_ERROR;
+    }
+
+    /*
+     * Copy the finished so we can use it for renegotiation checks
+     */
+    if (!ossl_assert(md_len <= EVP_MAX_MD_SIZE)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+    }
+    if (s->server) {
+        memcpy(s->s3.previous_client_finished, s->s3.tmp.peer_finish_md,
+               md_len);
+        s->s3.previous_client_finished_len = md_len;
+    } else {
+        memcpy(s->s3.previous_server_finished, s->s3.tmp.peer_finish_md,
+               md_len);
+        s->s3.previous_server_finished_len = md_len;
+    }
+
+    return MSG_PROCESS_FINISHED_READING;
+}
+
+int tls_construct_change_cipher_spec_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    if (!WPACKET_put_bytes_u8(pkt, SSL3_MT_CCS)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+/* Add a certificate to the WPACKET */
+static int ssl_add_cert_to_wpacket_ntls(SSL_CONNECTION *s, WPACKET *pkt, X509 *x)
+{
+    int len;
+    unsigned char *outbytes;
+
+    len = i2d_X509(x, NULL);
+    if (len < 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_BUF_LIB);
+        return 0;
+    }
+    if (!WPACKET_sub_allocate_bytes_u24(pkt, len, &outbytes)
+            || i2d_X509(x, &outbytes) != len) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+/* Add certificate chain to provided WPACKET */
+static int ssl_add_cert_chain_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                   CERT_PKEY *a_cpk, CERT_PKEY *k_cpk)
+{
+    int i, chain_count;
+    X509 *x;
+    STACK_OF(X509) *extra_certs;
+    STACK_OF(X509) *chain = NULL;
+    X509_STORE *chain_store;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (a_cpk == NULL || a_cpk->x509 == NULL
+        || k_cpk == NULL || k_cpk->x509 == NULL)
+        return 1;
+
+    if (a_cpk->chain != NULL)
+        extra_certs = a_cpk->chain;
+    else if (k_cpk->chain != NULL)
+        extra_certs = k_cpk->chain;
+    else
+        extra_certs = sctx->extra_certs;
+
+    if ((s->mode & SSL_MODE_NO_AUTO_CHAIN) || extra_certs)
+        chain_store = NULL;
+    else if (s->cert->chain_store)
+        chain_store = s->cert->chain_store;
+    else
+        chain_store = sctx->cert_store;
+
+    if (chain_store != NULL) {
+        X509_STORE_CTX *xs_ctx = X509_STORE_CTX_new_ex(sctx->libctx,
+                                                       sctx->propq);
+
+        if (xs_ctx == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+
+        if (!X509_STORE_CTX_init(xs_ctx, chain_store,
+                                 a_cpk->x509, NULL)) {
+            X509_STORE_CTX_free(xs_ctx);
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_X509_LIB);
+            return 0;
+        }
+        /*
+         * It is valid for the chain not to be complete (because normally we
+         * don't include the root cert in the chain). Therefore we deliberately
+         * ignore the error return from this call. We're not actually verifying
+         * the cert - we're just building as much of the chain as we can
+         */
+        (void)X509_verify_cert(xs_ctx);
+        /* Don't leave errors in the queue */
+        ERR_clear_error();
+        chain = X509_STORE_CTX_get0_chain(xs_ctx);
+        i = ssl_security_cert_chain(s, chain, NULL, 0);
+        if (i != 1) {
+#if 0
+            /* Dummy error calls so mkerr generates them */
+            ERR_raise(ERR_LIB_SSL, SSL_R_EE_KEY_TOO_SMALL);
+            ERR_raise(ERR_LIB_SSL, SSL_R_CA_KEY_TOO_SMALL);
+            ERR_raise(ERR_LIB_SSL, SSL_R_CA_MD_TOO_WEAK);
+#endif
+            X509_STORE_CTX_free(xs_ctx);
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, i);
+            return 0;
+        }
+
+        /* add sign certificate */
+        if (!ssl_add_cert_to_wpacket_ntls(s, pkt, a_cpk->x509)) {
+            /* SSLfatal_ntls() already called */
+            X509_STORE_CTX_free(xs_ctx);
+            return 0;
+        }
+
+        /* add encryption certificate */
+        if (!ssl_add_cert_to_wpacket_ntls(s, pkt, k_cpk->x509)) {
+            /* SSLfatal_ntls() already called */
+            X509_STORE_CTX_free(xs_ctx);
+            return 0;
+        }
+
+        chain_count = sk_X509_num(chain);
+        for (i = 1; i < chain_count; i++) {
+            x = sk_X509_value(chain, i);
+            if (!ssl_add_cert_to_wpacket_ntls(s, pkt, x)) {
+                /* SSLfatal_ntls() already called */
+                X509_STORE_CTX_free(xs_ctx);
+                return 0;
+            }
+        }
+        X509_STORE_CTX_free(xs_ctx);
+    } else {
+        i = ssl_security_cert_chain(s, extra_certs, a_cpk->x509, 0);
+        if (i != 1) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, i);
+            return 0;
+        }
+
+        /* add sign certificate */
+        if (!ssl_add_cert_to_wpacket_ntls(s, pkt, a_cpk->x509)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+
+        /* add encryption certificate */
+        if (!ssl_add_cert_to_wpacket_ntls(s, pkt, k_cpk->x509)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+
+        /* output the following chain */
+        for (i = 0; i < sk_X509_num(extra_certs); i++) {
+            x = sk_X509_value(extra_certs, i);
+            if (!ssl_add_cert_to_wpacket_ntls(s, pkt, x)) {
+                /* SSLfatal_ntls() already called */
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+
+unsigned long ssl3_output_cert_chain_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                          CERT_PKEY *a_cpk,
+                                          CERT_PKEY *k_cpk)
+{
+    if (!WPACKET_start_sub_packet_u24(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (!ssl_add_cert_chain_ntls(s, pkt, a_cpk, k_cpk))
+        return 0;
+
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+/*
+ * Tidy up after the end of a handshake. In the case of SCTP this may result
+ * in NBIO events. If |clearbufs| is set then init_buf and the wbio buffer is
+ * freed up as well.
+ */
+WORK_STATE tls_finish_handshake_ntls(SSL_CONNECTION *s, ossl_unused WORK_STATE wst,
+                                     int clearbufs, int stop)
+{
+    void (*cb) (const SSL *ssl, int type, int val) = NULL;
+    int cleanuphand = s->statem.cleanuphand;
+    SSL *ssl = SSL_CONNECTION_GET_USER_SSL(s);
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (clearbufs) {
+        BUF_MEM_free(s->init_buf);
+        s->init_buf = NULL;
+
+        if (!ssl_free_wbio_buffer(s)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return WORK_ERROR;
+        }
+        s->init_num = 0;
+    }
+
+    /*
+     * Only set if there was a Finished message and this isn't after a TLSv1.3
+     * post handshake exchange
+     */
+    if (cleanuphand) {
+        /* skipped if we just sent a HelloRequest */
+        s->renegotiate = 0;
+        s->new_session = 0;
+        s->statem.cleanuphand = 0;
+        s->ext.ticket_expected = 0;
+
+        ssl3_cleanup_key_block(s);
+
+        if (s->server) {
+            ssl_update_cache(s, SSL_SESS_CACHE_SERVER);
+
+            /* N.B. s->ctx may not equal s->session_ctx */
+            ssl_tsan_counter(sctx, &sctx->stats.sess_accept_good);
+            s->handshake_func = ossl_statem_accept_ntls;
+        } else {
+            ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);
+            if (s->hit)
+                ssl_tsan_counter(s->session_ctx,
+                                 &s->session_ctx->stats.sess_hit);
+
+            s->handshake_func = ossl_statem_connect_ntls;
+            ssl_tsan_counter(s->session_ctx,
+                             &s->session_ctx->stats.sess_connect_good);
+        }
+    }
+
+    if (s->info_callback != NULL)
+        cb = s->info_callback;
+    else if (sctx->info_callback != NULL)
+        cb = sctx->info_callback;
+
+    /* The callback may expect us to not be in init at handshake done */
+    ossl_statem_set_in_init_ntls(s, 0);
+
+    if (cb != NULL)
+        cb(ssl, SSL_CB_HANDSHAKE_DONE, 1);
+
+    if (!stop) {
+        /* If we've got more work to do we go back into init */
+        ossl_statem_set_in_init_ntls(s, 1);
+        return WORK_FINISHED_CONTINUE;
+    }
+
+    return WORK_FINISHED_STOP;
+}
+
+int tls_get_message_header_ntls(SSL_CONNECTION *s, int *mt)
+{
+    /* s->init_num < SSL3_HM_HEADER_LENGTH */
+    int skip_message, i;
+    uint8_t recvd_type;
+    unsigned char *p;
+    size_t l, readbytes;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    p = (unsigned char *)s->init_buf->data;
+
+    do {
+        while (s->init_num < SSL3_HM_HEADER_LENGTH) {
+            i = ssl->method->ssl_read_bytes(ssl, SSL3_RT_HANDSHAKE, &recvd_type,
+                                          &p[s->init_num],
+                                          SSL3_HM_HEADER_LENGTH - s->init_num,
+                                          0, &readbytes);
+            if (i <= 0) {
+                s->rwstate = SSL_READING;
+                return 0;
+            }
+            if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {
+                /*
+                 * A ChangeCipherSpec must be a single byte and may not occur
+                 * in the middle of a handshake message.
+                 */
+                if (s->init_num != 0 || readbytes != 1 || p[0] != SSL3_MT_CCS) {
+                    SSLfatal_ntls(s, SSL_AD_UNEXPECTED_MESSAGE,
+                                  SSL_R_BAD_CHANGE_CIPHER_SPEC);
+                    return 0;
+                }
+                if (s->statem.hand_state == TLS_ST_BEFORE
+                        && (s->s3.flags & TLS1_FLAGS_STATELESS) != 0) {
+                    /*
+                     * We are stateless and we received a CCS. Probably this is
+                     * from a client between the first and second ClientHellos.
+                     * We should ignore this, but return an error because we do
+                     * not return success until we see the second ClientHello
+                     * with a valid cookie.
+                     */
+                    return 0;
+                }
+                s->s3.tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC;
+                s->init_num = readbytes - 1;
+                s->init_msg = s->init_buf->data;
+                s->s3.tmp.message_size = readbytes;
+                return 1;
+            } else if (recvd_type != SSL3_RT_HANDSHAKE) {
+                SSLfatal_ntls(s, SSL_AD_UNEXPECTED_MESSAGE,
+                         SSL_R_CCS_RECEIVED_EARLY);
+                return 0;
+            }
+            s->init_num += readbytes;
+        }
+
+        skip_message = 0;
+        if (!s->server)
+            if (s->statem.hand_state != TLS_ST_OK
+                    && p[0] == SSL3_MT_HELLO_REQUEST)
+                /*
+                 * The server may always send 'Hello Request' messages --
+                 * we are doing a handshake anyway now, so ignore them if
+                 * their format is correct. Does not count for 'Finished'
+                 * MAC.
+                 */
+                if (p[1] == 0 && p[2] == 0 && p[3] == 0) {
+                    s->init_num = 0;
+                    skip_message = 1;
+
+                    if (s->msg_callback)
+                        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
+                                        p, SSL3_HM_HEADER_LENGTH, ussl,
+                                        s->msg_callback_arg);
+                }
+    } while (skip_message);
+    /* s->init_num == SSL3_HM_HEADER_LENGTH */
+
+    *mt = *p;
+    s->s3.tmp.message_type = *(p++);
+
+    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {
+        /*
+         * Only happens with SSLv3+ in an SSLv2 backward compatible
+         * ClientHello
+         *
+         * Total message size is the remaining record bytes to read
+         * plus the SSL3_HM_HEADER_LENGTH bytes that we already read
+         */
+        l = s->rlayer.tlsrecs[0].length
+            + SSL3_HM_HEADER_LENGTH;
+        s->s3.tmp.message_size = l;
+
+        s->init_msg = s->init_buf->data;
+        s->init_num = SSL3_HM_HEADER_LENGTH;
+    } else {
+        n2l3(p, l);
+        /* BUF_MEM_grow takes an 'int' parameter */
+        if (l > (INT_MAX - SSL3_HM_HEADER_LENGTH)) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                     SSL_R_EXCESSIVE_MESSAGE_SIZE);
+            return 0;
+        }
+        s->s3.tmp.message_size = l;
+
+        s->init_msg = s->init_buf->data + SSL3_HM_HEADER_LENGTH;
+        s->init_num = 0;
+    }
+
+    return 1;
+}
+
+int tls_get_message_body_ntls(SSL_CONNECTION *s, size_t *len)
+{
+    size_t n, readbytes;
+    unsigned char *p;
+    int i;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    if (s->s3.tmp.message_type == SSL3_MT_CHANGE_CIPHER_SPEC) {
+        /* We've already read everything in */
+        *len = (unsigned long)s->init_num;
+        return 1;
+    }
+
+    p = s->init_msg;
+    n = s->s3.tmp.message_size - s->init_num;
+    while (n > 0) {
+        i = ssl->method->ssl_read_bytes(ssl, SSL3_RT_HANDSHAKE, NULL,
+                                      &p[s->init_num], n, 0, &readbytes);
+        if (i <= 0) {
+            s->rwstate = SSL_READING;
+            *len = 0;
+            return 0;
+        }
+        s->init_num += readbytes;
+        n -= readbytes;
+    }
+
+    /*
+     * If receiving Finished, record MAC of prior handshake messages for
+     * Finished verification.
+     */
+    if (*(s->init_buf->data) == SSL3_MT_FINISHED && !ssl3_take_mac_ntls(s)) {
+        /* SSLfatal_ntls() already called */
+        *len = 0;
+        return 0;
+    }
+
+    /* Feed this message into MAC computation. */
+    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {
+        if (!ssl3_finish_mac(s, (unsigned char *)s->init_buf->data,
+                             s->init_num)) {
+            /* SSLfatal_ntls() already called */
+            *len = 0;
+            return 0;
+        }
+        if (s->msg_callback)
+            s->msg_callback(0, SSL2_VERSION, 0, s->init_buf->data,
+                            (size_t)s->init_num, ussl, s->msg_callback_arg);
+    } else {
+        /*
+         * We defer feeding in the HRR until later. We'll do it as part of
+         * processing the message
+         */
+#define SERVER_HELLO_RANDOM_OFFSET  (SSL3_HM_HEADER_LENGTH + 2)
+        if (s->s3.tmp.message_type != SSL3_MT_SERVER_HELLO
+                || s->init_num < SERVER_HELLO_RANDOM_OFFSET + SSL3_RANDOM_SIZE
+                || memcmp(hrrrandom_ntls,
+                          s->init_buf->data + SERVER_HELLO_RANDOM_OFFSET,
+                          SSL3_RANDOM_SIZE) != 0) {
+            if (!ssl3_finish_mac(s, (unsigned char *)s->init_buf->data,
+                                 s->init_num + SSL3_HM_HEADER_LENGTH)) {
+                /* SSLfatal_ntls() already called */
+                *len = 0;
+                return 0;
+            }
+        }
+        if (s->msg_callback)
+            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data,
+                            (size_t)s->init_num + SSL3_HM_HEADER_LENGTH, ussl,
+                            s->msg_callback_arg);
+    }
+
+    *len = s->init_num;
+    return 1;
+}
+
+static const X509ERR2ALERT x509table[] = {
+    {X509_V_ERR_APPLICATION_VERIFICATION, SSL_AD_HANDSHAKE_FAILURE},
+    {X509_V_ERR_CA_KEY_TOO_SMALL, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_EC_KEY_EXPLICIT_PARAMS, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_CA_MD_TOO_WEAK, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_CERT_CHAIN_TOO_LONG, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_CERT_HAS_EXPIRED, SSL_AD_CERTIFICATE_EXPIRED},
+    {X509_V_ERR_CERT_NOT_YET_VALID, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_CERT_REJECTED, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_CERT_REVOKED, SSL_AD_CERTIFICATE_REVOKED},
+    {X509_V_ERR_CERT_SIGNATURE_FAILURE, SSL_AD_DECRYPT_ERROR},
+    {X509_V_ERR_CERT_UNTRUSTED, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_CRL_HAS_EXPIRED, SSL_AD_CERTIFICATE_EXPIRED},
+    {X509_V_ERR_CRL_NOT_YET_VALID, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_CRL_SIGNATURE_FAILURE, SSL_AD_DECRYPT_ERROR},
+    {X509_V_ERR_DANE_NO_MATCH, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_EE_KEY_TOO_SMALL, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_EMAIL_MISMATCH, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_HOSTNAME_MISMATCH, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_INVALID_CA, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_INVALID_CALL, SSL_AD_INTERNAL_ERROR},
+    {X509_V_ERR_INVALID_PURPOSE, SSL_AD_UNSUPPORTED_CERTIFICATE},
+    {X509_V_ERR_IP_ADDRESS_MISMATCH, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_OUT_OF_MEM, SSL_AD_INTERNAL_ERROR},
+    {X509_V_ERR_PATH_LENGTH_EXCEEDED, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_STORE_LOOKUP, SSL_AD_INTERNAL_ERROR},
+    {X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE, SSL_AD_BAD_CERTIFICATE},
+    {X509_V_ERR_UNABLE_TO_GET_CRL, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE, SSL_AD_UNKNOWN_CA},
+    {X509_V_ERR_UNSPECIFIED, SSL_AD_INTERNAL_ERROR},
+
+    /* Last entry; return this if we don't find the value above. */
+    {X509_V_OK, SSL_AD_CERTIFICATE_UNKNOWN}
+};
+
+int ssl_x509err2alert_ntls(int x509err)
+{
+    const X509ERR2ALERT *tp;
+
+    for (tp = x509table; tp->x509err != X509_V_OK; ++tp)
+        if (tp->x509err == x509err)
+            break;
+    return tp->alert;
+}
+
+int ssl_allow_compression_ntls(SSL_CONNECTION *s)
+{
+    if (s->options & SSL_OP_NO_COMPRESSION)
+        return 0;
+    return ssl_security(s, SSL_SECOP_COMPRESSION, 0, 0, NULL);
+}
+
+static int version_cmp(const SSL_CONNECTION *s, int a, int b)
+{
+    if (a == b)
+        return 0;
+
+    return a < b ? -1 : 1;
+}
+
+typedef struct {
+    int version;
+    const SSL_METHOD *(*cmeth) (void);
+    const SSL_METHOD *(*smeth) (void);
+} version_info;
+
+#if TLS_MAX_VERSION_INTERNAL != TLS1_3_VERSION
+# error Code needs update for TLS_method() support beyond TLS1_3_VERSION.
+#endif
+
+/* Must be in order high to low */
+static const version_info tls_version_table[] = {
+#ifndef OPENSSL_NO_TLS1_3
+    {TLS1_3_VERSION, tlsv1_3_client_method, tlsv1_3_server_method},
+#else
+    {TLS1_3_VERSION, NULL, NULL},
+#endif
+#ifndef OPENSSL_NO_TLS1_2
+    {TLS1_2_VERSION, tlsv1_2_client_method, tlsv1_2_server_method},
+#else
+    {TLS1_2_VERSION, NULL, NULL},
+#endif
+#ifndef OPENSSL_NO_TLS1_1
+    {TLS1_1_VERSION, tlsv1_1_client_method, tlsv1_1_server_method},
+#else
+    {TLS1_1_VERSION, NULL, NULL},
+#endif
+#ifndef OPENSSL_NO_TLS1
+    {TLS1_VERSION, tlsv1_client_method, tlsv1_server_method},
+#else
+    {TLS1_VERSION, NULL, NULL},
+#endif
+#ifndef OPENSSL_NO_NTLS
+    {NTLS_VERSION, ntls_client_method, ntls_server_method},
+#else
+    {NTLS_VERSION, NULL, NULL},
+#endif
+#ifndef OPENSSL_NO_SSL3
+    {SSL3_VERSION, sslv3_client_method, sslv3_server_method},
+#else
+    {SSL3_VERSION, NULL, NULL},
+#endif
+    {0, NULL, NULL},
+};
+
+
+
+
+
+/*
+ * ssl_method_error - Check whether an SSL_METHOD is enabled.
+ *
+ * @s: The SSL handle for the candidate method
+ * @method: the intended method.
+ *
+ * Returns 0 on success, or an SSL error reason on failure.
+ */
+static int ssl_method_error(const SSL_CONNECTION *s, const SSL_METHOD *method)
+{
+    int version = method->version;
+
+    if ((s->min_proto_version != 0 &&
+         version_cmp(s, version, s->min_proto_version) < 0) ||
+        ssl_security(s, SSL_SECOP_VERSION, 0, version, NULL) == 0)
+        return SSL_R_VERSION_TOO_LOW;
+
+    if (s->max_proto_version != 0 &&
+        version_cmp(s, version, s->max_proto_version) > 0)
+        return SSL_R_VERSION_TOO_HIGH;
+
+    if ((s->options & method->mask) != 0)
+        return SSL_R_UNSUPPORTED_PROTOCOL;
+    if ((method->flags & SSL_METHOD_NO_SUITEB) != 0 && tls1_suiteb(s))
+        return SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE;
+
+    return 0;
+}
+
+/*
+ * ssl_version_supported_ntls - Check that the specified `version` is supported by
+ * `SSL *` instance
+ *
+ * @s: The SSL handle for the candidate method
+ * @version: Protocol version to test against
+ *
+ * Returns 1 when supported, otherwise 0
+ */
+int ssl_version_supported_ntls(const SSL_CONNECTION *s, int version, const SSL_METHOD **meth)
+{
+    const version_info *vent;
+    const version_info *table;
+
+    switch (SSL_CONNECTION_GET_SSL(s)->method->version) {
+    default:
+        /* Version should match method version for non-ANY method */
+        return version_cmp(s, version, s->version) == 0;
+    case TLS_ANY_VERSION:
+        table = tls_version_table;
+        break;
+    }
+
+    for (vent = table;
+         vent->version != 0 && version_cmp(s, version, vent->version) <= 0;
+         ++vent) {
+        if (vent->cmeth != NULL
+                && version_cmp(s, version, vent->version) == 0
+                && ssl_method_error(s, vent->cmeth()) == 0
+                && (!s->server
+                    || version != TLS1_3_VERSION)) {
+            if (meth != NULL)
+                *meth = vent->cmeth();
+            return 1;
+        }
+    }
+    return 0;
+}
+
+/*
+ * ssl_check_version_downgrade_ntls - In response to RFC7507 SCSV version
+ * fallback indication from a client check whether we're using the highest
+ * supported protocol version.
+ *
+ * @s server SSL handle.
+ *
+ * Returns 1 when using the highest enabled version, 0 otherwise.
+ */
+int ssl_check_version_downgrade_ntls(SSL_CONNECTION *s)
+{
+    const version_info *vent;
+    const version_info *table;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    /*
+     * Check that the current protocol is the highest enabled version
+     * (according to s->ctx->method, as version negotiation may have changed
+     * s->method).
+     */
+    if (s->version == sctx->method->version)
+        return 1;
+
+    /*
+     * Apparently we're using a version-flexible SSL_METHOD (not at its
+     * highest protocol version).
+     */
+    if (sctx->method->version == TLS_method()->version)
+        table = tls_version_table;
+    else {
+        /* Unexpected state; fail closed. */
+        return 0;
+    }
+
+    for (vent = table; vent->version != 0; ++vent) {
+        if (vent->smeth != NULL && ssl_method_error(s, vent->smeth()) == 0)
+            return s->version == vent->version;
+    }
+    return 0;
+}
+
+/*
+ * ssl_set_version_bound_ntls - set an upper or lower bound on the supported (D)TLS
+ * protocols, provided the initial (D)TLS method is version-flexible.  This
+ * function sanity-checks the proposed value and makes sure the method is
+ * version-flexible, then sets the limit if all is well.
+ *
+ * @method_version: The version of the current SSL_METHOD.
+ * @version: the intended limit.
+ * @bound: pointer to limit to be updated.
+ *
+ * Returns 1 on success, 0 on failure.
+ */
+int ssl_set_version_bound_ntls(int method_version, int version, int *bound)
+{
+    int valid_tls;
+
+    if (version == 0) {
+        *bound = version;
+        return 1;
+    }
+
+    valid_tls = version >= NTLS_VERSION && version <= TLS_MAX_VERSION_INTERNAL;
+
+    if (!valid_tls)
+        return 0;
+
+    /*-
+     * Restrict TLS methods to TLS protocol versions.
+     *
+     * Note that for both lower-bounds we use explicit versions, not
+     * (D)TLS_MIN_VERSION.  This is because we don't want to break user
+     * configurations.  If the MIN (supported) version ever rises, the user's
+     * "floor" remains valid even if no longer available.  We don't expect the
+     * MAX ceiling to ever get lower, so making that variable makes sense.
+     */
+    switch (method_version) {
+    default:
+        break;
+
+    case TLS_ANY_VERSION:
+        if (valid_tls)
+            *bound = version;
+        break;
+    }
+    return 1;
+}
+
+static void check_for_downgrade(SSL_CONNECTION *s, int vers, DOWNGRADE *dgrd)
+{
+    if (vers == TLS1_2_VERSION
+            && ssl_version_supported_ntls(s, TLS1_3_VERSION, NULL)) {
+        *dgrd = DOWNGRADE_TO_1_2;
+    } else if (vers < TLS1_2_VERSION
+               /*
+                * We need to ensure that a server that disables TLSv1.2
+                * (creating a hole between TLSv1.3 and TLSv1.1) can still
+                * complete handshakes with clients that support TLSv1.2 and
+                * below. Therefore we do not enable the sentinel if TLSv1.3 is
+                * enabled and TLSv1.2 is not.
+                */
+            && ssl_version_supported_ntls(s, TLS1_2_VERSION, NULL)) {
+        *dgrd = DOWNGRADE_TO_1_1;
+    } else {
+        *dgrd = DOWNGRADE_NONE;
+    }
+}
+
+/*
+ * ssl_choose_server_version_ntls - Choose server (D)TLS version.  Called when the
+ * client HELLO is received to select the final server protocol version and
+ * the version specific method.
+ *
+ * @s: server SSL handle.
+ *
+ * Returns 0 on success or an SSL error reason number on failure.
+ */
+int ssl_choose_server_version_ntls(SSL_CONNECTION *s, CLIENTHELLO_MSG *hello, DOWNGRADE *dgrd)
+{
+    /*-
+     * With version-flexible methods we have an initial state with:
+     *
+     *   s->method->version == (D)TLS_ANY_VERSION,
+     *   s->version == (D)TLS_MAX_VERSION_INTERNAL.
+     *
+     * So we detect version-flexible methods via the method version, not the
+     * handle version.
+     */
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    int server_version = ssl->method->version;
+    int client_version = hello->legacy_version;
+    const version_info *vent;
+    const version_info *table;
+    int disabled = 0;
+
+    s->client_version = client_version;
+
+    switch (server_version) {
+    default:
+        if (version_cmp(s, client_version, s->version) < 0)
+            return SSL_R_WRONG_SSL_VERSION;
+        *dgrd = DOWNGRADE_NONE;
+        /*
+            * If this SSL handle is not from a version flexible method we don't
+            * (and never did) check min/max FIPS or Suite B constraints.  Hope
+            * that's OK.  It is up to the caller to not choose fixed protocol
+            * versions they don't want.  If not, then easy to fix, just return
+            * ssl_method_error(s, s->method)
+            */
+        return 0;
+        /*
+         * Fall through if we are TLSv1.3 already (this means we must be after
+         * a HelloRetryRequest
+         */
+        /* fall thru */
+    case TLS_ANY_VERSION:
+        table = tls_version_table;
+        break;
+    }
+
+    /*
+     * just use the version supplied in the ClientHello.
+     */
+    for (vent = table; vent->version != 0; ++vent) {
+        const SSL_METHOD *method;
+
+        if (vent->smeth == NULL ||
+            version_cmp(s, client_version, vent->version) < 0)
+            continue;
+        method = vent->smeth();
+        if (ssl_method_error(s, method) == 0) {
+            check_for_downgrade(s, vent->version, dgrd);
+            s->version = vent->version;
+            ssl->method = method;
+            return 0;
+        }
+        disabled = 1;
+    }
+    return disabled ? SSL_R_UNSUPPORTED_PROTOCOL : SSL_R_VERSION_TOO_LOW;
+}
+
+/*
+ * ssl_choose_client_version_ntls - Choose client (D)TLS version.  Called when the
+ * server HELLO is received to select the final client protocol version and
+ * the version specific method.
+ *
+ * @s: client SSL handle.
+ * @version: The proposed version from the server's HELLO.
+ * @extensions: The extensions received
+ *
+ * Returns 1 on success or 0 on error.
+ */
+int ssl_choose_client_version_ntls(SSL_CONNECTION *s, int version, RAW_EXTENSION *extensions)
+{
+    const version_info *vent;
+    const version_info *table;
+    int ret, ver_min, ver_max, real_max, origv;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    origv = s->version;
+    s->version = version;
+
+    if (s->hello_retry_request != SSL_HRR_NONE
+            && s->version != TLS1_3_VERSION) {
+        s->version = origv;
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_WRONG_SSL_VERSION);
+        return 0;
+    }
+
+    switch (ssl->method->version) {
+    default:
+        if (s->version != ssl->method->version) {
+            s->version = origv;
+            SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_WRONG_SSL_VERSION);
+            return 0;
+        }
+        /*
+         * If this SSL handle is not from a version flexible method we don't
+         * (and never did) check min/max, FIPS or Suite B constraints.  Hope
+         * that's OK.  It is up to the caller to not choose fixed protocol
+         * versions they don't want.  If not, then easy to fix, just return
+         * ssl_method_error(s, s->method)
+         */
+        return 1;
+    case TLS_ANY_VERSION:
+        table = tls_version_table;
+        break;
+    }
+
+    ret = ssl_get_min_max_version_ntls(s, &ver_min, &ver_max, &real_max);
+    if (ret != 0) {
+        s->version = origv;
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, ret);
+        return 0;
+    }
+    if (s->version < ver_min) {
+        s->version = origv;
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNSUPPORTED_PROTOCOL);
+        return 0;
+    } else if (s->version > ver_max) {
+        s->version = origv;
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNSUPPORTED_PROTOCOL);
+        return 0;
+    }
+
+    if ((s->mode & SSL_MODE_SEND_FALLBACK_SCSV) == 0)
+        real_max = ver_max;
+
+    /* Check for downgrades */
+    if (s->version == TLS1_2_VERSION && real_max > s->version) {
+        if (memcmp(tls12downgrade,
+                   s->s3.server_random + SSL3_RANDOM_SIZE
+                                        - sizeof(tls12downgrade),
+                   sizeof(tls12downgrade)) == 0) {
+            s->version = origv;
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+			              SSL_R_INAPPROPRIATE_FALLBACK);
+            return 0;
+        }
+    } else if (s->version < TLS1_2_VERSION
+               && real_max > s->version) {
+        if (memcmp(tls11downgrade,
+                   s->s3.server_random + SSL3_RANDOM_SIZE
+                                        - sizeof(tls11downgrade),
+                   sizeof(tls11downgrade)) == 0) {
+            s->version = origv;
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                          SSL_R_INAPPROPRIATE_FALLBACK);
+            return 0;
+        }
+    }
+
+    for (vent = table; vent->version != 0; ++vent) {
+        if (vent->cmeth == NULL || s->version != vent->version)
+            continue;
+
+        ssl->method = vent->cmeth();
+        return 1;
+    }
+
+    s->version = origv;
+    SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNSUPPORTED_PROTOCOL);
+    return 0;
+}
+
+/*
+ * ssl_get_min_max_version_ntls - get minimum and maximum protocol version
+ * @s: The SSL connection
+ * @min_version: The minimum supported version
+ * @max_version: The maximum supported version
+ * @real_max:    The highest version below the lowest compile time version hole
+ *               where that hole lies above at least one run-time enabled
+ *               protocol.
+ *
+ * Work out what version we should be using for the initial ClientHello if the
+ * version is initially (D)TLS_ANY_VERSION.  We apply any explicit SSL_OP_NO_xxx
+ * options, the MinProtocol and MaxProtocol configuration commands, any Suite B
+ * constraints and any floor imposed by the security level here,
+ * so we don't advertise the wrong protocol version to only reject the outcome later.
+ *
+ * Computing the right floor matters.  If, e.g., TLS 1.0 and 1.2 are enabled,
+ * TLS 1.1 is disabled, but the security level, Suite-B  and/or MinProtocol
+ * only allow TLS 1.2, we want to advertise TLS1.2, *not* TLS1.
+ *
+ * Returns 0 on success or an SSL error reason number on failure.  On failure
+ * min_version and max_version will also be set to 0.
+ */
+int ssl_get_min_max_version_ntls(const SSL_CONNECTION *s, int *min_version, int *max_version,
+                            int *real_max)
+{
+    int version, tmp_real_max;
+    int hole;
+    const SSL_METHOD *single = NULL;
+    const SSL_METHOD *method;
+    const version_info *table;
+    const version_info *vent;
+    const SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    switch (ssl->method->version) {
+    default:
+        /*
+         * If this SSL handle is not from a version flexible method we don't
+         * (and never did) check min/max FIPS or Suite B constraints.  Hope
+         * that's OK.  It is up to the caller to not choose fixed protocol
+         * versions they don't want.  If not, then easy to fix, just return
+         * ssl_method_error(s, s->method)
+         */
+        *min_version = *max_version = s->version;
+        /*
+         * Providing a real_max only makes sense where we're using a version
+         * flexible method.
+         */
+        if (!ossl_assert(real_max == NULL))
+            return ERR_R_INTERNAL_ERROR;
+        return 0;
+    case TLS_ANY_VERSION:
+        table = tls_version_table;
+        break;
+    }
+
+    /*
+     * SSL_OP_NO_X disables all protocols above X *if* there are some protocols
+     * below X enabled. This is required in order to maintain the "version
+     * capability" vector contiguous. Any versions with a NULL client method
+     * (protocol version client is disabled at compile-time) is also a "hole".
+     *
+     * Our initial state is hole == 1, version == 0.  That is, versions above
+     * the first version in the method table are disabled (a "hole" above
+     * the valid protocol entries) and we don't have a selected version yet.
+     *
+     * Whenever "hole == 1", and we hit an enabled method, its version becomes
+     * the selected version, and the method becomes a candidate "single"
+     * method.  We're no longer in a hole, so "hole" becomes 0.
+     *
+     * If "hole == 0" and we hit an enabled method, then "single" is cleared,
+     * as we support a contiguous range of at least two methods.  If we hit
+     * a disabled method, then hole becomes true again, but nothing else
+     * changes yet, because all the remaining methods may be disabled too.
+     * If we again hit an enabled method after the new hole, it becomes
+     * selected, as we start from scratch.
+     */
+    *min_version = version = 0;
+    hole = 1;
+    if (real_max != NULL)
+        *real_max = 0;
+    tmp_real_max = 0;
+    for (vent = table; vent->version != 0; ++vent) {
+        /*
+         * A table entry with a NULL client method is still a hole in the
+         * "version capability" vector.
+         */
+        if (vent->cmeth == NULL) {
+            hole = 1;
+            tmp_real_max = 0;
+            continue;
+        }
+        method = vent->cmeth();
+
+        if (hole == 1 && tmp_real_max == 0)
+            tmp_real_max = vent->version;
+
+        if (ssl_method_error(s, method) != 0) {
+            hole = 1;
+        } else if (!hole) {
+            single = NULL;
+            *min_version = method->version;
+        } else {
+            if (real_max != NULL && tmp_real_max != 0)
+                *real_max = tmp_real_max;
+            version = (single = method)->version;
+            *min_version = version;
+            hole = 0;
+        }
+    }
+
+    *max_version = version;
+
+    /* Fail if everything is disabled */
+    if (version == 0)
+        return SSL_R_NO_PROTOCOLS_AVAILABLE;
+
+    return 0;
+}
+
+/*
+ * ssl_set_client_hello_version_ntls - Work out what version we should be using for
+ * the initial ClientHello.legacy_version field.
+ *
+ * @s: client SSL handle.
+ *
+ * Returns 0 on success or an SSL error reason number on failure.
+ */
+int ssl_set_client_hello_version_ntls(SSL_CONNECTION *s)
+{
+    int ver_min, ver_max, ret;
+
+    /*
+     * In a renegotiation we always send the same client_version that we sent
+     * last time, regardless of which version we eventually negotiated.
+     */
+    if (!SSL_IS_FIRST_HANDSHAKE(s))
+        return 0;
+
+    ret = ssl_get_min_max_version_ntls(s, &ver_min, &ver_max, NULL);
+
+    if (ret != 0)
+        return ret;
+
+    s->version = ver_max;
+
+    /* TLS1.3 always uses TLS1.2 in the legacy_version field */
+    if (ver_max > TLS1_2_VERSION)
+        ver_max = TLS1_2_VERSION;
+
+    s->client_version = ver_max;
+    return 0;
+}
+
+/*
+ * Checks a list of |groups| to determine if the |group_id| is in it. If it is
+ * and |checkallow| is 1 then additionally check if the group is allowed to be
+ * used. Returns 1 if the group is in the list (and allowed if |checkallow| is
+ * 1) or 0 otherwise.
+ */
+int check_in_list_ntls(SSL_CONNECTION *s, uint16_t group_id, const uint16_t *groups,
+                  size_t num_groups, int checkallow)
+{
+    size_t i;
+
+    if (groups == NULL || num_groups == 0)
+        return 0;
+
+    for (i = 0; i < num_groups; i++) {
+        uint16_t group = groups[i];
+
+        if (group_id == group
+                && (!checkallow
+                    || tls_group_allowed(s, group, SSL_SECOP_CURVE_CHECK))) {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+/* Replace ClientHello1 in the transcript hash with a synthetic message */
+int create_synthetic_message_hash_ntls(SSL_CONNECTION *s, const unsigned char *hashval,
+                                  size_t hashlen, const unsigned char *hrr,
+                                  size_t hrrlen)
+{
+    unsigned char hashvaltmp[EVP_MAX_MD_SIZE];
+    unsigned char msghdr[SSL3_HM_HEADER_LENGTH];
+
+    memset(msghdr, 0, sizeof(msghdr));
+
+    if (hashval == NULL) {
+        hashval = hashvaltmp;
+        hashlen = 0;
+        /* Get the hash of the initial ClientHello */
+        if (!ssl3_digest_cached_records(s, 0)
+                || !ssl_handshake_hash(s, hashvaltmp, sizeof(hashvaltmp),
+                                       &hashlen)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+
+    /* Reinitialise the transcript hash */
+    if (!ssl3_init_finished_mac(s)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    /* Inject the synthetic message_hash message */
+    msghdr[0] = SSL3_MT_MESSAGE_HASH;
+    msghdr[SSL3_HM_HEADER_LENGTH - 1] = (unsigned char)hashlen;
+    if (!ssl3_finish_mac(s, msghdr, SSL3_HM_HEADER_LENGTH)
+            || !ssl3_finish_mac(s, hashval, hashlen)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    /*
+     * Now re-inject the HRR and current message if appropriate (we just deleted
+     * it when we reinitialised the transcript hash above). Only necessary after
+     * receiving a ClientHello2 with a cookie.
+     */
+    if (hrr != NULL
+            && (!ssl3_finish_mac(s, hrr, hrrlen)
+                || !ssl3_finish_mac(s, (unsigned char *)s->init_buf->data,
+                                    s->s3.tmp.message_size
+                                    + SSL3_HM_HEADER_LENGTH))) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    return 1;
+}
+
+static int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b)
+{
+    return X509_NAME_cmp(*a, *b);
+}
+
+int parse_ca_names_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    STACK_OF(X509_NAME) *ca_sk = sk_X509_NAME_new(ca_dn_cmp);
+    X509_NAME *xn = NULL;
+    PACKET cadns;
+
+    if (ca_sk == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    /* get the CA RDNs */
+    if (!PACKET_get_length_prefixed_2(pkt, &cadns)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    while (PACKET_remaining(&cadns)) {
+        const unsigned char *namestart, *namebytes;
+        unsigned int name_len;
+
+        if (!PACKET_get_net_2(&cadns, &name_len)
+            || !PACKET_get_bytes(&cadns, &namebytes, name_len)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        namestart = namebytes;
+        if ((xn = d2i_X509_NAME(NULL, &namebytes, name_len)) == NULL) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        if (namebytes != (namestart + name_len)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_CA_DN_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (!sk_X509_NAME_push(ca_sk, xn)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+        xn = NULL;
+    }
+
+    sk_X509_NAME_pop_free(s->s3.tmp.peer_ca_names, X509_NAME_free);
+    s->s3.tmp.peer_ca_names = ca_sk;
+
+    return 1;
+
+ err:
+    sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);
+    X509_NAME_free(xn);
+    return 0;
+}
+
+const STACK_OF(X509_NAME) *get_ca_names_ntls(SSL_CONNECTION *s)
+{
+    const STACK_OF(X509_NAME) *ca_sk = NULL;;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    if (s->server) {
+        ca_sk = SSL_get_client_CA_list(ssl);
+        if (ca_sk != NULL && sk_X509_NAME_num(ca_sk) == 0)
+            ca_sk = NULL;
+    }
+
+    if (ca_sk == NULL)
+        ca_sk = SSL_get0_CA_list(ssl);
+
+    return ca_sk;
+}
+
+int construct_ca_names_ntls(SSL_CONNECTION *s, const STACK_OF(X509_NAME) *ca_sk, WPACKET *pkt)
+{
+    /* Start sub-packet for client CA list */
+    if (!WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if ((ca_sk != NULL) && !(s->options & SSL_OP_DISABLE_TLSEXT_CA_NAMES)) {
+        int i;
+
+        for (i = 0; i < sk_X509_NAME_num(ca_sk); i++) {
+            unsigned char *namebytes;
+            X509_NAME *name = sk_X509_NAME_value(ca_sk, i);
+            int namelen;
+
+            if (name == NULL
+                    || (namelen = i2d_X509_NAME(name, NULL)) < 0
+                    || !WPACKET_sub_allocate_bytes_u16(pkt, namelen,
+                                                       &namebytes)
+                    || i2d_X509_NAME(name, &namebytes) != namelen) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+        }
+    }
+
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+/* Create a buffer containing data to be signed for server key exchange */
+size_t construct_key_exchange_tbs_ntls(SSL_CONNECTION *s, unsigned char **ptbs,
+                                  const void *param, size_t paramlen)
+{
+    size_t tbslen = 2 * SSL3_RANDOM_SIZE + paramlen;
+    unsigned char *tbs = OPENSSL_malloc(tbslen);
+
+    if (tbs == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    memcpy(tbs, s->s3.client_random, SSL3_RANDOM_SIZE);
+    memcpy(tbs + SSL3_RANDOM_SIZE, s->s3.server_random, SSL3_RANDOM_SIZE);
+
+    memcpy(tbs + SSL3_RANDOM_SIZE * 2, param, paramlen);
+
+    *ptbs = tbs;
+    return tbslen;
+}
+
+/*
+ * Saves the current handshake digest for Post-Handshake Auth,
+ * Done after ClientFinished is processed, done exactly once
+ */
+int tls13_save_handshake_digest_for_pha_ntls(SSL_CONNECTION *s)
+{
+    if (s->pha_dgst == NULL) {
+        if (!ssl3_digest_cached_records(s, 1))
+            /* SSLfatal_ntls() already called */
+            return 0;
+
+        s->pha_dgst = EVP_MD_CTX_new();
+        if (s->pha_dgst == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        if (!EVP_MD_CTX_copy_ex(s->pha_dgst,
+                                s->s3.handshake_dgst)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            EVP_MD_CTX_free(s->pha_dgst);
+            s->pha_dgst = NULL;
+            return 0;
+        }
+    }
+    return 1;
+}
+
+/*
+ * Restores the Post-Handshake Auth handshake digest
+ * Done just before sending/processing the Cert Request
+ */
+int tls13_restore_handshake_digest_for_pha_ntls(SSL_CONNECTION *s)
+{
+    if (s->pha_dgst == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    if (!EVP_MD_CTX_copy_ex(s->s3.handshake_dgst,
+                            s->pha_dgst)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    return 1;
+}
+
+unsigned char *x509_to_asn1_ntls(const X509 *x, size_t *len)
+{
+    unsigned char *buf = NULL;
+    unsigned char *p;
+    size_t buflen;
+    int n;
+
+    if (x == NULL || len == NULL)
+        return NULL;
+
+    if ((n = i2d_X509(x, NULL)) <= 0)
+        return NULL;
+
+    /* opaque ASN.1Cert<1..2^24-1> */
+    buflen = n + 3;
+
+    buf = OPENSSL_malloc(buflen);
+    if (buf == NULL)
+        return NULL;
+
+    p = buf + 3;
+    if ((n = i2d_X509(x, &p)) <= 0) {
+        OPENSSL_free(buf);
+        return NULL;
+    }
+
+    l2n3(n, buf);
+    buf -= 3;
+
+    *len = n + 3;
+
+    return buf;
+}
+
+int ssl_derive_ntls(SSL_CONNECTION *s, EVP_PKEY *privkey, EVP_PKEY *pubkey, int gensecret)
+{
+    int rv = 0;
+    int idx = 1;
+    X509 *peer_x509 = NULL;
+    EVP_PKEY *peer_cert_pub = NULL;
+    EVP_PKEY *cert_priv = NULL;
+    unsigned char *pms = NULL;
+    size_t pmslen = SSL_MAX_MASTER_KEY_LENGTH;
+    EVP_PKEY_CTX *pctx = NULL;
+    OSSL_PARAM params[8], *p = params;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (privkey == NULL || pubkey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* SM2 requires to use the private key in encryption certificate */
+    cert_priv = s->cert->pkeys[SSL_PKEY_SM2_ENC].privatekey;
+    if (cert_priv == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /*
+     * XXX:
+     *
+     * For NTLS server side, s->session->peer stores the client signing
+     * certificate and s->session->peer_chain is an one-item stack which
+     * stores the client encryption certificate.
+     *
+     * We need to get the client encryption certificate at this stage,
+     * so we use index 0 in peer_chain.
+     *
+     * For client side of NTLS, the peer is an reference of the first element
+     * of the two-item stack stored in s->session->peer_chain, which is the
+     * signing certificate of server. So we need to get the second certificate
+     * in this scenario for encryption usage.
+     */
+    if (s->server)
+        idx = 0;
+
+    if (s->session->peer_chain == NULL
+        || (peer_x509 = sk_X509_value(s->session->peer_chain, idx)) == NULL
+        || (peer_cert_pub = X509_get0_pubkey(peer_x509)) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    pms = OPENSSL_malloc(pmslen);
+    if (pms == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    pctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, privkey, sctx->propq);
+
+    /* for NTLS, server is initiator(Z_A), client is responder(Z_B) */
+    *p++ = OSSL_PARAM_construct_int(OSSL_EXCHANGE_PARAM_INITIATOR,
+                                    &s->server);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_EXCHANGE_PARAM_SELF_ID,
+                                             SM2_DEFAULT_ID,
+                                             SM2_DEFAULT_ID_LEN);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_EXCHANGE_PARAM_PEER_ID,
+                                             SM2_DEFAULT_ID,
+                                             SM2_DEFAULT_ID_LEN);
+    *p++ = OSSL_PARAM_construct_octet_ptr(OSSL_EXCHANGE_PARAM_SELF_ENC_KEY,
+                                          (void **)&cert_priv,
+                                          sizeof(cert_priv));
+    *p++ = OSSL_PARAM_construct_octet_ptr(OSSL_EXCHANGE_PARAM_PEER_ENC_KEY,
+                                          (void **)&peer_cert_pub,
+                                          sizeof(peer_cert_pub));
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_EXCHANGE_PARAM_DIGEST,
+                                            "SM3", 0);
+    *p++ = OSSL_PARAM_construct_size_t(OSSL_EXCHANGE_PARAM_OUTLEN, &pmslen);
+    *p = OSSL_PARAM_construct_end();
+
+    if (EVP_PKEY_derive_init_ex(pctx, params) <= 0
+        || EVP_PKEY_derive_set_peer(pctx, pubkey) <= 0
+        || EVP_PKEY_derive(pctx, pms, &pmslen) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (gensecret) {
+        rv = ssl_gensecret(s, pms, pmslen);
+    } else {
+        /* Save premaster secret */
+        s->s3.tmp.pms = pms;
+        s->s3.tmp.pmslen = pmslen;
+        pms = NULL;
+        rv = 1;
+    }
+
+err:
+    OPENSSL_clear_free(pms, pmslen);
+    EVP_PKEY_CTX_free(pctx);
+    return rv;
+}
+
+
+int SSL_connection_is_ntls(SSL_CONNECTION *s, int is_server)
+{
+#define PEEK_HEADER_LENGTH 3
+    /*
+     * For client, or sometimes ssl_version is fixed,
+     * we can easily determine if version is NTLS
+     */
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    if (s->version == NTLS1_1_VERSION)
+        return 1;
+
+    if (is_server) {
+        /* After receiving client hello and before choosing server version,
+         * get version from s->clienthello->legacy_version
+         */
+        if (s->clienthello) {
+            if (s->clienthello->legacy_version == NTLS1_1_VERSION)
+                return 1;
+            else
+                return 0;
+        }
+
+        /*
+         * For server, first flight has not set version, we
+         * have to get the server version from clientHello
+         */
+        if (SSL_IS_FIRST_HANDSHAKE(s) && SSL_in_before(ssl)) {
+            int ret, fd;
+            PACKET pkt;
+            unsigned int version, type;
+            unsigned char buf[PEEK_HEADER_LENGTH];
+            char *data = NULL;
+
+            if (BIO_method_type(s->rbio) == BIO_TYPE_MEM) {
+                ret = BIO_get_mem_data(s->rbio, &data);
+                if (ret < PEEK_HEADER_LENGTH) {
+                    s->rwstate = SSL_READING;
+                    return -1;
+                }
+                memcpy(buf, data, PEEK_HEADER_LENGTH);
+            } else {
+                ret = BIO_get_fd(s->rbio, &fd);
+
+                if (ret <= 0) {
+                    /* NTLS only support socket communication */
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                                  ERR_R_INTERNAL_ERROR);
+                    return -1;
+                }
+
+                ret = recv(fd, buf, PEEK_HEADER_LENGTH, MSG_PEEK);
+                if (ret < PEEK_HEADER_LENGTH) {
+                    s->rwstate = SSL_READING;
+                    return -1;
+                }
+            }
+
+            if (!PACKET_buf_init(&pkt, buf, 3)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return -1;
+            }
+
+            if (!PACKET_get_1(&pkt, &type)) {
+                SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, ERR_R_INTERNAL_ERROR);
+                return -1;
+            }
+
+            if (!PACKET_get_net_2(&pkt, &version)) {
+                SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, ERR_R_INTERNAL_ERROR);
+                return -1;
+            }
+
+            if (version == NTLS1_1_VERSION)
+                return 1;
+            else
+                return 0;
+        }
+    }
+
+    return 0;
+}
\ No newline at end of file
Index: b/ssl/statem_ntls/ntls_statem_local.h
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_statem_local.h
@@ -0,0 +1,456 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+/*****************************************************************************
+ *                                                                           *
+ * The following definitions are PRIVATE to the state machine. They should   *
+ * NOT be used outside of the state machine.                                 *
+ *                                                                           *
+ *****************************************************************************/
+
+/* Max message length definitions */
+
+/* The spec allows for a longer length than this, but we limit it */
+#define HELLO_VERIFY_REQUEST_MAX_LENGTH 258
+#define END_OF_EARLY_DATA_MAX_LENGTH    0
+#define HELLO_RETRY_REQUEST_MAX_LENGTH  20000
+#define ENCRYPTED_EXTENSIONS_MAX_LENGTH 20000
+#define SESSION_TICKET_MAX_LENGTH_TLS13 131338
+#define SESSION_TICKET_MAX_LENGTH_TLS12 65541
+#define SERVER_KEY_EXCH_MAX_LENGTH      102400
+#define SERVER_HELLO_DONE_MAX_LENGTH    0
+#define KEY_UPDATE_MAX_LENGTH           1
+#define CCS_MAX_LENGTH                  1
+
+/* Max ServerHello size permitted by RFC 8446 */
+#define SERVER_HELLO_MAX_LENGTH         65607
+
+/* Max should actually be 36 but we are generous */
+#define FINISHED_MAX_LENGTH             64
+
+/* Dummy message type */
+#define SSL3_MT_DUMMY   -1
+
+#ifndef OPENSSL_NO_SM2
+/*
+ *standard handshake sm2-id and cert verify id is defined
+ * in IETF RFC 8998
+ */
+# define HANDSHAKE_SM2_ID "TLSv1.3+GM+Cipher+Suite"
+# define HANDSHAKE_SM2_ID_LEN sizeof(HANDSHAKE_SM2_ID) - 1
+# define CERTVRIFY_SM2_ID "1234567812345678"
+# define CERTVRIFY_SM2_ID_LEN sizeof(CERTVRIFY_SM2_ID) - 1
+
+#endif
+
+extern const unsigned char hrrrandom_ntls[];
+
+/* Message processing return codes */
+typedef enum {
+    /* Something bad happened */
+    MSG_PROCESS_ERROR,
+    /* We've finished reading - swap to writing */
+    MSG_PROCESS_FINISHED_READING,
+    /*
+     * We've completed the main processing of this message but there is some
+     * post processing to be done.
+     */
+    MSG_PROCESS_CONTINUE_PROCESSING,
+    /* We've finished this message - read the next message */
+    MSG_PROCESS_CONTINUE_READING
+} MSG_PROCESS_RETURN;
+
+typedef int (*confunc_f) (SSL_CONNECTION *s, WPACKET *pkt);
+
+int ssl3_take_mac_ntls(SSL_CONNECTION *s);
+int check_in_list_ntls(SSL_CONNECTION *s, uint16_t group_id, const uint16_t *groups,
+                  size_t num_groups, int checkallow);
+int create_synthetic_message_hash_ntls(SSL_CONNECTION *s, const unsigned char *hashval,
+                                  size_t hashlen, const unsigned char *hrr,
+                                  size_t hrrlen);
+int parse_ca_names_ntls(SSL_CONNECTION *s, PACKET *pkt);
+const STACK_OF(X509_NAME) *get_ca_names_ntls(SSL_CONNECTION *s);
+int construct_ca_names_ntls(SSL_CONNECTION *s, const STACK_OF(X509_NAME) *ca_sk, WPACKET *pkt);
+size_t construct_key_exchange_tbs_ntls(SSL_CONNECTION *s, unsigned char **ptbs,
+                                  const void *param, size_t paramlen);
+
+/*
+ * TLS/DTLS client state machine functions
+ */
+int ossl_statem_client_read_transition_ntls(SSL_CONNECTION *s, int mt);
+WRITE_TRAN ossl_statem_client_write_transition_ntls(SSL_CONNECTION *s);
+WORK_STATE ossl_statem_client_pre_work_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+WORK_STATE ossl_statem_client_post_work_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+int ossl_statem_client_construct_message_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         confunc_f *confunc, int *mt);
+size_t ossl_statem_client_max_message_size_ntls(SSL_CONNECTION *s);
+MSG_PROCESS_RETURN ossl_statem_client_process_message_ntls(SSL_CONNECTION *s, PACKET *pkt);
+WORK_STATE ossl_statem_client_post_process_message_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+
+/*
+ * TLS/DTLS server state machine functions
+ */
+int ossl_statem_server_read_transition_ntls(SSL_CONNECTION *s, int mt);
+WRITE_TRAN ossl_statem_server_write_transition_ntls(SSL_CONNECTION *s);
+WORK_STATE ossl_statem_server_pre_work_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+WORK_STATE ossl_statem_server_post_work_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+int ossl_statem_server_construct_message_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         confunc_f *confunc,int *mt);
+size_t ossl_statem_server_max_message_size_ntls(SSL_CONNECTION *s);
+MSG_PROCESS_RETURN ossl_statem_server_process_message_ntls(SSL_CONNECTION *s, PACKET *pkt);
+WORK_STATE ossl_statem_server_post_process_message_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+
+/* Functions for getting new message data */
+__owur int tls_get_message_header_ntls(SSL_CONNECTION *s, int *mt);
+__owur int tls_get_message_body_ntls(SSL_CONNECTION *s, size_t *len);
+__owur int dtls_get_message_ntls(SSL_CONNECTION *s, int *mt, size_t *len);
+
+/* Message construction and processing functions */
+__owur int tls_process_initial_server_flight_ntls(SSL_CONNECTION *s);
+__owur MSG_PROCESS_RETURN tls_process_change_cipher_spec_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_finished_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur int tls_construct_change_cipher_spec_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+
+
+__owur int tls_construct_finished_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur WORK_STATE tls_finish_handshake_ntls(SSL_CONNECTION *s, WORK_STATE wst, int clearbufs,
+                                       int stop);
+__owur WORK_STATE dtls_wait_for_dry_ntls(SSL_CONNECTION *s);
+
+/* some client-only functions */
+__owur int tls_construct_client_hello_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_server_hello_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_certificate_request_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_new_session_ticket_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur int tls_process_cert_status_body_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_cert_status_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_server_done_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur int tls_construct_cert_verify_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur WORK_STATE tls_prepare_client_certificate_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+__owur int tls_construct_client_certificate_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int ssl_do_client_cert_cb_ntls(SSL_CONNECTION *s, X509 **px509, EVP_PKEY **ppkey);
+__owur int tls_construct_client_key_exchange_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int tls_client_key_exchange_post_work_ntls(SSL_CONNECTION *s);
+__owur int tls_construct_cert_status_body_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int tls_construct_cert_status_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_key_exchange_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_server_certificate_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur WORK_STATE tls_post_process_server_certificate_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+__owur int ssl3_check_cert_and_algorithm_ntls(SSL_CONNECTION *s);
+#ifndef OPENSSL_NO_NEXTPROTONEG
+__owur int tls_construct_next_proto_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+#endif
+__owur MSG_PROCESS_RETURN tls_process_hello_req_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN dtls_process_hello_verify_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur int tls_construct_end_of_early_data_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+
+/* some server-only functions */
+__owur MSG_PROCESS_RETURN tls_process_client_hello_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur WORK_STATE tls_post_process_client_hello_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+__owur int tls_construct_server_hello_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int dtls_construct_hello_verify_request_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int tls_construct_server_certificate_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int tls_construct_server_key_exchange_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int tls_construct_certificate_request_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur int tls_construct_server_done_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_client_certificate_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur MSG_PROCESS_RETURN tls_process_client_key_exchange_ntls(SSL_CONNECTION *s, PACKET *pkt);
+__owur WORK_STATE tls_post_process_client_key_exchange_ntls(SSL_CONNECTION *s, WORK_STATE wst);
+__owur MSG_PROCESS_RETURN tls_process_cert_verify_ntls(SSL_CONNECTION *s, PACKET *pkt);
+#ifndef OPENSSL_NO_NEXTPROTONEG
+__owur MSG_PROCESS_RETURN tls_process_next_proto_ntls(SSL_CONNECTION *s, PACKET *pkt);
+#endif
+__owur int tls_construct_new_session_ticket_ntls(SSL_CONNECTION *s, WPACKET *pkt);
+MSG_PROCESS_RETURN tls_process_end_of_early_data_ntls(SSL_CONNECTION *s, PACKET *pkt);
+
+
+/* Extension processing */
+
+typedef enum ext_return_en {
+    EXT_RETURN_FAIL,
+    EXT_RETURN_SENT,
+    EXT_RETURN_NOT_SENT
+} EXT_RETURN;
+
+__owur int tls_validate_all_contexts_ntls(SSL_CONNECTION *s, unsigned int thisctx,
+                                     RAW_EXTENSION *exts);
+__owur int extension_is_relevant_ntls(SSL_CONNECTION *s, unsigned int extctx,
+                                 unsigned int thisctx);
+__owur int tls_collect_extensions_ntls(SSL_CONNECTION *s, PACKET *packet, unsigned int context,
+                                  RAW_EXTENSION **res, size_t *len, int init);
+__owur int tls_parse_extension_ntls(SSL_CONNECTION *s, TLSEXT_INDEX idx, int context,
+                               RAW_EXTENSION *exts,  X509 *x, size_t chainidx);
+__owur int tls_parse_all_extensions_ntls(SSL_CONNECTION *s, int context, RAW_EXTENSION *exts,
+                                    X509 *x, size_t chainidx, int fin);
+__owur int should_add_extension_ntls(SSL_CONNECTION *s, unsigned int extctx,
+                                unsigned int thisctx, int max_version);
+__owur int tls_construct_extensions_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                    X509 *x, size_t chainidx);
+
+__owur int tls_psk_do_binder_ntls(SSL_CONNECTION *s, const EVP_MD *md,
+                             const unsigned char *msgstart,
+                             size_t binderoffset, const unsigned char *binderin,
+                             unsigned char *binderout,
+                             SSL_SESSION *sess, int sign, int external);
+
+/* Server Extension processing */
+int tls_parse_ctos_server_name_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                               X509 *x, size_t chainidx);
+int tls_parse_ctos_maxfragmentlen_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+int tls_parse_ctos_early_data_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                              X509 *x, size_t chainidx);
+int tls_parse_ctos_ec_pt_formats_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx);
+int tls_parse_ctos_supported_groups_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                    X509 *x, size_t chainidxl);
+int tls_parse_ctos_session_ticket_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+int tls_parse_ctos_sig_algs_cert_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx);
+int tls_parse_ctos_sig_algs_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                            size_t chainidx);
+#ifndef OPENSSL_NO_OCSP
+int tls_parse_ctos_status_request_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+#endif
+#ifndef OPENSSL_NO_NEXTPROTONEG
+int tls_parse_ctos_npn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+#endif
+int tls_parse_ctos_alpn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                        size_t chainidx);
+#ifndef OPENSSL_NO_SRTP
+int tls_parse_ctos_use_srtp_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                            size_t chainidx);
+#endif
+int tls_parse_ctos_etm_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+int tls_parse_ctos_key_share_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                             size_t chainidx);
+int tls_parse_ctos_cookie_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                          size_t chainidx);
+int tls_parse_ctos_ems_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+int tls_parse_ctos_psk_kex_modes_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx);
+int tls_parse_ctos_psk_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+int tls_parse_ctos_post_handshake_auth_ntls(SSL_CONNECTION *, PACKET *pkt, unsigned int context,
+                                       X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_stoc_server_name_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                          unsigned int context, X509 *x,
+                                          size_t chainidx);
+EXT_RETURN tls_construct_stoc_early_data_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         unsigned int context, X509 *x,
+                                         size_t chainidx);
+EXT_RETURN tls_construct_stoc_maxfragmentlen_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+EXT_RETURN tls_construct_stoc_ec_pt_formats_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx);
+EXT_RETURN tls_construct_stoc_supported_groups_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                               unsigned int context, X509 *x,
+                                               size_t chainidx);
+EXT_RETURN tls_construct_stoc_session_ticket_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+#ifndef OPENSSL_NO_OCSP
+EXT_RETURN tls_construct_stoc_status_request_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+#endif
+#ifndef OPENSSL_NO_NEXTPROTONEG
+EXT_RETURN tls_construct_stoc_next_proto_neg_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+#endif
+EXT_RETURN tls_construct_stoc_alpn_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                   X509 *x, size_t chainidx);
+#ifndef OPENSSL_NO_SRTP
+EXT_RETURN tls_construct_stoc_use_srtp_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                X509 *x, size_t chainidx);
+#endif
+EXT_RETURN tls_construct_stoc_etm_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_stoc_ems_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_stoc_supported_versions_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                                 unsigned int context, X509 *x,
+                                                 size_t chainidx);
+EXT_RETURN tls_construct_stoc_key_share_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                        unsigned int context, X509 *x,
+                                        size_t chainidx);
+EXT_RETURN tls_construct_stoc_cookie_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                     X509 *x, size_t chainidx);
+/*
+ * Not in public headers as this is not an official extension. Only used when
+ * SSL_OP_CRYPTOPRO_TLSEXT_BUG is set.
+ */
+#define TLSEXT_TYPE_cryptopro_bug      0xfde8
+EXT_RETURN tls_construct_stoc_cryptopro_bug_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx);
+EXT_RETURN tls_construct_stoc_psk_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+
+/* Client Extension processing */
+EXT_RETURN tls_construct_ctos_server_name_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                   X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_ctos_maxfragmentlen_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                             X509 *x, size_t chainidx);
+
+EXT_RETURN tls_construct_ctos_ec_pt_formats_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx);
+EXT_RETURN tls_construct_ctos_supported_groups_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                               unsigned int context, X509 *x,
+                                               size_t chainidx);
+EXT_RETURN tls_construct_ctos_early_data_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         unsigned int context, X509 *x,
+                                         size_t chainidx);
+EXT_RETURN tls_construct_ctos_session_ticket_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+EXT_RETURN tls_construct_ctos_sig_algs_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                       unsigned int context, X509 *x,
+                                       size_t chainidx);
+#ifndef OPENSSL_NO_OCSP
+EXT_RETURN tls_construct_ctos_status_request_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                             unsigned int context, X509 *x,
+                                             size_t chainidx);
+#endif
+#ifndef OPENSSL_NO_NEXTPROTONEG
+EXT_RETURN tls_construct_ctos_npn_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+#endif
+EXT_RETURN tls_construct_ctos_alpn_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                   X509 *x, size_t chainidx);
+#ifndef OPENSSL_NO_SRTP
+EXT_RETURN tls_construct_ctos_use_srtp_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                       X509 *x, size_t chainidx);
+#endif
+EXT_RETURN tls_construct_ctos_etm_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+#ifndef OPENSSL_NO_CT
+EXT_RETURN tls_construct_ctos_sct_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+#endif
+EXT_RETURN tls_construct_ctos_ems_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_ctos_supported_versions_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                                 unsigned int context, X509 *x,
+                                                 size_t chainidx);
+EXT_RETURN tls_construct_ctos_key_share_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                        unsigned int context, X509 *x,
+                                        size_t chainidx);
+EXT_RETURN tls_construct_ctos_psk_kex_modes_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                            unsigned int context, X509 *x,
+                                            size_t chainidx);
+EXT_RETURN tls_construct_ctos_cookie_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                     X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_ctos_padding_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                      unsigned int context, X509 *x,
+                                      size_t chainidx);
+EXT_RETURN tls_construct_ctos_psk_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+EXT_RETURN tls_construct_ctos_post_handshake_auth_ntls(SSL_CONNECTION *s, WPACKET *pkt, unsigned int context,
+                                                  X509 *x, size_t chainidx);
+
+int tls_parse_stoc_server_name_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                               X509 *x, size_t chainidx);
+int tls_parse_stoc_early_data_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                              X509 *x, size_t chainidx);
+int tls_parse_stoc_maxfragmentlen_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+int tls_parse_stoc_ec_pt_formats_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                 X509 *x, size_t chainidx);
+int tls_parse_stoc_session_ticket_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+#ifndef OPENSSL_NO_OCSP
+int tls_parse_stoc_status_request_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                  X509 *x, size_t chainidx);
+#endif
+#ifndef OPENSSL_NO_CT
+int tls_parse_stoc_sct_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+#endif
+#ifndef OPENSSL_NO_NEXTPROTONEG
+int tls_parse_stoc_npn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+#endif
+int tls_parse_stoc_alpn_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                        size_t chainidx);
+#ifndef OPENSSL_NO_SRTP
+int tls_parse_stoc_use_srtp_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                            size_t chainidx);
+#endif
+int tls_parse_stoc_etm_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+int tls_parse_stoc_ems_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+int tls_parse_stoc_supported_versions_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context,
+                                      X509 *x, size_t chainidx);
+int tls_parse_stoc_key_share_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                             size_t chainidx);
+int tls_parse_stoc_cookie_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+int tls_parse_stoc_psk_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned int context, X509 *x,
+                       size_t chainidx);
+
+int tls_handle_alpn_ntls(SSL_CONNECTION *s);
+
+int tls13_save_handshake_digest_for_pha_ntls(SSL_CONNECTION *s);
+int tls13_restore_handshake_digest_for_pha_ntls(SSL_CONNECTION *s);
+
+
+
+/* NTLS stuffs */
+
+/* common functions */
+int ssl_derive_ntls(SSL_CONNECTION *s, EVP_PKEY *privkey, EVP_PKEY *pubkey, int gensecret);
+
+/* from statem.h move here */
+
+/* function define in ssl.h */
+
+__owur int SSL_CTX_has_client_custom_ext_ntls(const SSL_CTX *ctx,
+                                         unsigned int ext_type);
+
+__owur int SSL_CTX_add_client_custom_ext_ntls(SSL_CTX *ctx,
+                                         unsigned int ext_type,
+                                         custom_ext_add_cb add_cb,
+                                         custom_ext_free_cb free_cb,
+                                         void *add_arg,
+                                         custom_ext_parse_cb parse_cb,
+                                         void *parse_arg);
+
+__owur int SSL_CTX_add_server_custom_ext_ntls(SSL_CTX *ctx,
+                                         unsigned int ext_type,
+                                         custom_ext_add_cb add_cb,
+                                         custom_ext_free_cb free_cb,
+                                         void *add_arg,
+                                         custom_ext_parse_cb parse_cb,
+                                         void *parse_arg);
+
+__owur int SSL_CTX_add_custom_ext_ntls(SSL_CTX *ctx, unsigned int ext_type,
+                                  unsigned int context,
+                                  SSL_custom_ext_add_cb_ex add_cb,
+                                  SSL_custom_ext_free_cb_ex free_cb,
+                                  void *add_arg,
+                                  SSL_custom_ext_parse_cb_ex parse_cb,
+                                  void *parse_arg);
+
+__owur int SSL_extension_supported_ntls(unsigned int ext_type);
+__owur OSSL_HANDSHAKE_STATE SSL_get_state_ntls(const SSL_CONNECTION *ssl);
+int SSL_in_init_ntls(const SSL *s);
+int SSL_in_before_ntls(const SSL *s);
+int SSL_is_init_finished_ntls(const SSL *s);
+unsigned char *x509_to_asn1_ntls(const X509 *x, size_t *len);
Index: b/ssl/statem_ntls/ntls_statem_srvr.c
===================================================================
--- /dev/null
+++ b/ssl/statem_ntls/ntls_statem_srvr.c
@@ -0,0 +1,2518 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include <stdio.h>
+#include <openssl/core_names.h>
+#include "ntls_ssl_local.h"
+#include "ntls_statem_local.h"
+#include "internal/constant_time.h"
+#include "internal/cryptlib.h"
+#include <openssl/buffer.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#include <openssl/x509.h>
+#include <openssl/dh.h>
+#include <openssl/bn.h>
+#include <openssl/md5.h>
+
+#define TICKET_NONCE_SIZE       8
+
+/*
+ * ossl_statem_server_read_transition_ntls() encapsulates the logic for the allowed
+ * handshake state transitions when the server is reading messages from the
+ * client. The message type that the client has sent is provided in |mt|. The
+ * current state is in |s->statem.hand_state|.
+ *
+ * Return values are 1 for success (transition allowed) and  0 on error
+ * (transition not allowed)
+ */
+int ossl_statem_server_read_transition_ntls(SSL_CONNECTION *s, int mt)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        break;
+
+    case TLS_ST_BEFORE:
+    case TLS_ST_OK:
+        if (mt == SSL3_MT_CLIENT_HELLO) {
+            st->hand_state = TLS_ST_SR_CLNT_HELLO;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_SW_SRVR_DONE:
+        /*
+         * If we get a CKE message after a ServerDone then either
+         * 1) We didn't request a Certificate
+         * OR
+         * 2) If we did request one then
+         *      a) We allow no Certificate to be returned
+         *      AND
+         *      b) We are running SSL3 (in TLS1.0+ the client must return a 0
+         *         list if we requested a certificate)
+         */
+        if (mt == SSL3_MT_CLIENT_KEY_EXCHANGE) {
+            if (s->s3.tmp.cert_request) {
+                if (s->version == SSL3_VERSION) {
+                    if ((s->verify_mode & SSL_VERIFY_PEER)
+                        && (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {
+                        /*
+                         * This isn't an unexpected message as such - we're just
+                         * not going to accept it because we require a client
+                         * cert.
+                         */
+                        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                                      SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
+                        return 0;
+                    }
+                    st->hand_state = TLS_ST_SR_KEY_EXCH;
+                    return 1;
+                }
+            } else {
+                st->hand_state = TLS_ST_SR_KEY_EXCH;
+                return 1;
+            }
+        } else if (s->s3.tmp.cert_request) {
+            if (mt == SSL3_MT_CERTIFICATE) {
+                st->hand_state = TLS_ST_SR_CERT;
+                return 1;
+            }
+        }
+        break;
+
+    case TLS_ST_SR_CERT:
+        if (mt == SSL3_MT_CLIENT_KEY_EXCHANGE) {
+            st->hand_state = TLS_ST_SR_KEY_EXCH;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_SR_KEY_EXCH:
+        /*
+         * We should only process a CertificateVerify message if we have
+         * received a Certificate from the client. If so then |s->session->peer|
+         * will be non NULL. In some instances a CertificateVerify message is
+         * not required even if the peer has sent a Certificate (e.g. such as in
+         * the case of static DH). In that case |st->no_cert_verify| should be
+         * set.
+         */
+        if (s->session->peer == NULL || st->no_cert_verify) {
+            if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+                /*
+                 * For the ECDH ciphersuites when the client sends its ECDH
+                 * pub key in a certificate, the CertificateVerify message is
+                 * not sent. Also for GOST ciphersuites when the client uses
+                 * its key from the certificate for key exchange.
+                 */
+                st->hand_state = TLS_ST_SR_CHANGE;
+                return 1;
+            }
+        } else {
+            if (mt == SSL3_MT_CERTIFICATE_VERIFY) {
+                st->hand_state = TLS_ST_SR_CERT_VRFY;
+                return 1;
+            }
+        }
+        break;
+
+    case TLS_ST_SR_CERT_VRFY:
+        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+            st->hand_state = TLS_ST_SR_CHANGE;
+            return 1;
+        }
+        break;
+
+    case TLS_ST_SR_CHANGE:
+#ifndef OPENSSL_NO_NEXTPROTONEG
+        if (s->s3.npn_seen) {
+            if (mt == SSL3_MT_NEXT_PROTO) {
+                st->hand_state = TLS_ST_SR_NEXT_PROTO;
+                return 1;
+            }
+        } else {
+#endif
+            if (mt == SSL3_MT_FINISHED) {
+                st->hand_state = TLS_ST_SR_FINISHED;
+                return 1;
+            }
+#ifndef OPENSSL_NO_NEXTPROTONEG
+        }
+#endif
+        break;
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+    case TLS_ST_SR_NEXT_PROTO:
+        if (mt == SSL3_MT_FINISHED) {
+            st->hand_state = TLS_ST_SR_FINISHED;
+            return 1;
+        }
+        break;
+#endif
+
+    case TLS_ST_SW_FINISHED:
+        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+            st->hand_state = TLS_ST_SR_CHANGE;
+            return 1;
+        }
+        break;
+    }
+
+    /* No valid transition found */
+    SSLfatal_ntls(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
+    return 0;
+}
+
+/*
+ * Should we send a ServerKeyExchange message?
+ *
+ * Valid return values are:
+ *   1: Yes
+ *   0: No
+ */
+static int send_server_key_exchange(SSL_CONNECTION *s)
+{
+    return 1;
+}
+
+/*
+ * Should we send a CertificateRequest message?
+ *
+ * Valid return values are:
+ *   1: Yes
+ *   0: No
+ */
+int send_certificate_request_ntls(SSL_CONNECTION *s)
+{
+    if (
+           /* don't request cert unless asked for it: */
+           s->verify_mode & SSL_VERIFY_PEER
+           /*
+            * if SSL_VERIFY_CLIENT_ONCE is set, don't request cert
+            * a second time:
+            */
+           && (s->certreqs_sent < 1 ||
+               !(s->verify_mode & SSL_VERIFY_CLIENT_ONCE))
+           /*
+            * never request cert in anonymous ciphersuites (see
+            * section "Certificate request" in SSL 3 drafts and in
+            * RFC 2246):
+            */
+           && (!(s->s3.tmp.new_cipher->algorithm_auth & SSL_aNULL)
+               /*
+                * ... except when the application insists on
+                * verification (against the specs, but statem_clnt.c accepts
+                * this for SSL 3)
+                */
+               || (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
+           /* don't request certificate for SRP auth */
+           && !(s->s3.tmp.new_cipher->algorithm_auth & SSL_aSRP)
+           /*
+            * With normal PSK Certificates and Certificate Requests
+            * are omitted
+            */
+           && !(s->s3.tmp.new_cipher->algorithm_auth & SSL_aPSK)) {
+        return 1;
+    }
+
+    return 0;
+}
+
+/*
+ * ossl_statem_server_write_transition_ntls() works out what handshake state to move
+ * to next when the server is writing messages to be sent to the client.
+ */
+WRITE_TRAN ossl_statem_server_write_transition_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    /*
+     * Note that before the ClientHello we don't know what version we are going
+     * to negotiate yet, so we don't take this branch until later
+     */
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return WRITE_TRAN_ERROR;
+
+    case TLS_ST_OK:
+        if (st->request_state == TLS_ST_SW_HELLO_REQ) {
+            /* We must be trying to renegotiate */
+            st->hand_state = TLS_ST_SW_HELLO_REQ;
+            st->request_state = TLS_ST_BEFORE;
+            return WRITE_TRAN_CONTINUE;
+        }
+        /* Must be an incoming ClientHello */
+        if (!tls_setup_handshake_ntls(s)) {
+            /* SSLfatal_ntls() already called */
+            return WRITE_TRAN_ERROR;
+        }
+        /* Fall through */
+
+    case TLS_ST_BEFORE:
+        /* Just go straight to trying to read from the client */
+        return WRITE_TRAN_FINISHED;
+
+    case TLS_ST_SW_HELLO_REQ:
+        st->hand_state = TLS_ST_OK;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SR_CLNT_HELLO:
+        if (s->renegotiate == 0 && !SSL_IS_FIRST_HANDSHAKE(s)) {
+            /* We must have rejected the renegotiation */
+            st->hand_state = TLS_ST_OK;
+            return WRITE_TRAN_CONTINUE;
+        } else {
+            st->hand_state = TLS_ST_SW_SRVR_HELLO;
+        }
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SW_SRVR_HELLO:
+        if (s->hit) {
+            if (s->ext.ticket_expected)
+                st->hand_state = TLS_ST_SW_SESSION_TICKET;
+            else
+                st->hand_state = TLS_ST_SW_CHANGE;
+        } else {
+            /* Check if it is anon DH or anon ECDH, */
+            /* normal PSK or SRP */
+            if (!(s->s3.tmp.new_cipher->algorithm_auth &
+                  (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {
+                st->hand_state = TLS_ST_SW_CERT;
+            } else if (send_server_key_exchange(s)) {
+                st->hand_state = TLS_ST_SW_KEY_EXCH;
+            } else if (send_certificate_request_ntls(s)) {
+                st->hand_state = TLS_ST_SW_CERT_REQ;
+            } else {
+                st->hand_state = TLS_ST_SW_SRVR_DONE;
+            }
+        }
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SW_CERT:
+        if (s->ext.status_expected) {
+            st->hand_state = TLS_ST_SW_CERT_STATUS;
+            return WRITE_TRAN_CONTINUE;
+        }
+        /* Fall through */
+
+    case TLS_ST_SW_CERT_STATUS:
+        if (send_server_key_exchange(s)) {
+            st->hand_state = TLS_ST_SW_KEY_EXCH;
+            return WRITE_TRAN_CONTINUE;
+        }
+        /* Fall through */
+
+    case TLS_ST_SW_KEY_EXCH:
+        if (send_certificate_request_ntls(s)) {
+            st->hand_state = TLS_ST_SW_CERT_REQ;
+            return WRITE_TRAN_CONTINUE;
+        }
+        /* Fall through */
+
+    case TLS_ST_SW_CERT_REQ:
+        st->hand_state = TLS_ST_SW_SRVR_DONE;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SW_SRVR_DONE:
+        return WRITE_TRAN_FINISHED;
+
+    case TLS_ST_SR_FINISHED:
+        if (s->hit) {
+            st->hand_state = TLS_ST_OK;
+            return WRITE_TRAN_CONTINUE;
+        } else if (s->ext.ticket_expected) {
+            st->hand_state = TLS_ST_SW_SESSION_TICKET;
+        } else {
+            st->hand_state = TLS_ST_SW_CHANGE;
+        }
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SW_SESSION_TICKET:
+        st->hand_state = TLS_ST_SW_CHANGE;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SW_CHANGE:
+        st->hand_state = TLS_ST_SW_FINISHED;
+        return WRITE_TRAN_CONTINUE;
+
+    case TLS_ST_SW_FINISHED:
+        if (s->hit) {
+            return WRITE_TRAN_FINISHED;
+        }
+        st->hand_state = TLS_ST_OK;
+        return WRITE_TRAN_CONTINUE;
+    }
+}
+
+/*
+ * Perform any pre work that needs to be done prior to sending a message from
+ * the server to the client.
+ */
+WORK_STATE ossl_statem_server_pre_work_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    OSSL_STATEM *st = &s->statem;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+
+    switch (st->hand_state) {
+    default:
+        /* No pre work to be done */
+        break;
+
+    case TLS_ST_SW_HELLO_REQ:
+        s->shutdown = 0;
+        break;
+
+    case TLS_ST_SW_SRVR_HELLO:
+        break;
+
+    case TLS_ST_SW_SRVR_DONE:
+        return WORK_FINISHED_CONTINUE;
+
+    case TLS_ST_SW_SESSION_TICKET:
+        break;
+
+    case TLS_ST_SW_CHANGE:
+        /* Writes to s->session are only safe for initial handshakes */
+        if (s->session->cipher == NULL) {
+            s->session->cipher = s->s3.tmp.new_cipher;
+        } else if (s->session->cipher != s->s3.tmp.new_cipher) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return WORK_ERROR;
+        }
+        if (!ssl->method->ssl3_enc->setup_key_block(s)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+        return WORK_FINISHED_CONTINUE;
+
+    case TLS_ST_EARLY_DATA:
+        if (s->early_data_state != SSL_EARLY_DATA_ACCEPTING
+                && (s->s3.flags & TLS1_FLAGS_STATELESS) == 0)
+            return WORK_FINISHED_CONTINUE;
+        /* Fall through */
+
+    case TLS_ST_OK:
+        /* Calls SSLfatal_ntls() as required */
+        return tls_finish_handshake_ntls(s, wst, 1, 1);
+    }
+
+    return WORK_FINISHED_CONTINUE;
+}
+
+/*
+ * Perform any work that needs to be done after sending a message from the
+ * server to the client.
+ */
+WORK_STATE ossl_statem_server_post_work_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    OSSL_STATEM *st = &s->statem;
+    SSL *ssl = SSL_CONNECTION_GET_USER_SSL(s);
+    s->init_num = 0;
+
+    switch (st->hand_state) {
+    default:
+        /* No post work to be done */
+        break;
+
+    case TLS_ST_SW_HELLO_REQ:
+        if (statem_flush_ntls(s) != 1)
+            return WORK_MORE_A;
+        if (!ssl3_init_finished_mac(s)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+        break;
+
+    case TLS_ST_SW_SRVR_HELLO:
+            break;
+
+    case TLS_ST_SW_CHANGE:
+        if (s->hello_retry_request == SSL_HRR_PENDING) {
+            if (!statem_flush_ntls(s))
+                return WORK_MORE_A;
+            break;
+        }
+
+        if (!ssl->method->ssl3_enc->change_cipher_state(s,
+                                                      SSL3_CHANGE_CIPHER_SERVER_WRITE))
+        {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+
+        break;
+
+    case TLS_ST_SW_SRVR_DONE:
+        if (statem_flush_ntls(s) != 1)
+            return WORK_MORE_A;
+        break;
+
+    case TLS_ST_SW_FINISHED:
+        if (statem_flush_ntls(s) != 1)
+            return WORK_MORE_A;
+        break;
+
+    case TLS_ST_SW_CERT_REQ:
+        if (s->post_handshake_auth == SSL_PHA_REQUEST_PENDING) {
+            if (statem_flush_ntls(s) != 1)
+                return WORK_MORE_A;
+        }
+        break;
+
+    case TLS_ST_SW_KEY_UPDATE:
+        if (statem_flush_ntls(s) != 1)
+            return WORK_MORE_A;
+        if (!tls13_update_key(s, 1)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+        break;
+
+    case TLS_ST_SW_SESSION_TICKET:
+        clear_sys_error();
+        break;
+    }
+
+    return WORK_FINISHED_CONTINUE;
+}
+
+/*
+ * Get the message construction function and message type for sending from the
+ * server
+ *
+ * Valid return values are:
+ *   1: Success
+ *   0: Error
+ */
+int ossl_statem_server_construct_message_ntls(SSL_CONNECTION *s, WPACKET *pkt,
+                                         confunc_f *confunc, int *mt)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_HANDSHAKE_STATE);
+        return 0;
+
+    case TLS_ST_SW_CHANGE:
+        *confunc = tls_construct_change_cipher_spec_ntls;
+        *mt = SSL3_MT_CHANGE_CIPHER_SPEC;
+        break;
+
+    case TLS_ST_SW_HELLO_REQ:
+        /* No construction function needed */
+        *confunc = NULL;
+        *mt = SSL3_MT_HELLO_REQUEST;
+        break;
+
+    case TLS_ST_SW_SRVR_HELLO:
+        *confunc = tls_construct_server_hello_ntls;
+        *mt = SSL3_MT_SERVER_HELLO;
+        break;
+
+    case TLS_ST_SW_CERT:
+        *confunc = tls_construct_server_certificate_ntls;
+        *mt = SSL3_MT_CERTIFICATE;
+        break;
+
+    case TLS_ST_SW_KEY_EXCH:
+        *confunc = tls_construct_server_key_exchange_ntls;
+        *mt = SSL3_MT_SERVER_KEY_EXCHANGE;
+        break;
+
+    case TLS_ST_SW_CERT_REQ:
+        *confunc = tls_construct_certificate_request_ntls;
+        *mt = SSL3_MT_CERTIFICATE_REQUEST;
+        break;
+
+    case TLS_ST_SW_SRVR_DONE:
+        *confunc = tls_construct_server_done_ntls;
+        *mt = SSL3_MT_SERVER_DONE;
+        break;
+
+    case TLS_ST_SW_SESSION_TICKET:
+        *confunc = tls_construct_new_session_ticket_ntls;
+        *mt = SSL3_MT_NEWSESSION_TICKET;
+        break;
+
+    case TLS_ST_SW_CERT_STATUS:
+        *confunc = tls_construct_cert_status_ntls;
+        *mt = SSL3_MT_CERTIFICATE_STATUS;
+        break;
+
+    case TLS_ST_SW_FINISHED:
+        *confunc = tls_construct_finished_ntls;
+        *mt = SSL3_MT_FINISHED;
+        break;
+
+    case TLS_ST_EARLY_DATA:
+        *confunc = NULL;
+        *mt = SSL3_MT_DUMMY;
+        break;
+    }
+
+    return 1;
+}
+
+/*
+ * Maximum size (excluding the Handshake header) of a ClientHello message,
+ * calculated as follows:
+ *
+ *  2 + # client_version
+ *  32 + # only valid length for random
+ *  1 + # length of session_id
+ *  32 + # maximum size for session_id
+ *  2 + # length of cipher suites
+ *  2^16-2 + # maximum length of cipher suites array
+ *  1 + # length of compression_methods
+ *  2^8-1 + # maximum length of compression methods
+ *  2 + # length of extensions
+ *  2^16-1 # maximum length of extensions
+ */
+#define CLIENT_HELLO_MAX_LENGTH         131396
+
+#define CLIENT_KEY_EXCH_MAX_LENGTH      2048
+#define NEXT_PROTO_MAX_LENGTH           514
+
+/*
+ * Returns the maximum allowed length for the current message that we are
+ * reading. Excludes the message header.
+ */
+size_t ossl_statem_server_max_message_size_ntls(SSL_CONNECTION *s)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        return 0;
+
+    case TLS_ST_SR_CLNT_HELLO:
+        return CLIENT_HELLO_MAX_LENGTH;
+
+    case TLS_ST_SR_CERT:
+        return s->max_cert_list;
+
+    case TLS_ST_SR_KEY_EXCH:
+        return CLIENT_KEY_EXCH_MAX_LENGTH;
+
+    case TLS_ST_SR_CERT_VRFY:
+        return SSL3_RT_MAX_PLAIN_LENGTH;
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+    case TLS_ST_SR_NEXT_PROTO:
+        return NEXT_PROTO_MAX_LENGTH;
+#endif
+
+    case TLS_ST_SR_CHANGE:
+        return CCS_MAX_LENGTH;
+
+    case TLS_ST_SR_FINISHED:
+        return FINISHED_MAX_LENGTH;
+    }
+}
+
+/*
+ * Process a message that the server has received from the client.
+ */
+MSG_PROCESS_RETURN ossl_statem_server_process_message_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+
+    case TLS_ST_SR_CLNT_HELLO:
+        return tls_process_client_hello_ntls(s, pkt);
+
+    case TLS_ST_SR_END_OF_EARLY_DATA:
+        return tls_process_end_of_early_data_ntls(s, pkt);
+
+    case TLS_ST_SR_CERT:
+        return tls_process_client_certificate_ntls(s, pkt);
+
+    case TLS_ST_SR_KEY_EXCH:
+        return tls_process_client_key_exchange_ntls(s, pkt);
+
+    case TLS_ST_SR_CERT_VRFY:
+        return tls_process_cert_verify_ntls(s, pkt);
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+    case TLS_ST_SR_NEXT_PROTO:
+        return tls_process_next_proto_ntls(s, pkt);
+#endif
+
+    case TLS_ST_SR_CHANGE:
+        return tls_process_change_cipher_spec_ntls(s, pkt);
+
+    case TLS_ST_SR_FINISHED:
+        return tls_process_finished_ntls(s, pkt);
+    }
+}
+
+/*
+ * Perform any further processing required following the receipt of a message
+ * from the client
+ */
+WORK_STATE ossl_statem_server_post_process_message_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    OSSL_STATEM *st = &s->statem;
+
+    switch (st->hand_state) {
+    default:
+        /* Shouldn't happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return WORK_ERROR;
+
+    case TLS_ST_SR_CLNT_HELLO:
+        return tls_post_process_client_hello_ntls(s, wst);
+
+    case TLS_ST_SR_KEY_EXCH:
+        return tls_post_process_client_key_exchange_ntls(s, wst);
+    }
+}
+
+/*-
+ * ssl_check_for_safari attempts to fingerprint Safari using OS X
+ * SecureTransport using the TLS extension block in |hello|.
+ * Safari, since 10.6, sends exactly these extensions, in this order:
+ *   SNI,
+ *   elliptic_curves
+ *   ec_point_formats
+ *   signature_algorithms (for TLSv1.2 only)
+ *
+ * We wish to fingerprint Safari because they broke ECDHE-ECDSA support in 10.8,
+ * but they advertise support. So enabling ECDHE-ECDSA ciphers breaks them.
+ * Sadly we cannot differentiate 10.6, 10.7 and 10.8.4 (which work), from
+ * 10.8..10.8.3 (which don't work).
+ */
+static void ssl_check_for_safari(SSL_CONNECTION *s, const CLIENTHELLO_MSG *hello)
+{
+    static const unsigned char kSafariExtensionsBlock[] = {
+        0x00, 0x0a,             /* elliptic_curves extension */
+        0x00, 0x08,             /* 8 bytes */
+        0x00, 0x06,             /* 6 bytes of curve ids */
+        0x00, 0x17,             /* P-256 */
+        0x00, 0x18,             /* P-384 */
+        0x00, 0x19,             /* P-521 */
+
+        0x00, 0x0b,             /* ec_point_formats */
+        0x00, 0x02,             /* 2 bytes */
+        0x01,                   /* 1 point format */
+        0x00,                   /* uncompressed */
+        /* The following is only present in TLS 1.2 */
+        0x00, 0x0d,             /* signature_algorithms */
+        0x00, 0x0c,             /* 12 bytes */
+        0x00, 0x0a,             /* 10 bytes */
+        0x05, 0x01,             /* SHA-384/RSA */
+        0x04, 0x01,             /* SHA-256/RSA */
+        0x02, 0x01,             /* SHA-1/RSA */
+        0x04, 0x03,             /* SHA-256/ECDSA */
+        0x02, 0x03,             /* SHA-1/ECDSA */
+    };
+    /* Length of the common prefix (first two extensions). */
+    static const size_t kSafariCommonExtensionsLength = 18;
+    unsigned int type;
+    PACKET sni, tmppkt;
+    size_t ext_len;
+
+    tmppkt = hello->extensions;
+
+    if (!PACKET_forward(&tmppkt, 2)
+        || !PACKET_get_net_2(&tmppkt, &type)
+        || !PACKET_get_length_prefixed_2(&tmppkt, &sni)) {
+        return;
+    }
+
+    if (type != TLSEXT_TYPE_server_name)
+        return;
+
+    ext_len = TLS1_get_client_version(
+        SSL_CONNECTION_GET_SSL(s)) >= TLS1_2_VERSION ?
+                    sizeof(kSafariExtensionsBlock) : kSafariCommonExtensionsLength;
+
+    s->s3.is_probably_safari = PACKET_equal(&tmppkt, kSafariExtensionsBlock,
+                                             ext_len);
+}
+
+#define RENEG_OPTIONS_OK(options) \
+    ((options & SSL_OP_NO_RENEGOTIATION) == 0 \
+     && (options & SSL_OP_ALLOW_CLIENT_RENEGOTIATION) != 0)
+
+MSG_PROCESS_RETURN tls_process_client_hello_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    PACKET session_id, compression, extensions, cookie;
+    static const unsigned char null_compression = 0;
+    CLIENTHELLO_MSG *clienthello = NULL;
+
+    /* Check if this is actually an unexpected renegotiation ClientHello */
+    if (s->renegotiate == 0 && !SSL_IS_FIRST_HANDSHAKE(s)) {
+        if (!ossl_assert(!SSL_CONNECTION_IS_TLS13(s))) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+        if (!RENEG_OPTIONS_OK(s->options)
+                || (!s->s3.send_connection_binding
+                    && (s->options
+                        & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) == 0)) {
+            ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
+            return MSG_PROCESS_FINISHED_READING;
+        }
+        s->renegotiate = 1;
+        s->new_session = 1;
+    }
+
+    clienthello = OPENSSL_zalloc(sizeof(*clienthello));
+    if (clienthello == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /*
+     * First, parse the raw ClientHello data into the CLIENTHELLO_MSG structure.
+     */
+    clienthello->isv2 = RECORD_LAYER_is_sslv2_record(&s->rlayer);
+    PACKET_null_init(&cookie);
+
+    if (clienthello->isv2) {
+        unsigned int mt;
+
+        if (!SSL_IS_FIRST_HANDSHAKE(s)
+                || s->hello_retry_request != SSL_HRR_NONE) {
+            SSLfatal_ntls(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
+            goto err;
+        }
+
+        /*-
+         * An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
+         * header is sent directly on the wire, not wrapped as a TLS
+         * record. Our record layer just processes the message length and passes
+         * the rest right through. Its format is:
+         * Byte  Content
+         * 0-1   msg_length - decoded by the record layer
+         * 2     msg_type - s->init_msg points here
+         * 3-4   version
+         * 5-6   cipher_spec_length
+         * 7-8   session_id_length
+         * 9-10  challenge_length
+         * ...   ...
+         */
+
+        if (!PACKET_get_1(pkt, &mt)
+            || mt != SSL2_MT_CLIENT_HELLO) {
+            /*
+             * Should never happen. We should have tested this in the record
+             * layer in order to have determined that this is a SSLv2 record
+             * in the first place
+             */
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+    }
+
+    if (!PACKET_get_net_2(pkt, &clienthello->legacy_version)) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);
+        goto err;
+    }
+
+    /* Parse the message and load client random. */
+    if (clienthello->isv2) {
+        /*
+         * Handle an SSLv2 backwards compatible ClientHello
+         * Note, this is only for SSLv3+ using the backward compatible format.
+         * Real SSLv2 is not supported, and is rejected below.
+         */
+        unsigned int ciphersuite_len, session_id_len, challenge_len;
+        PACKET challenge;
+
+        if (!PACKET_get_net_2(pkt, &ciphersuite_len)
+            || !PACKET_get_net_2(pkt, &session_id_len)
+            || !PACKET_get_net_2(pkt, &challenge_len)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_RECORD_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (session_id_len > SSL_MAX_SSL_SESSION_ID_LENGTH) {
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (!PACKET_get_sub_packet(pkt, &clienthello->ciphersuites,
+                                   ciphersuite_len)
+            || !PACKET_copy_bytes(pkt, clienthello->session_id, session_id_len)
+            || !PACKET_get_sub_packet(pkt, &challenge, challenge_len)
+            /* No extensions. */
+            || PACKET_remaining(pkt) != 0) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_RECORD_LENGTH_MISMATCH);
+            goto err;
+        }
+        clienthello->session_id_len = session_id_len;
+
+        /* Load the client random and compression list. We use SSL3_RANDOM_SIZE
+         * here rather than sizeof(clienthello->random) because that is the limit
+         * for SSLv3 and it is fixed. It won't change even if
+         * sizeof(clienthello->random) does.
+         */
+        challenge_len = challenge_len > SSL3_RANDOM_SIZE
+                        ? SSL3_RANDOM_SIZE : challenge_len;
+        memset(clienthello->random, 0, SSL3_RANDOM_SIZE);
+        if (!PACKET_copy_bytes(&challenge,
+                               clienthello->random + SSL3_RANDOM_SIZE -
+                               challenge_len, challenge_len)
+            /* Advertise only null compression. */
+            || !PACKET_buf_init(&compression, &null_compression, 1)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        PACKET_null_init(&clienthello->extensions);
+    } else {
+        /* Regular ClientHello. */
+        if (!PACKET_copy_bytes(pkt, clienthello->random, SSL3_RANDOM_SIZE)
+            || !PACKET_get_length_prefixed_1(pkt, &session_id)
+            || !PACKET_copy_all(&session_id, clienthello->session_id,
+                    SSL_MAX_SSL_SESSION_ID_LENGTH,
+                    &clienthello->session_id_len)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (!PACKET_get_length_prefixed_2(pkt, &clienthello->ciphersuites)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (!PACKET_get_length_prefixed_1(pkt, &compression)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        /* Could be empty. */
+        if (PACKET_remaining(pkt) == 0) {
+            PACKET_null_init(&clienthello->extensions);
+        } else {
+            if (!PACKET_get_length_prefixed_2(pkt, &clienthello->extensions)
+                    || PACKET_remaining(pkt) != 0) {
+                SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+                goto err;
+            }
+        }
+    }
+
+    if (!PACKET_copy_all(&compression, clienthello->compressions,
+                         MAX_COMPRESSIONS_SIZE,
+                         &clienthello->compressions_len)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /* Preserve the raw extensions PACKET for later use */
+    extensions = clienthello->extensions;
+    if (!tls_collect_extensions_ntls(s, &extensions, SSL_EXT_CLIENT_HELLO,
+                                &clienthello->pre_proc_exts,
+                                &clienthello->pre_proc_exts_len, 1)) {
+        /* SSLfatal_ntls already been called */
+        goto err;
+    }
+    s->clienthello = clienthello;
+
+    return MSG_PROCESS_CONTINUE_PROCESSING;
+
+ err:
+    if (clienthello != NULL)
+        OPENSSL_free(clienthello->pre_proc_exts);
+    OPENSSL_free(clienthello);
+
+    return MSG_PROCESS_ERROR;
+}
+
+static int tls_early_post_process_client_hello(SSL_CONNECTION *s)
+{
+    unsigned int j;
+    int i, al = SSL_AD_INTERNAL_ERROR;
+    int protverr;
+    size_t loop;
+    unsigned long id;
+
+    const SSL_CIPHER *c;
+    STACK_OF(SSL_CIPHER) *ciphers = NULL;
+    STACK_OF(SSL_CIPHER) *scsvs = NULL;
+    CLIENTHELLO_MSG *clienthello = s->clienthello;
+    DOWNGRADE dgrd = DOWNGRADE_NONE;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+
+    /* Finished parsing the ClientHello, now we can start processing it */
+    /* Give the ClientHello callback a crack at things */
+    if (sctx->client_hello_cb != NULL) {
+        /* A failure in the ClientHello callback terminates the connection. */
+        switch (sctx->client_hello_cb(ussl, &al, sctx->client_hello_cb_arg)) {
+        case SSL_CLIENT_HELLO_SUCCESS:
+            break;
+        case SSL_CLIENT_HELLO_RETRY:
+            s->rwstate = SSL_CLIENT_HELLO_CB;
+            return -1;
+        case SSL_CLIENT_HELLO_ERROR:
+        default:
+            SSLfatal_ntls(s, al, SSL_R_CALLBACK_FAILED);
+            goto err;
+        }
+    }
+
+    /* Set up the client_random */
+    memcpy(s->s3.client_random, clienthello->random, SSL3_RANDOM_SIZE);
+
+    /* Choose the version */
+
+    if (clienthello->isv2) {
+        if (clienthello->legacy_version == NTLS_VERSION) {
+            /* do nothing */
+        } else if (clienthello->legacy_version == SSL2_VERSION
+                || (clienthello->legacy_version & 0xff00)
+                   != (SSL3_VERSION_MAJOR << 8)) {
+            /*
+             * This is real SSLv2 or something completely unknown. We don't
+             * support it.
+             */
+            SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNKNOWN_PROTOCOL);
+            goto err;
+        }
+        /* SSLv3/TLS */
+        s->client_version = clienthello->legacy_version;
+    }
+    /*
+     * Do SSL/TLS version negotiation if applicable. Version negotiation comes later.
+     */
+    protverr = ssl_choose_server_version_ntls(s, clienthello, &dgrd);
+
+    if (protverr) {
+        if (SSL_IS_FIRST_HANDSHAKE(s)) {
+            /* like ssl3_get_record, send alert using remote version number */
+            s->version = s->client_version = clienthello->legacy_version;
+        }
+        SSLfatal_ntls(s, SSL_AD_PROTOCOL_VERSION, protverr);
+        goto err;
+    }
+
+    s->hit = 0;
+
+    if (!ssl_cache_cipherlist(s, &clienthello->ciphersuites,
+                              clienthello->isv2) ||
+        !ossl_bytes_to_cipher_list(s, &clienthello->ciphersuites, &ciphers, &scsvs,
+                              clienthello->isv2, 1)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    s->s3.send_connection_binding = 0;
+    /* Check what signalling cipher-suite values were received. */
+    if (scsvs != NULL) {
+        for(i = 0; i < sk_SSL_CIPHER_num(scsvs); i++) {
+            c = sk_SSL_CIPHER_value(scsvs, i);
+            if (SSL_CIPHER_get_id(c) == SSL3_CK_SCSV) {
+                if (s->renegotiate) {
+                    /* SCSV is fatal if renegotiating */
+                    SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                                  SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
+                    goto err;
+                }
+                s->s3.send_connection_binding = 1;
+            } else if (SSL_CIPHER_get_id(c) == SSL3_CK_FALLBACK_SCSV &&
+                       !ssl_check_version_downgrade_ntls(s)) {
+                /*
+                 * This SCSV indicates that the client previously tried
+                 * a higher version.  We should fail if the current version
+                 * is an unexpected downgrade, as that indicates that the first
+                 * connection may have been tampered with in order to trigger
+                 * an insecure downgrade.
+                 */
+                SSLfatal_ntls(s, SSL_AD_INAPPROPRIATE_FALLBACK,
+                              SSL_R_INAPPROPRIATE_FALLBACK);
+                goto err;
+            }
+        }
+    }
+
+    /*
+     * We don't allow resumption in a backwards compatible ClientHello.
+     * In TLS1.1+, session_id MUST be empty.
+     *
+     * Versions before 0.9.7 always allow clients to resume sessions in
+     * renegotiation. 0.9.7 and later allow this by default, but optionally
+     * ignore resumption requests with flag
+     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather
+     * than a change to default behavior so that applications relying on
+     * this for security won't even compile against older library versions).
+     * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to
+     * request renegotiation but not a new session (s->new_session remains
+     * unset): for servers, this essentially just means that the
+     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION setting will be
+     * ignored.
+     */
+    if (clienthello->isv2 ||
+        (s->new_session &&
+         (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {
+        if (!ssl_get_new_session(s, 1)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    } else {
+        i = ssl_get_prev_session(s, clienthello);
+        if (i == 1) {
+            /* previous session */
+            s->hit = 1;
+        } else if (i == -1) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        } else {
+            /* i == 0 */
+            if (!ssl_get_new_session(s, 1)) {
+                /* SSLfatal_ntls() already called */
+                goto err;
+            }
+        }
+    }
+
+
+
+    /*
+     * If it is a hit, check that the cipher is in the list. In TLSv1.3 we check
+     * ciphersuite compatibility with the session as part of resumption.
+     */
+    if (s->hit) {
+        j = 0;
+        id = s->session->cipher->id;
+
+        OSSL_TRACE_BEGIN(TLS_CIPHER) {
+            BIO_printf(trc_out, "client sent %d ciphers\n",
+                       sk_SSL_CIPHER_num(ciphers));
+        }
+        for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
+            c = sk_SSL_CIPHER_value(ciphers, i);
+            if (trc_out != NULL)
+                BIO_printf(trc_out, "client [%2d of %2d]:%s\n", i,
+                           sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));
+            if (c->id == id) {
+                j = 1;
+                break;
+            }
+        }
+        if (j == 0) {
+            /*
+             * we need to have the cipher in the cipher list if we are asked
+             * to reuse it
+             */
+            SSLfatal_ntls(s, SSL_AD_ILLEGAL_PARAMETER,
+                          SSL_R_REQUIRED_CIPHER_MISSING);
+            OSSL_TRACE_CANCEL(TLS_CIPHER);
+            goto err;
+        }
+        OSSL_TRACE_END(TLS_CIPHER);
+    }
+
+    for (loop = 0; loop < clienthello->compressions_len; loop++) {
+        if (clienthello->compressions[loop] == 0)
+            break;
+    }
+
+    if (loop >= clienthello->compressions_len) {
+        /* no compress */
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_NO_COMPRESSION_SPECIFIED);
+        goto err;
+    }
+
+    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)
+        ssl_check_for_safari(s, clienthello);
+
+    /* TLS extensions */
+    if (!tls_parse_all_extensions_ntls(s, SSL_EXT_CLIENT_HELLO,
+                                       clienthello->pre_proc_exts, NULL, 0, 1)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    /*
+     * Check if we want to use external pre-shared secret for this handshake
+     * for not reused session only. We need to generate server_random before
+     * calling tls_session_secret_cb in order to allow SessionTicket
+     * processing to use it in key derivation.
+     */
+    {
+        unsigned char *pos;
+        pos = s->s3.server_random;
+        if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE, dgrd) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+    }
+
+    if (!s->hit && !tls1_set_server_sigalgs(s)) {
+        /* SSLfatal() already called */
+        goto err;
+    }
+
+    if (!s->hit
+            && s->version >= TLS1_VERSION
+            && s->ext.session_secret_cb) {
+        const SSL_CIPHER *pref_cipher = NULL;
+        /*
+         * s->session->master_key_length is a size_t, but this is an int for
+         * backwards compat reasons
+         */
+        int master_key_length;
+
+        master_key_length = sizeof(s->session->master_key);
+        if (s->ext.session_secret_cb(ussl, s->session->master_key,
+                                     &master_key_length, ciphers,
+                                     &pref_cipher,
+                                     s->ext.session_secret_cb_arg)
+                && master_key_length > 0) {
+            s->session->master_key_length = master_key_length;
+            s->hit = 1;
+            s->peer_ciphers = ciphers;
+            s->session->verify_result = X509_V_OK;
+
+            ciphers = NULL;
+
+            /* check if some cipher was preferred by call back */
+            if (pref_cipher == NULL)
+                pref_cipher = ssl3_choose_cipher(s, s->peer_ciphers,
+                                                 SSL_get_ciphers(ssl));
+            if (pref_cipher == NULL) {
+                SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_CIPHER);
+                goto err;
+            }
+
+            s->session->cipher = pref_cipher;
+            sk_SSL_CIPHER_free(s->cipher_list);
+            s->cipher_list = sk_SSL_CIPHER_dup(s->peer_ciphers);
+            sk_SSL_CIPHER_free(s->cipher_list_by_id);
+            s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->peer_ciphers);
+        }
+    }
+
+    /*
+     * Worst case, we will use the NULL compression, but if we have other
+     * options, we will now look for them.  We have complen-1 compression
+     * algorithms from the client, starting at q.
+     */
+    s->s3.tmp.new_compression = NULL;
+
+    /*
+     * If compression is disabled we'd better not try to resume a session
+     * using compression.
+     */
+    if (s->session->compress_meth != 0) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_INCONSISTENT_COMPRESSION);
+        goto err;
+    }
+
+
+    /*
+     * Given s->peer_ciphers and SSL_get_ciphers, we must pick a cipher
+     */
+
+    if (!s->hit) {
+        sk_SSL_CIPHER_free(s->peer_ciphers);
+        s->peer_ciphers = ciphers;
+        if (ciphers == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+        ciphers = NULL;
+    }
+
+    if (!s->hit) {
+        s->session->compress_meth = 0;
+    }
+
+    sk_SSL_CIPHER_free(ciphers);
+    sk_SSL_CIPHER_free(scsvs);
+    OPENSSL_free(clienthello->pre_proc_exts);
+    OPENSSL_free(s->clienthello);
+    s->clienthello = NULL;
+    return 1;
+ err:
+    sk_SSL_CIPHER_free(ciphers);
+    sk_SSL_CIPHER_free(scsvs);
+    OPENSSL_free(clienthello->pre_proc_exts);
+    OPENSSL_free(s->clienthello);
+    s->clienthello = NULL;
+
+    return 0;
+}
+
+/*
+ * Call the status request callback if needed. Upon success, returns 1.
+ * Upon failure, returns 0.
+ */
+static int tls_handle_status_request(SSL_CONNECTION *s)
+{
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    s->ext.status_expected = 0;
+
+    /*
+     * If status request then ask callback what to do. Note: this must be
+     * called after servername callbacks in case the certificate has changed,
+     * and must be called after the cipher has been chosen because this may
+     * influence which certificate is sent
+     */
+    if (s->ext.status_type != TLSEXT_STATUSTYPE_nothing && sctx != NULL
+            && sctx->ext.status_cb != NULL) {
+        int ret;
+
+        /* If no certificate can't return certificate status */
+        if (s->s3.tmp.cert != NULL) {
+            /*
+             * Set current certificate to one we will use so SSL_get_certificate
+             * et al can pick it up.
+             */
+            s->cert->key = s->s3.tmp.cert;
+            ret = sctx->ext.status_cb(SSL_CONNECTION_GET_USER_SSL(s)
+                                    , sctx->ext.status_arg);
+            switch (ret) {
+                /* We don't want to send a status request response */
+            case SSL_TLSEXT_ERR_NOACK:
+                s->ext.status_expected = 0;
+                break;
+                /* status request response should be sent */
+            case SSL_TLSEXT_ERR_OK:
+                if (s->ext.ocsp.resp)
+                    s->ext.status_expected = 1;
+                break;
+                /* something bad happened */
+            case SSL_TLSEXT_ERR_ALERT_FATAL:
+            default:
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_CLIENTHELLO_TLSEXT);
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+
+/*
+ * Call the alpn_select callback if needed. Upon success, returns 1.
+ * Upon failure, returns 0.
+ */
+int tls_handle_alpn_ntls(SSL_CONNECTION *s)
+{
+    const unsigned char *selected = NULL;
+    unsigned char selected_len = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (sctx->ext.alpn_select_cb != NULL && s->s3.alpn_proposed != NULL) {
+        int r = sctx->ext.alpn_select_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                           &selected, &selected_len,
+                                           s->s3.alpn_proposed,
+                                           (unsigned int)s->s3.alpn_proposed_len,
+                                           sctx->ext.alpn_select_cb_arg);
+
+        if (r == SSL_TLSEXT_ERR_OK) {
+            OPENSSL_free(s->s3.alpn_selected);
+            s->s3.alpn_selected = OPENSSL_memdup(selected, selected_len);
+            if (s->s3.alpn_selected == NULL) {
+                s->s3.alpn_selected_len = 0;
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                return 0;
+            }
+            s->s3.alpn_selected_len = selected_len;
+#ifndef OPENSSL_NO_NEXTPROTONEG
+            /* ALPN takes precedence over NPN. */
+            s->s3.npn_seen = 0;
+#endif
+
+            /* Check ALPN is consistent with session */
+            if (s->session->ext.alpn_selected == NULL
+                        || selected_len != s->session->ext.alpn_selected_len
+                        || memcmp(selected, s->session->ext.alpn_selected,
+                                  selected_len) != 0) {
+                /* Not consistent so can't be used for early_data */
+                s->ext.early_data_ok = 0;
+
+                if (!s->hit) {
+                    /*
+                     * This is a new session and so alpn_selected should have
+                     * been initialised to NULL. We should update it with the
+                     * selected ALPN.
+                     */
+                    if (!ossl_assert(s->session->ext.alpn_selected == NULL)) {
+                        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                                      ERR_R_INTERNAL_ERROR);
+                        return 0;
+                    }
+                    s->session->ext.alpn_selected = OPENSSL_memdup(selected,
+                                                                   selected_len);
+                    if (s->session->ext.alpn_selected == NULL) {
+                        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                                      ERR_R_INTERNAL_ERROR);
+                        return 0;
+                    }
+                    s->session->ext.alpn_selected_len = selected_len;
+                }
+            }
+
+            return 1;
+        } else if (r != SSL_TLSEXT_ERR_NOACK) {
+            SSLfatal_ntls(s, SSL_AD_NO_APPLICATION_PROTOCOL,
+                     SSL_R_NO_APPLICATION_PROTOCOL);
+            return 0;
+        }
+        /*
+         * If r == SSL_TLSEXT_ERR_NOACK then behave as if no callback was
+         * present.
+         */
+    }
+
+    /* Check ALPN is consistent with session */
+    if (s->session->ext.alpn_selected != NULL) {
+        /* Not consistent so can't be used for early_data */
+        s->ext.early_data_ok = 0;
+    }
+
+    return 1;
+}
+
+WORK_STATE tls_post_process_client_hello_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    const SSL_CIPHER *cipher;
+    SSL *ssl = SSL_CONNECTION_GET_SSL(s);
+    SSL *ussl = SSL_CONNECTION_GET_USER_SSL(s);
+    if (wst == WORK_MORE_A) {
+        int rv = tls_early_post_process_client_hello(s);
+        if (rv == 0) {
+            /* SSLfatal_ntls() was already called */
+            goto err;
+        }
+        if (rv < 0)
+            return WORK_MORE_A;
+        wst = WORK_MORE_B;
+    }
+    if (wst == WORK_MORE_B) {
+        if (!s->hit) {
+            /* Let cert callback update server certificates if required */
+            if (!s->hit && s->cert->cert_cb != NULL) {
+                int rv = s->cert->cert_cb(ussl, s->cert->cert_cb_arg);
+                if (rv == 0) {
+                    SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_CERT_CB_ERROR);
+                    goto err;
+                }
+                if (rv < 0) {
+                    s->rwstate = SSL_X509_LOOKUP;
+                    return WORK_MORE_B;
+                }
+                s->rwstate = SSL_NOTHING;
+            }
+
+            cipher =
+                ssl3_choose_cipher(s, s->peer_ciphers, SSL_get_ciphers(ssl));
+
+            if (cipher == NULL) {
+                SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                              SSL_R_NO_SHARED_CIPHER);
+                goto err;
+            }
+            s->s3.tmp.new_cipher = cipher;
+
+            if (!s->hit) {
+                if (!tls_choose_sigalg_ntls(s, 1)) {
+                    /* SSLfatal_ntls already called */
+                    goto err;
+                }
+                /* check whether we should disable session resumption */
+                if (s->not_resumable_session_cb != NULL)
+                    s->session->not_resumable =
+                        s->not_resumable_session_cb(ussl,
+                            ((s->s3.tmp.new_cipher->algorithm_mkey
+                              & (SSL_kDHE | SSL_kECDHE)) != 0));
+                if (s->session->not_resumable)
+                    /* do not send a session ticket */
+                    s->ext.ticket_expected = 0;
+            }
+        } else {
+            /* Session-id reuse */
+            s->s3.tmp.new_cipher = s->session->cipher;
+        }
+
+        if (s->s3.tmp.new_cipher->algorithm_mkey & SSL_kSM2DHE)
+            s->verify_mode = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT
+                             | SSL_VERIFY_CLIENT_ONCE;
+
+        /*-
+         * we now have the following setup.
+         * client_random
+         * cipher_list          - our preferred list of ciphers
+         * ciphers              - the clients preferred list of ciphers
+         * compression          - basically ignored right now
+         * ssl version is set   - sslv3
+         * s->session           - The ssl session has been setup.
+         * s->hit               - session reuse flag
+         * s->s3.tmp.new_cipher - the new cipher to use.
+         */
+
+        /*
+         * Call status_request callback if needed. Has to be done after the
+         * certificate callbacks etc above.
+         */
+        if (!tls_handle_status_request(s)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+        /*
+         * Call alpn_select callback if needed.  Has to be done after SNI and
+         * cipher negotiation (HTTP/2 restricts permitted ciphers). In TLSv1.3
+         * we already did this because cipher negotiation happens earlier, and
+         * we must handle ALPN before we decide whether to accept early_data.
+         */
+        if (!tls_handle_alpn_ntls(s)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+
+        wst = WORK_MORE_C;
+    }
+
+    return WORK_FINISHED_STOP;
+ err:
+    return WORK_ERROR;
+}
+
+int tls_construct_server_hello_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    int compm;
+    size_t sl, len;
+    int version;
+    unsigned char *session_id;
+    int usetls13 = s->hello_retry_request == SSL_HRR_PENDING;
+
+    version = usetls13 ? TLS1_2_VERSION : s->version;
+    if (!WPACKET_put_bytes_u16(pkt, version)
+               /*
+                * Random stuff. Filling of the server_random takes place in
+                * tls_process_client_hello_ntls()
+                */
+            || !WPACKET_memcpy(pkt,
+                               s->hello_retry_request == SSL_HRR_PENDING
+                                   ? hrrrandom_ntls : s->s3.server_random,
+                               SSL3_RANDOM_SIZE)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /*-
+     * There are several cases for the session ID to send
+     * back in the server hello:
+     * - For session reuse from the session cache,
+     *   we send back the old session ID.
+     * - If stateless session reuse (using a session ticket)
+     *   is successful, we send back the client's "session ID"
+     *   (which doesn't actually identify the session).
+     * - If it is a new session, we send back the new
+     *   session ID.
+     * - However, if we want the new session to be single-use,
+     *   we send back a 0-length session ID.
+     * - In TLSv1.3 we echo back the session id sent to us by the client
+     *   regardless
+     * s->hit is non-zero in either case of session reuse,
+     * so the following won't overwrite an ID that we're supposed
+     * to send back.
+     */
+    if (s->session->not_resumable ||
+        (!(SSL_CONNECTION_GET_CTX(s)->session_cache_mode & SSL_SESS_CACHE_SERVER)
+         && !s->hit))
+        s->session->session_id_length = 0;
+
+    if (usetls13) {
+        sl = s->tmp_session_id_len;
+        session_id = s->tmp_session_id;
+    } else {
+        sl = s->session->session_id_length;
+        session_id = s->session->session_id;
+    }
+
+    if (sl > sizeof(s->session->session_id)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* set up the compression method */
+    compm = 0;
+
+    if (!WPACKET_sub_memcpy_u8(pkt, session_id, sl)
+            || !SSL_CONNECTION_GET_SSL(s)->method->put_cipher_by_char(s->s3.tmp.new_cipher,
+                                                                      pkt, &len)
+            || !WPACKET_put_bytes_u8(pkt, compm)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (!tls_construct_extensions_ntls(s, pkt,
+                                   s->hello_retry_request == SSL_HRR_PENDING
+                                   ? SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST
+                                   : SSL_EXT_TLS1_2_SERVER_HELLO,
+                                   NULL, 0)) {
+        /* SSLfatal() already called */
+        return 0;
+    }
+
+    if (s->hello_retry_request == SSL_HRR_PENDING) {
+        /* Ditch the session. We'll create a new one next time around */
+        SSL_SESSION_free(s->session);
+        s->session = NULL;
+        s->hit = 0;
+
+        /*
+         * Re-initialise the Transcript Hash. We're going to prepopulate it with
+         * a synthetic message_hash in place of ClientHello1.
+         */
+        if (!create_synthetic_message_hash_ntls(s, NULL, 0, NULL, 0)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    } else if (!(s->verify_mode & SSL_VERIFY_PEER)
+                && !ssl3_digest_cached_records(s, 0)) {
+        /* SSLfatal_ntls() already called */;
+        return 0;
+    }
+
+    return 1;
+}
+
+int tls_construct_server_done_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    if (!s->s3.tmp.cert_request) {
+        if (!ssl3_digest_cached_records(s, 0)) {
+            /* SSLfatal_ntls() already called */
+            return 0;
+        }
+    }
+    return 1;
+}
+
+int tls_construct_server_key_exchange_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    unsigned char *encodedPoint = NULL;
+    size_t encodedlen = 0;
+    int curve_id = 0;
+    const SIGALG_LOOKUP *lu = s->s3.tmp.sigalg;
+    unsigned long type;
+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();
+    EVP_PKEY_CTX *pctx = NULL;
+    size_t paramlen, paramoffset;
+    int ret = 0;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (!WPACKET_get_total_written(pkt, &paramoffset)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    type = s->s3.tmp.new_cipher->algorithm_mkey;
+
+    if (type & SSL_kSM2DHE) {
+        if (s->s3.tmp.pkey != NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        /* Get NID of appropriate shared curve */
+        curve_id = tls1_shared_group(s, -2);
+        if (curve_id == 0) {
+            SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                          SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
+            goto err;
+        }
+        /* Cache the group used in the SSL_SESSION */
+        s->session->kex_group = curve_id;
+        /* Generate a new key for this curve */
+        s->s3.tmp.pkey = ssl_generate_pkey_group(s, curve_id);
+        if (s->s3.tmp.pkey == NULL) {
+            /* SSLfatal() already called */
+            goto err;
+        }
+
+        /* Encode the public key. */
+        encodedlen = EVP_PKEY_get1_encoded_public_key(s->s3.tmp.pkey,
+                                                      &encodedPoint);
+        if (encodedlen == 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+            goto err;
+        }
+        /*
+         * We only support named (not generic) curves. In this situation, the
+         * ServerKeyExchange message has: [1 byte CurveType], [2 byte CurveName]
+         * [1 byte length of encoded point], followed by the actual encoded
+         * point itself
+         */
+        if (!WPACKET_put_bytes_u8(pkt, NAMED_CURVE_TYPE)
+                || !WPACKET_put_bytes_u8(pkt, 0)
+                || !WPACKET_put_bytes_u8(pkt, curve_id)
+                || !WPACKET_sub_memcpy_u8(pkt, encodedPoint, encodedlen)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+        OPENSSL_free(encodedPoint);
+        encodedPoint = NULL;
+
+        /* Get length of the parameters we have written above */
+        if (!WPACKET_get_length(pkt, &paramlen)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+    }
+
+    if (lu != NULL) {
+        EVP_PKEY *pkey = NULL;
+        X509 *x509 = NULL;
+        const EVP_MD *md;
+        unsigned char *sigbytes1, *sigbytes2, *tbs;
+        size_t siglen = 0, tbslen;
+        unsigned char *buf = NULL;
+        size_t buflen;
+
+        /* get signing cert and pkey */
+        if (type & SSL_kRSA) {
+            pkey = s->cert->pkeys[SSL_PKEY_RSA_SIGN].privatekey;
+            x509 = s->cert->pkeys[SSL_PKEY_RSA_ENC].x509;
+        } else if (type & SSL_kSM2) {
+            pkey = s->cert->pkeys[SSL_PKEY_SM2_SIGN].privatekey;
+            x509 = s->cert->pkeys[SSL_PKEY_SM2_ENC].x509;
+        } else if (type & SSL_kSM2DHE) {
+            pkey = s->cert->pkeys[SSL_PKEY_SM2_SIGN].privatekey;
+        }
+
+        if (pkey == NULL || !tls1_lookup_md(sctx, lu, &md)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        if (EVP_DigestSignInit_ex(md_ctx, &pctx,
+                                  md == NULL ? NULL : EVP_MD_get0_name(md),
+                                  sctx->libctx, sctx->propq, pkey,
+                                  NULL) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        if (EVP_PKEY_is_a(pkey, "SM2")) {
+            if (EVP_PKEY_CTX_set1_id(pctx, SM2_DEFAULT_ID,
+                                     SM2_DEFAULT_ID_LEN) <= 0) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+                goto err;
+            }
+        }
+        if (type & (SSL_kRSA | SSL_kSM2)) {
+            if (x509 == NULL
+                    || (buf = x509_to_asn1_ntls(x509, &buflen)) == NULL) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+                goto err;
+            }
+        }
+
+        tbslen = construct_key_exchange_tbs_ntls(s, &tbs,
+                     (buf != NULL)
+                     ? (const void *)buf
+                     : (const void *)(s->init_buf->data + paramoffset),
+                     (buf != NULL) ? buflen : paramlen);
+        if (tbslen == 0) {
+            /* SSLfatal_ntls() already called */
+            OPENSSL_free(buf);
+            goto err;
+        }
+
+        OPENSSL_free(buf);
+
+        if (EVP_DigestSign(md_ctx, NULL, &siglen, tbs, tbslen) <=0
+                || !WPACKET_sub_reserve_bytes_u16(pkt, siglen, &sigbytes1)
+                || EVP_DigestSign(md_ctx, sigbytes1, &siglen, tbs, tbslen) <= 0
+                || !WPACKET_sub_allocate_bytes_u16(pkt, siglen, &sigbytes2)
+                || sigbytes1 != sigbytes2) {
+            OPENSSL_free(tbs);
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+        OPENSSL_free(tbs);
+    }
+
+    ret = 1;
+err:
+    OPENSSL_free(encodedPoint);
+    EVP_MD_CTX_free(md_ctx);
+    return ret;
+}
+
+int tls_construct_certificate_request_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    /* get the list of acceptable cert types */
+    if (!WPACKET_start_sub_packet_u8(pkt)
+        || !ssl3_get_req_cert_type(s, pkt) || !WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (SSL_USE_SIGALGS(s)) {
+        const uint16_t *psigs;
+        size_t nl = tls12_get_psigalgs(s, 1, &psigs);
+
+        if (!WPACKET_start_sub_packet_u16(pkt)
+                || !WPACKET_set_flags(pkt, WPACKET_FLAGS_NON_ZERO_LENGTH)
+                || !tls12_copy_sigalgs(s, pkt, psigs, nl)
+                || !WPACKET_close(pkt)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+    }
+
+    if (!construct_ca_names_ntls(s, get_ca_names_ntls(s), pkt)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    s->certreqs_sent++;
+    s->s3.tmp.cert_request = 1;
+    return 1;
+}
+
+/* process ClientKeyExchange encrypted pre master secret for kRSA or kSM2 */
+static int tls_process_cke_pms_ntls(SSL_CONNECTION *s, PACKET *pkt, unsigned long alg_k)
+{
+    size_t outlen;
+    PACKET enc_premaster;
+    EVP_PKEY *pkey = NULL;
+    unsigned char *pkey_decrypt = NULL;
+    int ret = 0;
+    EVP_PKEY_CTX *ctx = NULL;
+    OSSL_PARAM params[2], *p = params;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    if (alg_k & SSL_kRSA)
+        pkey = s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
+    else if (alg_k & SSL_kSM2)
+        pkey = s->cert->pkeys[SSL_PKEY_SM2_ENC].privatekey;
+
+    if (pkey == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_MISSING_ENC_CERTIFICATE);
+        return 0;
+    }
+
+    if (!PACKET_get_length_prefixed_2(pkt, &enc_premaster)
+        || PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return 0;
+    }
+
+    outlen = SSL_MAX_MASTER_KEY_LENGTH;
+    pkey_decrypt = OPENSSL_malloc(outlen);
+    if (pkey_decrypt == NULL) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    ctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, pkey, sctx->propq);
+    if (ctx == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (EVP_PKEY_decrypt_init(ctx) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_DECRYPTION_FAILED);
+        goto err;
+    }
+
+    /*
+     * We must not leak whether a decryption failure occurs because of
+     * Bleichenbacher's attack on PKCS #1 v1.5 RSA padding (see RFC 2246,
+     * section 7.4.7.1). We use the special padding type
+     * RSA_PKCS1_WITH_TLS_PADDING to do that. It will automaticaly decrypt the
+     * RSA, check the padding and check that the client version is as expected
+     * in the premaster secret. If any of that fails then the function appears
+     * to return successfully but with a random result. The call below could
+     * still fail if the input is publicly invalid.
+     * See https://tools.ietf.org/html/rfc5246#section-7.4.7.1
+     */
+    if (alg_k & SSL_kRSA) {
+        if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_WITH_TLS_PADDING)
+                <= 0) {
+            SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_DECRYPTION_FAILED);
+            goto err;
+        }
+
+        *p++ = OSSL_PARAM_construct_uint(
+                    OSSL_ASYM_CIPHER_PARAM_TLS_CLIENT_VERSION,
+                    (unsigned int *)&s->client_version);
+        *p++ = OSSL_PARAM_construct_end();
+
+        if (!EVP_PKEY_CTX_set_params(ctx, params)) {
+            SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_DECRYPTION_FAILED);
+            goto err;
+        }
+    }
+
+    if (EVP_PKEY_decrypt(ctx, pkey_decrypt, &outlen,
+                         PACKET_data(&enc_premaster),
+                         PACKET_remaining(&enc_premaster)) <= 0) {
+        SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_DECRYPTION_FAILED);
+        goto err;
+    }
+
+    /*
+     * This test should never fail (otherwise we should have failed above) but
+     * we double check anyway.
+     */
+    if (outlen != SSL_MAX_MASTER_KEY_LENGTH) {
+        OPENSSL_cleanse(pkey_decrypt, SSL_MAX_MASTER_KEY_LENGTH);
+        SSLfatal_ntls(s, SSL_AD_DECRYPT_ERROR, SSL_R_DECRYPTION_FAILED);
+        goto err;
+    }
+
+    /* Also cleanses pkey_decrypt (on success or failure) */
+    if (!ssl_generate_master_secret(s, pkey_decrypt,
+                                    SSL_MAX_MASTER_KEY_LENGTH, 0)) {
+        /* SSLfatal_ntls already called */
+        goto err;
+    }
+
+    ret = 1;
+ err:
+    OPENSSL_free(pkey_decrypt);
+    EVP_PKEY_CTX_free(ctx);
+    return ret;
+}
+
+static int tls_process_cke_sm2dhe_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    const unsigned char *ecparams;
+    EVP_PKEY *skey = s->s3.tmp.pkey;
+    EVP_PKEY *ckey = NULL;
+    int ret = 0;
+
+    if (PACKET_remaining(pkt) == 0L) {
+        /* We don't support ECDH client auth */
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_TMP_ECDH_KEY);
+        goto err;
+    } else {
+        unsigned int i;
+        const unsigned char *data;
+
+        /*
+         * Get client's public key from encoded point in the
+         * ClientKeyExchange message.
+         */
+
+        if (!PACKET_get_bytes(pkt, &ecparams, 3)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);
+            goto err;
+        }
+
+        /* Get encoded point length */
+        if (!PACKET_get_1(pkt, &i) || !PACKET_get_bytes(pkt, &data, i)
+            || PACKET_remaining(pkt) != 0) {
+            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (skey == NULL) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_MISSING_TMP_ECDH_KEY);
+            goto err;
+        }
+
+        ckey = EVP_PKEY_new();
+        if (ckey == NULL || EVP_PKEY_copy_parameters(ckey, skey) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR,
+                          SSL_R_COPY_PARAMETERS_FAILED);
+            goto err;
+        }
+
+        if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
+            goto err;
+        }
+    }
+
+    if (ssl_derive_ntls(s, skey, ckey, 1) == 0) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    ret = 1;
+    EVP_PKEY_free(s->s3.tmp.pkey);
+    s->s3.tmp.pkey = NULL;
+ err:
+    EVP_PKEY_free(ckey);
+
+    return ret;
+}
+
+MSG_PROCESS_RETURN tls_process_client_key_exchange_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    unsigned long alg_k;
+
+    alg_k = s->s3.tmp.new_cipher->algorithm_mkey;
+
+    if (alg_k & (SSL_kRSA | SSL_kSM2)) {
+        if (!tls_process_cke_pms_ntls(s, pkt, alg_k)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    } else if (alg_k & SSL_kSM2DHE) {
+        if (!tls_process_cke_sm2dhe_ntls(s, pkt)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    } else {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_UNKNOWN_CIPHER_TYPE);
+        goto err;
+    }
+
+    return MSG_PROCESS_CONTINUE_PROCESSING;
+ err:
+    return MSG_PROCESS_ERROR;
+}
+
+WORK_STATE tls_post_process_client_key_exchange_ntls(SSL_CONNECTION *s, WORK_STATE wst)
+{
+    if (s->statem.no_cert_verify || !s->session->peer) {
+        /*
+         * No certificate verify or no peer certificate so we no longer need
+         * the handshake_buffer
+         */
+        if (!ssl3_digest_cached_records(s, 0)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+        return WORK_FINISHED_CONTINUE;
+    } else {
+        if (!s->s3.handshake_buffer) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            return WORK_ERROR;
+        }
+        /*
+         * For sigalgs freeze the handshake buffer. If we support
+         * extms we've done this already so this is a no-op
+         */
+        if (!ssl3_digest_cached_records(s, 1)) {
+            /* SSLfatal_ntls() already called */
+            return WORK_ERROR;
+        }
+    }
+
+    return WORK_FINISHED_CONTINUE;
+}
+
+MSG_PROCESS_RETURN tls_process_client_certificate_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    int i, j;
+    MSG_PROCESS_RETURN ret = MSG_PROCESS_ERROR;
+    X509 *x = NULL;
+    unsigned long l;
+    const unsigned char *certstart, *certbytes;
+    STACK_OF(X509) *sk = NULL;
+    PACKET spkt;
+    size_t chainidx;
+    SSL_SESSION *new_sess = NULL;
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /*
+     * To get this far we must have read encrypted data from the client. We no
+     * longer tolerate unencrypted alerts. This value is ignored if less than
+     * TLSv1.3
+     */
+
+    if ((sk = sk_X509_new_null()) == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (!PACKET_get_length_prefixed_3(pkt, &spkt)
+            || PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        goto err;
+    }
+
+    for (chainidx = 0; PACKET_remaining(&spkt) > 0; chainidx++) {
+        if (!PACKET_get_net_3(&spkt, &l)
+            || !PACKET_get_bytes(&spkt, &certbytes, l)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        certstart = certbytes;
+        x = X509_new_ex(sctx->libctx, sctx->propq);
+        if (x == NULL) {
+            SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+        if (d2i_X509(&x, (const unsigned char **)&certbytes, l) == NULL) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);
+            goto err;
+        }
+
+        if (certbytes != (certstart + l)) {
+            SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);
+            goto err;
+        }
+
+        if (!sk_X509_push(sk, x)) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+        x = NULL;
+    }
+
+    if (sk_X509_num(sk) <= 0) {
+        /*for ECDHE-SM2, certificates are required */
+        unsigned long alg_k = s->s3.tmp.new_cipher->algorithm_mkey;
+        if (alg_k & SSL_kSM2DHE) {
+            SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                          SSL_R_NO_CERTIFICATES_RETURNED);
+            goto err;
+        }
+
+        /* Fail for TLS only if we required a certificate */
+        else if ((s->verify_mode & SSL_VERIFY_PEER) &&
+                 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {
+            SSLfatal_ntls(s, SSL_AD_CERTIFICATE_REQUIRED,
+                          SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
+            goto err;
+        }
+        /* No client certificate so digest cached records */
+        if (s->s3.handshake_buffer && !ssl3_digest_cached_records(s, 0)) {
+            /* SSLfatal_ntls() already called */
+            goto err;
+        }
+    } else if (sk_X509_num(sk) < 2) {
+        SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                      SSL_R_NO_CERTIFICATES_RETURNED);
+        goto err;
+    } else {
+        for (j = 0; j < 2; j++) {
+            EVP_PKEY *pkey;
+
+            if (j == 0)
+                sk_X509_push(sk, sk_X509_shift(sk));
+            if (j == 1)
+                sk_X509_unshift(sk, sk_X509_pop(sk));
+
+            i = ssl_verify_cert_chain(s, sk);
+
+            if (i <= 0) {
+                SSLfatal_ntls(s, ssl_x509err2alert_ntls(s->verify_result),
+                              SSL_R_CERTIFICATE_VERIFY_FAILED);
+                goto err;
+            }
+            pkey = X509_get0_pubkey(sk_X509_value(sk, 0));
+            if (pkey == NULL) {
+                SSLfatal_ntls(s, SSL_AD_HANDSHAKE_FAILURE,
+                              SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+                goto err;
+            }
+        }
+    }
+
+    /*
+     * Sessions must be immutable once they go into the session cache. Otherwise
+     * we can get multi-thread problems. Therefore we don't "update" sessions,
+     * we replace them with a duplicate. Here, we need to do this every time
+     * a new certificate is received via post-handshake authentication, as the
+     * session may have already gone into the session cache.
+     */
+
+    if (s->post_handshake_auth == SSL_PHA_REQUESTED) {
+        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+
+        SSL_SESSION_free(s->session);
+        s->session = new_sess;
+    }
+
+    X509_free(s->session->peer);
+    /* For NTLS server, s->session->peer stores client sign cert */
+    s->session->peer = sk_X509_shift(sk);
+    s->session->verify_result = s->verify_result;
+
+    sk_X509_pop_free(s->session->peer_chain, X509_free);
+    /* For NTLS server, s->session->peer_chain stores client encryption cert and extra chain certs */
+    s->session->peer_chain = sk;
+    sk = NULL;
+
+    ret = MSG_PROCESS_CONTINUE_READING;
+
+ err:
+    X509_free(x);
+    sk_X509_pop_free(sk, X509_free);
+    return ret;
+}
+
+int tls_construct_server_certificate_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    CERT_PKEY *a_cpk = s->s3.tmp.sign_cert;
+    CERT_PKEY *k_cpk = s->s3.tmp.enc_cert;
+
+    if (a_cpk == NULL || k_cpk == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    if (!ssl3_output_cert_chain_ntls(s, pkt, a_cpk, k_cpk)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    return 1;
+}
+
+static int create_ticket_prequel(SSL_CONNECTION *s, WPACKET *pkt, uint32_t age_add,
+                                 unsigned char *tick_nonce)
+{
+    /*
+     * Ticket lifetime hint: For TLSv1.2 this is advisory only and we leave this
+     * unspecified for resumed session (for simplicity).
+     * In TLSv1.3 we reset the "time" field above, and always specify the
+     * timeout.
+     */
+
+    uint32_t t = ossl_time2seconds(s->session->timeout);
+    if (!WPACKET_put_bytes_u32(pkt,
+                               s->hit ? 0 : t)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /* Start the sub-packet for the actual ticket data */
+    if (!WPACKET_start_sub_packet_u16(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int construct_stateless_ticket(SSL_CONNECTION *s, WPACKET *pkt, uint32_t age_add,
+                                      unsigned char *tick_nonce)
+{
+    unsigned char *senc = NULL;
+    EVP_CIPHER_CTX *ctx = NULL;
+    SSL_HMAC *hctx = NULL;
+    unsigned char *p, *encdata1, *encdata2, *macdata1, *macdata2;
+    const unsigned char *const_p;
+    int len, slen_full, slen, lenfinal;
+    SSL_SESSION *sess;
+    size_t hlen;
+    SSL_CTX *tctx = s->session_ctx;
+    unsigned char iv[EVP_MAX_IV_LENGTH];
+    unsigned char key_name[TLSEXT_KEYNAME_LENGTH];
+    int iv_len, ok = 0;
+    size_t macoffset, macendoffset;
+    SSL *ssl = SSL_CONNECTION_GET_USER_SSL(s);
+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+
+    /* get session encoding length */
+    slen_full = i2d_SSL_SESSION(s->session, NULL);
+    /*
+     * Some length values are 16 bits, so forget it if session is too
+     * long
+     */
+    if (slen_full == 0 || slen_full > 0xFF00) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    senc = OPENSSL_malloc(slen_full);
+    if (senc == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    ctx = EVP_CIPHER_CTX_new();
+    hctx = ssl_hmac_new(tctx);
+    if (ctx == NULL || hctx == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    p = senc;
+    if (!i2d_SSL_SESSION(s->session, &p)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /*
+     * create a fresh copy (not shared with other threads) to clean up
+     */
+    const_p = senc;
+    sess = d2i_SSL_SESSION(NULL, &const_p, slen_full);
+    if (sess == NULL) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    slen = i2d_SSL_SESSION(sess, NULL);
+    if (slen == 0 || slen > slen_full) {
+        /* shouldn't ever happen */
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        SSL_SESSION_free(sess);
+        goto err;
+    }
+    p = senc;
+    if (!i2d_SSL_SESSION(sess, &p)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        SSL_SESSION_free(sess);
+        goto err;
+    }
+    SSL_SESSION_free(sess);
+
+    /*
+     * Initialize HMAC and cipher contexts. If callback present it does
+     * all the work otherwise use generated values from parent ctx.
+     */
+#ifndef OPENSSL_NO_DEPRECATED_3_0
+    if (tctx->ext.ticket_key_evp_cb != NULL || tctx->ext.ticket_key_cb != NULL)
+#else
+    if (tctx->ext.ticket_key_evp_cb != NULL)
+#endif
+    {
+        int ret = 0;
+
+        if (tctx->ext.ticket_key_evp_cb != NULL)
+            ret = tctx->ext.ticket_key_evp_cb(ssl, key_name, iv, ctx,
+                                              ssl_hmac_get0_EVP_MAC_CTX(hctx),
+                                              1);
+#ifndef OPENSSL_NO_DEPRECATED_3_0
+        else if (tctx->ext.ticket_key_cb != NULL)
+            /* if 0 is returned, write an empty ticket */
+            ret = tctx->ext.ticket_key_cb(ssl, key_name, iv, ctx,
+                                          ssl_hmac_get0_HMAC_CTX(hctx), 1);
+#endif
+
+        if (ret == 0) {
+
+            /* Put timeout and length */
+            if (!WPACKET_put_bytes_u32(pkt, 0)
+                    || !WPACKET_put_bytes_u16(pkt, 0)) {
+                SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+            OPENSSL_free(senc);
+            EVP_CIPHER_CTX_free(ctx);
+            ssl_hmac_free(hctx);
+            return 1;
+        }
+        if (ret < 0) {
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, SSL_R_CALLBACK_FAILED);
+            goto err;
+        }
+        iv_len = EVP_CIPHER_CTX_get_iv_length(ctx);
+    } else {
+        EVP_CIPHER *cipher = EVP_CIPHER_fetch(sctx->libctx, "AES-256-CBC",
+                                              sctx->propq);
+
+        if (cipher == NULL) {
+            /* Error is already recorded */
+            SSLfatal_alert_ntls(s, SSL_AD_INTERNAL_ERROR);
+            goto err;
+        }
+
+        iv_len = EVP_CIPHER_get_iv_length(cipher);
+        if (iv_len < 0
+		        || RAND_bytes_ex(sctx->libctx, iv, iv_len, 0) <= 0
+                || !EVP_EncryptInit_ex(ctx, cipher, NULL,
+                                       tctx->ext.secure->tick_aes_key, iv)
+                || !ssl_hmac_init(hctx, tctx->ext.secure->tick_hmac_key,
+                                 sizeof(tctx->ext.secure->tick_hmac_key),
+                                 "SHA256")) {
+            EVP_CIPHER_free(cipher);
+            SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+        EVP_CIPHER_free(cipher);
+        memcpy(key_name, tctx->ext.tick_key_name,
+               sizeof(tctx->ext.tick_key_name));
+    }
+
+    if (!create_ticket_prequel(s, pkt, age_add, tick_nonce)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    if (!WPACKET_get_total_written(pkt, &macoffset)
+               /* Output key name */
+            || !WPACKET_memcpy(pkt, key_name, sizeof(key_name))
+               /* output IV */
+            || !WPACKET_memcpy(pkt, iv, iv_len)
+            || !WPACKET_reserve_bytes(pkt, slen + EVP_MAX_BLOCK_LENGTH,
+                                      &encdata1)
+               /* Encrypt session data */
+            || !EVP_EncryptUpdate(ctx, encdata1, &len, senc, slen)
+            || !WPACKET_allocate_bytes(pkt, len, &encdata2)
+            || encdata1 != encdata2
+            || !EVP_EncryptFinal(ctx, encdata1 + len, &lenfinal)
+            || !WPACKET_allocate_bytes(pkt, lenfinal, &encdata2)
+            || encdata1 + len != encdata2
+            || len + lenfinal > slen + EVP_MAX_BLOCK_LENGTH
+            || !WPACKET_get_total_written(pkt, &macendoffset)
+            || !ssl_hmac_update(hctx,
+                                (unsigned char *)s->init_buf->data + macoffset,
+                                macendoffset - macoffset)
+            || !WPACKET_reserve_bytes(pkt, EVP_MAX_MD_SIZE, &macdata1)
+            || !ssl_hmac_final(hctx, macdata1, &hlen, EVP_MAX_MD_SIZE)
+            || hlen > EVP_MAX_MD_SIZE
+            || !WPACKET_allocate_bytes(pkt, hlen, &macdata2)
+            || macdata1 != macdata2) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    /* Close the sub-packet created by create_ticket_prequel() */
+    if (!WPACKET_close(pkt)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    ok = 1;
+ err:
+    OPENSSL_free(senc);
+    EVP_CIPHER_CTX_free(ctx);
+    ssl_hmac_free(hctx);
+    return ok;
+}
+
+int tls_construct_new_session_ticket_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    SSL_CTX *tctx = s->session_ctx;
+    unsigned char tick_nonce[TICKET_NONCE_SIZE];
+    union {
+        unsigned char age_add_c[sizeof(uint32_t)];
+        uint32_t age_add;
+    } age_add_u;
+
+    age_add_u.age_add = 0;
+
+    if (tctx->generate_ticket_cb != NULL &&
+        tctx->generate_ticket_cb(SSL_CONNECTION_GET_USER_SSL(s),
+                                 tctx->ticket_cb_data) == 0) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    if (!construct_stateless_ticket(s, pkt, age_add_u.age_add,
+                                    tick_nonce)) {
+        /* SSLfatal_ntls() already called */
+        goto err;
+    }
+
+    return 1;
+ err:
+    return 0;
+}
+
+/*
+ * In TLSv1.3 this is called from the extensions code, otherwise it is used to
+ * create a separate message. Returns 1 on success or 0 on failure.
+ */
+int tls_construct_cert_status_body_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    if (!WPACKET_put_bytes_u8(pkt, s->ext.status_type)
+            || !WPACKET_sub_memcpy_u24(pkt, s->ext.ocsp.resp,
+                                       s->ext.ocsp.resp_len)) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    return 1;
+}
+
+int tls_construct_cert_status_ntls(SSL_CONNECTION *s, WPACKET *pkt)
+{
+    if (!tls_construct_cert_status_body_ntls(s, pkt)) {
+        /* SSLfatal_ntls() already called */
+        return 0;
+    }
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+/*
+ * tls_process_next_proto_ntls reads a Next Protocol Negotiation handshake message.
+ * It sets the next_proto member in s if found
+ */
+MSG_PROCESS_RETURN tls_process_next_proto_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    PACKET next_proto, padding;
+    size_t next_proto_len;
+
+    /*-
+     * The payload looks like:
+     *   uint8 proto_len;
+     *   uint8 proto[proto_len];
+     *   uint8 padding_len;
+     *   uint8 padding[padding_len];
+     */
+    if (!PACKET_get_length_prefixed_1(pkt, &next_proto)
+        || !PACKET_get_length_prefixed_1(pkt, &padding)
+        || PACKET_remaining(pkt) > 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (!PACKET_memdup(&next_proto, &s->ext.npn, &next_proto_len)) {
+        s->ext.npn_len = 0;
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+    }
+
+    s->ext.npn_len = (unsigned char)next_proto_len;
+
+    return MSG_PROCESS_CONTINUE_READING;
+}
+#endif
+
+MSG_PROCESS_RETURN tls_process_end_of_early_data_ntls(SSL_CONNECTION *s, PACKET *pkt)
+{
+    if (PACKET_remaining(pkt) != 0) {
+        SSLfatal_ntls(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
+        return MSG_PROCESS_ERROR;
+    }
+
+    if (s->early_data_state != SSL_EARLY_DATA_READING
+            && s->early_data_state != SSL_EARLY_DATA_READ_RETRY) {
+        SSLfatal_ntls(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        return MSG_PROCESS_ERROR;
+    }
+
+    /*
+     * EndOfEarlyData signals a key change so the end of the message must be on
+     * a record boundary.
+     */
+    if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {
+        SSLfatal_ntls(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);
+        return MSG_PROCESS_ERROR;
+    }
+
+    s->early_data_state = SSL_EARLY_DATA_FINISHED_READING;
+    if (!SSL_CONNECTION_GET_SSL(s)->method->ssl3_enc->change_cipher_state(s,
+                SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_SERVER_READ)) {
+        /* SSLfatal_ntls() already called */
+        return MSG_PROCESS_ERROR;
+    }
+
+    return MSG_PROCESS_CONTINUE_READING;
+}
Index: b/ssl/t1_enc.c
===================================================================
--- a/ssl/t1_enc.c
+++ b/ssl/t1_enc.c
@@ -569,3 +569,81 @@ int tls1_alert_code(int code)
         return -1;
     }
 }
+
+#ifndef OPENSSL_NO_NTLS
+int ntls_alert_code(int code)
+{
+    switch (code) {
+    case SSL_AD_CLOSE_NOTIFY:
+        return SSL3_AD_CLOSE_NOTIFY;
+    case SSL_AD_UNEXPECTED_MESSAGE:
+        return SSL3_AD_UNEXPECTED_MESSAGE;
+    case SSL_AD_BAD_RECORD_MAC:
+        return SSL3_AD_BAD_RECORD_MAC;
+    case SSL_AD_DECRYPTION_FAILED:
+        return TLS1_AD_DECRYPTION_FAILED;
+    case SSL_AD_RECORD_OVERFLOW:
+        return TLS1_AD_RECORD_OVERFLOW;
+    case SSL_AD_DECOMPRESSION_FAILURE:
+        return SSL3_AD_DECOMPRESSION_FAILURE;
+    case SSL_AD_HANDSHAKE_FAILURE:
+        return SSL3_AD_HANDSHAKE_FAILURE;
+    case SSL_AD_BAD_CERTIFICATE:
+        return SSL3_AD_BAD_CERTIFICATE;
+    case SSL_AD_UNSUPPORTED_CERTIFICATE:
+        return SSL3_AD_UNSUPPORTED_CERTIFICATE;
+    case SSL_AD_CERTIFICATE_REVOKED:
+        return SSL3_AD_CERTIFICATE_REVOKED;
+    case SSL_AD_CERTIFICATE_EXPIRED:
+        return SSL3_AD_CERTIFICATE_EXPIRED;
+    case SSL_AD_CERTIFICATE_UNKNOWN:
+        return SSL3_AD_CERTIFICATE_UNKNOWN;
+    case SSL_AD_ILLEGAL_PARAMETER:
+        return SSL3_AD_ILLEGAL_PARAMETER;
+    case SSL_AD_UNKNOWN_CA:
+        return TLS1_AD_UNKNOWN_CA;
+    case SSL_AD_ACCESS_DENIED:
+        return TLS1_AD_ACCESS_DENIED;
+    case SSL_AD_DECODE_ERROR:
+        return TLS1_AD_DECODE_ERROR;
+    case SSL_AD_DECRYPT_ERROR:
+        return TLS1_AD_DECRYPT_ERROR;
+    case SSL_AD_PROTOCOL_VERSION:
+        return TLS1_AD_PROTOCOL_VERSION;
+    case SSL_AD_INSUFFICIENT_SECURITY:
+        return TLS1_AD_INSUFFICIENT_SECURITY;
+    case SSL_AD_INTERNAL_ERROR:
+        return TLS1_AD_INTERNAL_ERROR;
+    case SSL_AD_USER_CANCELLED:
+        return TLS1_AD_USER_CANCELLED;
+    case SSL_AD_UNSUPPORTED_EXTENSION:
+        return TLS1_AD_UNSUPPORTED_EXTENSION;
+    case SSL_AD_CERTIFICATE_UNOBTAINABLE:
+        return TLS1_AD_CERTIFICATE_UNOBTAINABLE;
+    case SSL_AD_UNRECOGNIZED_NAME:
+        return TLS1_AD_UNRECOGNIZED_NAME;
+    case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE:
+        return TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
+    case SSL_AD_BAD_CERTIFICATE_HASH_VALUE:
+        return TLS1_AD_BAD_CERTIFICATE_HASH_VALUE;
+    case SSL_AD_NO_APPLICATION_PROTOCOL:
+        return TLS1_AD_NO_APPLICATION_PROTOCOL;
+    case SSL_AD_CERTIFICATE_REQUIRED:
+        return SSL_AD_HANDSHAKE_FAILURE;
+    case SSL_AD_UNSUPPORTED_SITE2SITE:
+        return NTLS_AD_UNSUPPORTED_SITE2SITE;
+    case SSL_AD_NO_AREA:
+        return NTLS_AD_NO_AREA;
+    case SSL_AD_UNSUPPORTED_AREATYPE:
+        return NTLS_AD_UNSUPPORTED_AREATYPE;
+    case SSL_AD_BAD_IBCPARAM:
+        return NTLS_AD_BAD_IBCPARAM;
+    case SSL_AD_UNSUPPORTED_IBCPARAM:
+        return NTLS_AD_UNSUPPORTED_IBCPARAM;
+    case SSL_AD_IDENTITY_NEED:
+        return NTLS_AD_IDENTITY_NEED;
+    default:
+        return -1;
+    }
+}
+#endif
Index: b/ssl/t1_lib.c
===================================================================
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -91,6 +91,23 @@ SSL3_ENC_METHOD const TLSv1_3_enc_data =
     ssl3_handshake_write
 };
 
+#ifndef OPENSSL_NO_NTLS
+SSL3_ENC_METHOD const NTLS_enc_data = {
+    tls1_setup_key_block,
+    tls1_generate_master_secret,
+    tls1_change_cipher_state,
+    tls1_final_finish_mac,
+    TLS_MD_CLIENT_FINISH_CONST, TLS_MD_CLIENT_FINISH_CONST_SIZE,
+    TLS_MD_SERVER_FINISH_CONST, TLS_MD_SERVER_FINISH_CONST_SIZE,
+    ntls_alert_code,
+    tls1_export_keying_material,
+    SSL_ENC_FLAG_EXPLICIT_IV,
+    ssl3_set_handshake_header,
+    tls_close_construct_packet,
+    ssl3_handshake_write
+};
+#endif
+
 OSSL_TIME tls1_default_timeout(void)
 {
     /*
@@ -188,7 +205,8 @@ static struct {
     {NID_ffdhe3072, OSSL_TLS_GROUP_ID_ffdhe3072},
     {NID_ffdhe4096, OSSL_TLS_GROUP_ID_ffdhe4096},
     {NID_ffdhe6144, OSSL_TLS_GROUP_ID_ffdhe6144},
-    {NID_ffdhe8192, OSSL_TLS_GROUP_ID_ffdhe8192}
+    {NID_ffdhe8192, OSSL_TLS_GROUP_ID_ffdhe8192},
+    {NID_sm2, OSSL_TLS_GROUP_ID_sm2},
 };
 
 static const unsigned char ecformats_default[] = {
@@ -211,6 +229,9 @@ static const uint16_t supported_groups_d
     OSSL_TLS_GROUP_ID_gc512A,        /* GC512A (38) */
     OSSL_TLS_GROUP_ID_gc512B,        /* GC512B (39) */
     OSSL_TLS_GROUP_ID_gc512C,        /* GC512C (40) */
+#ifndef OPENSSL_NO_SM2
+    OSSL_TLS_GROUP_ID_sm2,           /* curveSM2 (41) */
+#endif
     OSSL_TLS_GROUP_ID_ffdhe2048,     /* ffdhe2048 (0x100) */
     OSSL_TLS_GROUP_ID_ffdhe3072,     /* ffdhe3072 (0x101) */
     OSSL_TLS_GROUP_ID_ffdhe4096,     /* ffdhe4096 (0x102) */
@@ -927,6 +948,11 @@ uint16_t tls1_shared_group(SSL_CONNECTIO
     int k;
     SSL_CTX *ctx = SSL_CONNECTION_GET_CTX(s);
 
+#ifndef OPENSSL_NO_NTLS
+    if (SSL_CONNECTION_IS_NTLS(s))
+        return TLSEXT_curve_SM2;
+#endif
+
     /* Can't do anything on client side */
     if (s->server == 0)
         return 0;
@@ -1324,11 +1350,28 @@ int tls1_check_ec_tmp_key(SSL_CONNECTION
     return 0;
 }
 
+
+#ifndef OPENSSL_NO_NTLS
+static const SIGALG_LOOKUP ntls_sm2_sigalg = {
+    "sm2sig_sm3", TLSEXT_SIGALG_sm2sig_sm3,
+    NID_sm3, SSL_MD_SM3_IDX, NID_sm2, SSL_PKEY_SM2_SIGN,
+    NID_SM2_with_SM3, NID_sm2
+};
+
+static const SIGALG_LOOKUP ntls_rsa_sigalg = {
+    "rsa_pkcs1_sha256", TLSEXT_SIGALG_rsa_pkcs1_sha256,
+    NID_sha256, SSL_MD_SHA256_IDX, EVP_PKEY_RSA, SSL_PKEY_RSA_SIGN,
+    NID_sha256WithRSAEncryption, NID_undef
+};
+#endif
 /* Default sigalg schemes */
 static const uint16_t tls12_sigalgs[] = {
     TLSEXT_SIGALG_ecdsa_secp256r1_sha256,
     TLSEXT_SIGALG_ecdsa_secp384r1_sha384,
     TLSEXT_SIGALG_ecdsa_secp521r1_sha512,
+#if (!defined OPENSSL_NO_SM2) && (!defined OPENSSL_NO_SM3)
+    TLSEXT_SIGALG_sm2sig_sm3,
+#endif
     TLSEXT_SIGALG_ed25519,
     TLSEXT_SIGALG_ed448,
     TLSEXT_SIGALG_ecdsa_brainpoolP256r1_sha256,
@@ -1375,6 +1418,11 @@ static const uint16_t suiteb_sigalgs[] =
 };
 
 static const SIGALG_LOOKUP sigalg_lookup_tbl[] = {
+#if (!defined OPENSSL_NO_SM2) && (!defined OPENSSL_NO_SM3)
+    {"sm2sig_sm3", TLSEXT_SIGALG_sm2sig_sm3,
+     NID_sm3, SSL_MD_SM3_IDX, EVP_PKEY_SM2, SSL_PKEY_SM2,
+     NID_SM2_with_SM3, NID_sm2, 1},
+#endif
     {"ecdsa_secp256r1_sha256", TLSEXT_SIGALG_ecdsa_secp256r1_sha256,
      NID_sha256, SSL_MD_SHA256_IDX, EVP_PKEY_EC, SSL_PKEY_ECC,
      NID_ecdsa_with_SHA256, NID_X9_62_prime256v1, 1},
@@ -1498,6 +1546,12 @@ static const uint16_t tls_default_sigalg
     TLSEXT_SIGALG_gostr34102012_512_intrinsic, /* SSL_PKEY_GOST12_512 */
     0, /* SSL_PKEY_ED25519 */
     0, /* SSL_PKEY_ED448 */
+#ifndef OPENSSL_NO_NTLS
+    0, /* SSL_PKEY_SM2_SIGN */
+    0, /* SSL_PKEY_SM2_ENC */
+    0, /* SSL_PKEY_RSA_SIGN */
+    0, /* SSL_PKEY_RSA_ENC */
+#endif
 };
 
 int ssl_setup_sigalgs(SSL_CTX *ctx)
@@ -1732,6 +1786,19 @@ int tls1_set_peer_legacy_sigalg(SSL_CONN
     size_t idx;
     const SIGALG_LOOKUP *lu;
 
+#ifndef OPENSSL_NO_NTLS
+    if (SSL_CONNECTION_IS_NTLS(s)) {
+        if (EVP_PKEY_is_a(pkey, "SM2"))
+            s->s3.tmp.peer_sigalg = &ntls_sm2_sigalg;
+        else if (EVP_PKEY_is_a(pkey, "RSA"))
+            s->s3.tmp.peer_sigalg = &ntls_rsa_sigalg;
+        else
+            return 0;
+
+        return 1;
+    }
+#endif
+
     if (ssl_cert_lookup_by_pkey(pkey, &idx, SSL_CONNECTION_GET_CTX(s)) == NULL)
         return 0;
     lu = tls1_get_legacy_sigalg(s, idx);
@@ -2082,6 +2149,15 @@ int ssl_cipher_disabled(const SSL_CONNEC
     if (!SSL_CONNECTION_IS_DTLS(s)) {
         int min_tls = c->min_tls;
 
+#ifndef OPENSSL_NO_NTLS
+        /*
+         * NTLS cipher can only use in NTLS
+         */
+        if (min_tls == NTLS_VERSION)
+            if (s->s3.tmp.max_ver != NTLS_VERSION)
+                return 1;
+#endif
+
         /*
          * For historical reasons we will allow ECHDE to be selected by a server
          * in SSLv3 if we are a client
@@ -2185,7 +2261,16 @@ SSL_TICKET_STATUS tls_get_ticket_from_cl
      * (e.g. TLSv1.3) behave as if no ticket present to permit stateful
      * resumption.
      */
-    if (s->version <= SSL3_VERSION || !tls_use_ticket(s))
+    if (
+#ifndef OPENSSL_NO_NTLS
+        (
+#endif
+        s->version <= SSL3_VERSION
+#ifndef OPENSSL_NO_NTLS
+        && !SSL_CONNECTION_IS_NTLS(s)
+        )
+#endif
+        || !tls_use_ticket(s))
         return SSL_TICKET_NONE;
 
     ticketext = &hello->pre_proc_exts[TLSEXT_IDX_session_ticket];
@@ -3378,6 +3463,13 @@ void tls1_set_cert_validity(SSL_CONNECTI
     tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_GOST12_512);
     tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_ED25519);
     tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_ED448);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_SM2);
+#ifndef OPENSSL_NO_NTLS
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_SM2_SIGN);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_SM2_ENC);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_RSA_SIGN);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_RSA_ENC);
+#endif
 }
 
 /* User level utility function to check a chain is suitable */
@@ -3703,7 +3795,7 @@ static const SIGALG_LOOKUP *find_sig_alg
         tmppkey = (pkey != NULL) ? pkey
                                  : s->cert->pkeys[lu->sig_idx].privatekey;
 
-        if (lu->sig == EVP_PKEY_EC) {
+        if (lu->sig == EVP_PKEY_EC || lu->sig == EVP_PKEY_SM2) {
             if (curve == -1)
                 curve = ssl_get_EC_curve_nid(tmppkey);
             if (lu->curve != NID_undef && curve != lu->curve)
@@ -3722,6 +3814,47 @@ static const SIGALG_LOOKUP *find_sig_alg
     return lu;
 }
 
+#ifndef OPENSSL_NO_NTLS
+int tls_choose_sigalg_ntls(SSL_CONNECTION *s, int fatalerrs)
+{
+    const SIGALG_LOOKUP *lu = NULL;
+    uint32_t kalg;
+
+    s->s3.tmp.cert = NULL;
+    s->s3.tmp.sign_cert = NULL;
+    s->s3.tmp.enc_cert = NULL;
+    s->s3.tmp.sigalg = NULL;
+
+    /* If ciphersuite doesn't require a cert nothing to do */
+    if (!(s->s3.tmp.new_cipher->algorithm_auth & SSL_aCERT))
+        return 1;
+
+    if (!s->server && !ssl_has_cert(s, s->cert->key - s->cert->pkeys))
+        return 1;
+
+    kalg = s->s3.tmp.new_cipher->algorithm_mkey;
+
+    if (kalg & (SSL_kSM2 | SSL_kSM2DHE)) {
+        lu = &ntls_sm2_sigalg;
+    } else if (kalg & SSL_kRSA) {
+        lu = &ntls_rsa_sigalg;
+    } else {
+        if (!fatalerrs)
+            return 1;
+        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
+        return 0;
+    }
+
+    s->s3.tmp.sign_cert = &s->cert->pkeys[lu->sig_idx];
+    s->s3.tmp.enc_cert = &s->cert->pkeys[lu->sig_idx + 1];
+
+    s->cert->key = s->s3.tmp.cert = s->s3.tmp.sign_cert;
+    s->s3.tmp.sigalg = lu;
+
+    return 1;
+}
+#endif
+
 /*
  * Choose an appropriate signature algorithm based on available certificates
  * Sets chosen certificate and signature algorithm.
Index: b/ssl/t1_trce.c
===================================================================
--- a/ssl/t1_trce.c
+++ b/ssl/t1_trce.c
@@ -68,7 +68,10 @@ static const ssl_trace_tbl ssl_version_t
     {TLS1_3_VERSION, "TLS 1.3"},
     {DTLS1_VERSION, "DTLS 1.0"},
     {DTLS1_2_VERSION, "DTLS 1.2"},
-    {DTLS1_BAD_VER, "DTLS 1.0 (bad)"}
+    {DTLS1_BAD_VER, "DTLS 1.0 (bad)"},
+#ifndef OPENSSL_NO_NTLS
+    {NTLS_VERSION, "NTLS"},
+#endif
 };
 
 static const ssl_trace_tbl ssl_content_tbl[] = {
@@ -449,6 +452,16 @@ static const ssl_trace_tbl ssl_ciphers_t
     {0xC100, "GOST2012-KUZNYECHIK-KUZNYECHIKOMAC"},
     {0xC101, "GOST2012-MAGMA-MAGMAOMAC"},
     {0xC102, "GOST2012-GOST8912-IANA"},
+#ifndef OPENSSL_NO_NTLS
+    {0xE011, "ECDHE_SM4_CBC_SM3"},
+    {0xE051, "ECDHE_SM4_GCM_SM3"},
+    {0xE013, "ECC_SM4_CBC_SM3"},
+    {0xE053, "ECC_SM4_GCM_SM3"},
+    {0xE019, "RSA_SM4_CBC_SM3"},
+    {0xE059, "RSA_SM4_GCM_SM3"},
+    {0xE01C, "RSA_SM4_CBC_SHA256"},
+    {0xE05A, "RSA_SM4_GCM_SHA256"},
+#endif
 };
 
 /* Compression methods */
@@ -546,7 +559,8 @@ static const ssl_trace_tbl ssl_groups_tb
     {259, "ffdhe6144"},
     {260, "ffdhe8192"},
     {0xFF01, "arbitrary_explicit_prime_curves"},
-    {0xFF02, "arbitrary_explicit_char2_curves"}
+    {0xFF02, "arbitrary_explicit_char2_curves"},
+    {41, "curveSM2"},
 };
 
 static const ssl_trace_tbl ssl_point_tbl[] = {
@@ -595,6 +609,7 @@ static const ssl_trace_tbl ssl_sigalg_tb
     {TLSEXT_SIGALG_ecdsa_brainpoolP256r1_sha256, "ecdsa_brainpoolP256r1_sha256"},
     {TLSEXT_SIGALG_ecdsa_brainpoolP384r1_sha384, "ecdsa_brainpoolP384r1_sha384"},
     {TLSEXT_SIGALG_ecdsa_brainpoolP512r1_sha512, "ecdsa_brainpoolP512r1_sha512"},
+    {TLSEXT_SIGALG_sm2sig_sm3, "sm2sig_sm3"},
 };
 
 static const ssl_trace_tbl ssl_ctype_tbl[] = {
@@ -1144,6 +1159,14 @@ static int ssl_get_keyex(const char **pn
         *pname = "GOST18";
         return SSL_kGOST18;
     }
+    if (alg_k & SSL_kSM2) {
+        *pname = "SM2";
+        return SSL_kSM2;
+    }
+    if (alg_k & SSL_kSM2DHE) {
+        *pname = "SM2DHE";
+        return SSL_kSM2DHE;
+    }
     *pname = "UNKNOWN";
     return 0;
 }
@@ -1195,6 +1218,19 @@ static int ssl_print_client_keyex(BIO *b
                       "GOST-wrapped PreMasterSecret", msg, msglen);
         msglen = 0;
         break;
+    case SSL_kSM2:
+        if (!ssl_print_hexbuf(bio, indent + 2,
+                              "EncryptedPreMasterSecret", 2, &msg, &msglen))
+            return 0;
+        break;
+    case SSL_kSM2DHE:
+        ssl_print_hex(bio, indent + 2, "ECParameters", msg, 3);
+        msg += 3;
+        msglen -= 3;
+        if (!ssl_print_hexbuf(bio, indent + 2,
+                              "sm2dh_Yc", 1, &msg, &msglen))
+            return 0;
+        break;
     }
 
     return !msglen;
@@ -1235,6 +1271,7 @@ static int ssl_print_server_keyex(BIO *b
 
     case SSL_kECDHE:
     case SSL_kECDHEPSK:
+    case SSL_kSM2DHE:
         if (msglen < 1)
             return 0;
         BIO_indent(bio, indent + 2, 80);
Index: b/test/babasslapitest.c
===================================================================
--- /dev/null
+++ b/test/babasslapitest.c
@@ -0,0 +1,538 @@
+#include <string.h>
+
+#include <openssl/opensslconf.h>
+#include <openssl/bio.h>
+#include <openssl/crypto.h>
+#include <openssl/ssl.h>
+#include <openssl/ocsp.h>
+#include <openssl/srp.h>
+#include <openssl/txt_db.h>
+#include <openssl/aes.h>
+
+#include "helpers/ssltestlib.h"
+#include "testutil.h"
+#include "testutil/output.h"
+#include "internal/nelem.h"
+#include "../ssl/ssl_local.h"
+
+static char *certsdir = NULL;
+static char *cert = NULL;
+static char *privkey = NULL;
+
+
+static int dummy_cert_cb(SSL *s, void *arg)
+{
+    return 1;
+}
+
+static int test_babassl_get_master_key(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+    int master_key_len;
+    unsigned char *master_key = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    if (SSL_get_master_key(serverssl, &master_key, &master_key_len), 0)
+        goto end;
+
+    if (!TEST_int_eq(master_key_len, 48))
+        goto end;
+
+    if (!TEST_ptr_ne(master_key, NULL))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_debug(void)
+{
+    int testresult = 0;
+    size_t len;
+    FILE *fp;
+    SSL_CTX *ctx = NULL;
+    SSL *s = NULL;
+
+    ctx = SSL_CTX_new(TLS_method());
+    if (!TEST_ptr(ctx))
+        goto end;
+
+    s = SSL_new(ctx);
+    if (!TEST_ptr(s))
+        goto end;
+
+    fflush(stdout);
+    setvbuf(stdout, NULL, _IONBF, 0);
+    fp = freopen("BABASSL_debug.log", "w", stdout);
+    BABASSL_debug(s, (unsigned char *)"BABASSL_debug",
+                  sizeof("BABASSL_debug") - 1);
+    fseek(fp, 0, SEEK_END);
+
+    len = 30;
+#ifdef _WIN32
+    /* \n -> \r\n on Windows */
+    len += 2;
+#endif
+    if(!TEST_int_eq(ftell(fp), len))
+        goto end;
+    fclose(fp);
+#ifdef OPENSSL_SYS_MSDOS
+# define DEV_TTY "con"
+#else
+# define DEV_TTY "/dev/tty"
+#endif
+    fp = freopen(DEV_TTY, "w", stdout);
+    remove("BABASSL_debug.log");
+
+    testresult = 1;
+end:
+    SSL_CTX_free(ctx);
+    SSL_free(s);
+    return testresult;
+}
+
+static int test_babassl_cipher_get(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+    const SSL_CIPHER *cipher;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    cipher = SSL_get_current_cipher(serverssl);
+    if (cipher == NULL)
+        goto end;
+
+    if (!TEST_long_eq(SSL_CIPHER_get_mkey(cipher), cipher->algorithm_mkey))
+        goto end;
+
+    if (!TEST_long_eq(SSL_CIPHER_get_mac(cipher), cipher->algorithm_mac))
+        goto end;
+
+    if (!TEST_long_eq(SSL_CIPHER_get_enc(cipher), cipher->algorithm_enc))
+        goto end;
+
+    if (!TEST_long_eq(SSL_CIPHER_get_auth(cipher), cipher->algorithm_auth))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_session_get_ref(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+
+    if (!TEST_int_eq(SSL_SESSION_get_ref(SSL_get_session(serverssl)), 1))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_get_use_certificate(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    if (!TEST_ptr_eq(SSL_get_use_certificate(serverssl),
+                     SSL_get_certificate(serverssl)))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_get_cert_cb(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey)))
+        goto end;
+
+    SSL_CTX_set_cert_cb(sctx, dummy_cert_cb, (void *)0x99);
+
+    if (SSL_CTX_get_cert_cb(sctx) != dummy_cert_cb
+            || !TEST_ptr_eq(SSL_CTX_get_cert_cb_arg(sctx), (void *)0x99))
+        goto end;
+
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                      NULL, NULL)))
+        goto end;
+
+    if (SSL_get_cert_cb(serverssl) != dummy_cert_cb
+            || !TEST_ptr_eq(SSL_get_cert_cb_arg(serverssl), (void *)0x99))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_get0_alpn_proposed(void)
+{
+    int testresult = 0;
+    unsigned int len;
+    const unsigned char *data;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_int_eq(SSL_CTX_set_alpn_protos(cctx, (u_char *) "\x02h2", 3),
+                        0)
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    SSL_get0_alpn_proposed(serverssl, &data, &len);
+    if (!TEST_int_eq(len, 3))
+        goto end;
+
+    if (memcmp(data, "\x02h2", len) != 0)
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_get0_wbio(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    if (!TEST_ptr_eq(SSL_get0_wbio(serverssl), SSL_CONNECTION_FROM_CONST_SSL(serverssl)->wbio))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_ctx_certs_clear(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    SSL_CTX_certs_clear(sctx);
+
+    SSL_free(serverssl);
+    serverssl = NULL;
+    SSL_free(clientssl);
+    clientssl = NULL;
+
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                      NULL, NULL))
+        || !TEST_false(create_ssl_connection(serverssl, clientssl,
+                                             SSL_ERROR_NONE)))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+
+static int test_babassl_set_session_ctx(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx1 = NULL, *cctx2 = NULL, *sctx1 = NULL, *sctx2 = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx1, &cctx1, cert, privkey))
+        || !TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                          TLS_client_method(),
+                                          TLS1_VERSION, 0,
+                                          &sctx2, &cctx2, cert, privkey))
+        || !TEST_true(create_ssl_objects(sctx1, cctx1, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_ptr_eq(SSL_CONNECTION_FROM_CONST_SSL_ONLY(serverssl)->session_ctx, sctx1)
+        || !TEST_ptr(SSL_set_SESSION_CTX(serverssl, sctx2))
+        || !TEST_ptr_eq(SSL_CONNECTION_FROM_CONST_SSL_ONLY(serverssl)->session_ctx, sctx2))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx1);
+    SSL_CTX_free(sctx2);
+    SSL_CTX_free(cctx1);
+    SSL_CTX_free(cctx2);
+    return testresult;
+}
+
+#ifndef OPENSSL_NO_TLS1_2
+static int client_hello_callback(SSL *s, int *al, void *arg) {
+    int *exts;
+    const int expected_extensions[] = {
+# ifndef OPENSSL_NO_EC
+        11, 10,
+# endif
+        35, 22, 23, 13};
+    size_t len;
+
+    if (!SSL_client_hello_get1_extensions(s, &exts, &len))
+        return SSL_CLIENT_HELLO_ERROR;
+    if (len != OSSL_NELEM(expected_extensions) ||
+        memcmp(exts, expected_extensions, len * sizeof(*exts)) != 0) {
+        OPENSSL_free(exts);
+        return SSL_CLIENT_HELLO_ERROR;
+    }
+
+    OPENSSL_free(exts);
+    return SSL_CLIENT_HELLO_SUCCESS;
+}
+
+static int test_babassl_client_hello_get1_extensions(void)
+{
+    int testresult = 0;
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+
+    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
+                                       TLS_client_method(),
+                                       TLS1_VERSION, 0,
+                                       &sctx, &cctx, cert, privkey)))
+        goto end;
+
+    SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION);
+
+    SSL_CTX_set_client_hello_cb(sctx, client_hello_callback, NULL);
+
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
+                                         NULL, NULL))
+        || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                            SSL_ERROR_NONE)))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    return testresult;
+}
+#endif
+
+#ifndef OPENSSL_NO_OCSP
+static int ocsp_server_called = 0;
+
+static int ocsp_server_cb(SSL *s, void *arg)
+{
+    if (!TEST_int_eq(SSL_check_tlsext_status(s), TLSEXT_STATUSTYPE_ocsp))
+        return SSL_TLSEXT_ERR_ALERT_FATAL;
+
+    ocsp_server_called = 1;
+
+    return SSL_TLSEXT_ERR_OK;
+}
+
+static int test_babassl_tlsext_status(void)
+{
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+    int testresult = 0;
+
+    if (!create_ssl_ctx_pair(NULL, TLS_server_method(), TLS_client_method(),
+                             TLS1_VERSION, TLS1_3_VERSION,
+                             &sctx, &cctx, cert, privkey))
+        return 0;
+
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
+                                      &clientssl, NULL, NULL))
+            || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                                SSL_ERROR_NONE))
+            || !TEST_int_ne(SSL_check_tlsext_status(serverssl),
+                            TLSEXT_STATUSTYPE_ocsp)
+            || !TEST_false(ocsp_server_called))
+        goto end;
+
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    serverssl = NULL;
+    clientssl = NULL;
+
+    if (!SSL_CTX_set_tlsext_status_type(cctx, TLSEXT_STATUSTYPE_ocsp))
+        goto end;
+
+    SSL_CTX_set_tlsext_status_cb(sctx, ocsp_server_cb);
+    SSL_CTX_set_tlsext_status_arg(sctx, NULL);
+
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
+                                      &clientssl, NULL, NULL))
+            || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                                                SSL_ERROR_NONE))
+            || !TEST_int_eq(SSL_check_tlsext_status(serverssl),
+                            TLSEXT_STATUSTYPE_ocsp)
+            || !TEST_true(ocsp_server_called))
+        goto end;
+
+    testresult = 1;
+
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+
+    return testresult;
+}
+#endif
+
+int setup_tests(void)
+{
+    if (!TEST_ptr(certsdir = test_get_argument(0)))
+        return 0;
+
+    cert = test_mk_file_path(certsdir, "servercert.pem");
+    if (cert == NULL)
+        return 0;
+
+    privkey = test_mk_file_path(certsdir, "serverkey.pem");
+    if (privkey == NULL) {
+        OPENSSL_free(cert);
+        return 0;
+    }
+
+    ADD_TEST(test_babassl_debug);
+    ADD_TEST(test_babassl_get_master_key);
+    ADD_TEST(test_babassl_cipher_get);
+    ADD_TEST(test_babassl_session_get_ref);
+    ADD_TEST(test_babassl_get_use_certificate);
+    ADD_TEST(test_babassl_get_cert_cb);
+    ADD_TEST(test_babassl_get0_alpn_proposed);
+    ADD_TEST(test_babassl_get0_wbio);
+    ADD_TEST(test_babassl_ctx_certs_clear);
+    ADD_TEST(test_babassl_set_session_ctx);
+#ifndef OPENSSL_NO_TLS1_2
+    ADD_TEST(test_babassl_client_hello_get1_extensions);
+#endif
+#ifndef OPENSSL_NO_OCSP
+    ADD_TEST(test_babassl_tlsext_status);
+#endif
+    return 1;
+}
+
+void cleanup_tests(void)
+{
+    OPENSSL_free(cert);
+    OPENSSL_free(privkey);
+    bio_s_mempacket_test_free();
+    bio_s_always_retry_free();
+}
Index: b/test/build.info
===================================================================
--- a/test/build.info
+++ b/test/build.info
@@ -63,7 +63,8 @@ IF[{- !$disabled{tests} -}]
           provfetchtest prov_config_test rand_test ca_internals_test \
           bio_tfo_test membio_test bio_dgram_test list_test fips_version_test \
           x509_test hpke_test pairwise_fail_test nodefltctxtest \
-          x509_load_cert_file_test bio_pw_callback_test
+          x509_load_cert_file_test bio_pw_callback_test \
+          babasslapitest
 
   IF[{- !$disabled{'rpk'} -}]
     PROGRAMS{noinst}=rpktest
@@ -106,6 +107,10 @@ IF[{- !$disabled{tests} -}]
   INCLUDE[rand_test]=../include ../apps/include
   DEPEND[rand_test]=../libcrypto.a libtestutil.a
 
+  SOURCE[babasslapitest]=babasslapitest.c helpers/ssltestlib.c
+  INCLUDE[babasslapitest]=.. ../include ../apps/include
+  DEPEND[babasslapitest]=../libcrypto ../libssl libtestutil.a
+
   SOURCE[rsa_complex]=rsa_complex.c
   INCLUDE[rsa_complex]=../include ../apps/include
 
@@ -1133,6 +1138,13 @@ IF[{- !$disabled{tests} -}]
     INCLUDE[pem_read_depr_test]=../include ../apps/include
     DEPEND[pem_read_depr_test]=../libcrypto libtestutil.a
   ENDIF
+
+  IF[{- !$disabled{'ntls'} -}]
+    PROGRAMS{noinst}=ssl_ntls_api_test
+    SOURCE[ssl_ntls_api_test]=ssl_ntls_api_test.c
+    INCLUDE[ssl_ntls_api_test]=.. ../include ../apps/include
+    DEPEND[ssl_ntls_api_test]=../libcrypto ../libssl libtestutil.a
+  ENDIF
 ENDIF
 
   SOURCE[ssl_ctx_test]=ssl_ctx_test.c
Index: b/test/certs/client-rsa-enc-expired.crt
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-enc-expired.crt
@@ -0,0 +1,19 @@
+-----BEGIN CERTIFICATE-----
+MIIDCTCCAfGgAwIBAgIBFTANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdSb290
+IENBMB4XDTAwMDEwMTAwMDAwMFoXDTAxMDEwMTAwMDAwMFowYjELMAkGA1UEBhMC
+QUIxCzAJBgNVBAgMAkNEMQswCQYDVQQHDAJFRjELMAkGA1UECgwCR0gxCzAJBgNV
+BAsMAklKMR8wHQYDVQQDDBZDTElFTlQgUlNBIEVOQyBFWFBJUkVEMIIBIjANBgkq
+hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2VqDa++FfI1B3mYgMkQ9hbPOTJfMl3Le
+U09WQFotW2+Q97DhKY8nHD4qG/JTcVUmeKTaDOOwpyU+GuGZnvFLn0aH92Vnj9ID
+aT6yuL9jhdPC51f1SQivHEH3RxlLrZcdQwrtMLGWQ1hQhXsoOn8fu8VfjskKNbZJ
+pJJfiUNKeWzPNnynxdHVHIEF2OpRc4LEUOaFsyH151zKVCZfLwFH9hqSgOZKmefJ
+eRplL7RfRm7kiZk5M6L28mV4sTmCTKpknYqw+oK2QYYKMJE0QAbFd2kPA5aq5Cm+
+xOnfBOTdNbyRII5XWC3fYeo+16VkBO1nEIe0lnzNYw1FnJ4o1kRkvwIDAQABoxow
+GDAJBgNVHRMEAjAAMAsGA1UdDwQEAwIDODANBgkqhkiG9w0BAQsFAAOCAQEAwU4M
+mltDGMKuS7IrHsS5yU8lKqaFMSP8Zmolzbu6NpXRxr3XHUzkco9kASc9BwQ9cI7A
+3a4Uo24+pZ1TlGK7HR0XNbwL73WAITR7L+Pq2u0Yep/W19ueIVsyQmEbQm3ZNrLv
+23vJxKohPpadMo6KLVW3+vdH+R4gG72OZYT+VclkN94IMJ8adYdRg99paK36nQRW
+Y7GiB3pHXL4SJ2uLuTdFOizjVYdhb/tawdoO/tBcamuD+hmmMXHwg4i9ObLgIlbT
+dD+u3Yadcsu30aWgl3heHkJYU5xqWRn8/Zjfudb7N4OUlSDPgJCqfZy1zu3yrFFx
+e8BMZ6uLSHvn33jeqw==
+-----END CERTIFICATE-----
Index: b/test/certs/client-rsa-enc-expired.key
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-enc-expired.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDZWoNr74V8jUHe
+ZiAyRD2Fs85Ml8yXct5TT1ZAWi1bb5D3sOEpjyccPiob8lNxVSZ4pNoM47CnJT4a
+4Zme8UufRof3ZWeP0gNpPrK4v2OF08LnV/VJCK8cQfdHGUutlx1DCu0wsZZDWFCF
+eyg6fx+7xV+OyQo1tkmkkl+JQ0p5bM82fKfF0dUcgQXY6lFzgsRQ5oWzIfXnXMpU
+Jl8vAUf2GpKA5kqZ58l5GmUvtF9GbuSJmTkzovbyZXixOYJMqmSdirD6grZBhgow
+kTRABsV3aQ8DlqrkKb7E6d8E5N01vJEgjldYLd9h6j7XpWQE7WcQh7SWfM1jDUWc
+nijWRGS/AgMBAAECggEALc+TBYvdUawgJvTVcmLJqMWGBMS13XHbhCmjnzqidrQk
+FOCWBIFkl+JOU8eWaLuuuRzdzHus/v2tglLsYwCulKpz++PGmRyFlYgeeSv1mP5S
+BRqX20XWSploufaN6c+A3mGOLoYvipAxoICdsP6cPKJUCq861KlQCjzDoBWru72c
+p3mVOHpTxPxxMSPDgLX26qzynWgFYjfigFxgDkGnFE+7gqddsbuEuf7oNyh33yXX
+p8OGkMYc6eWo9CNsud1kW2Eb2gju88boDT8O+3mCTtcmzcCba6of8l0OLFRBj/7V
++Ba0jzsvk6yGgZyxGBF/P/AnAdMYSoAzWDRe01cEEQKBgQD7dMXR1z6R9ymEQRu9
+XQN3YMSukOuoUhcZkXe8k4aD5izdW9S9HPsUnpItjdVXyaDjnFtQfEPQEOUJUz6y
+z+cJ/2ekpHXn1I5A6zlRsKAUhvB/BHKU3vflueoT4layvUSvBR3P4q87SqevAFeL
+RtPmKf6+CHbljHnRgsLVQ1o/OQKBgQDdR/u6vhUCVEhceoZ0ILNP0T1gG0AXrxWH
+F9hFjwMXIQULVfrqyFngnqOuAMkyTnVTWfkgQUPgb4xtxuh3D02uohzoziGLmZ3+
+5z90NAXlXQyAaXVs4XPVXUSwsw0e63D4kiay+etqkPKRp51EY2MJoYJ6O+s3L8R6
+FGnKhpfLtwKBgQDHO5B5YMfssx6r8UJfWVEjxwJPJffx14kB8yYhvem4nCk0Akye
+wlWV0sYTXeuJsPHPJdWcAblhI+G078Yfu2Zdn4WpB717wAguG7HAredIHFp06Ts4
+BSn5VMLImm8DE79VxQIH8p3QpqgRmn3Clo3SMbfrLZ225wSmIarpeoII0QKBgQCf
+ESrU7+VcWkf2KqHSgttDak9rcctd+x9HkI2IWyjGjJb6siEAe2uYe5F/+NKo1huj
+Ak+Cr0fi420YUN81DwwxmBmeBOe6WYBpB8TmfKssWPouqSCfV2YUH8rMFro82tTH
+6w/koqFnZrDooYv86FD+UFriEYahkjXz6A6wZpZh+wKBgDKe6s7s6STs18I3wTNi
+wX9S65ZObQji89FhfjdlpJN//JVlysFy8p7FfUMyXnF154SZFMPAOl429lNT7m6l
+oDPBL22LJq2H5wn69CA0AOkJ9+w0QcgJ9i8pnERnM85Nly8i+owHWY5/nA9GQGYG
+UdyT8IcwpDFm8/M1+XbQWUgh
+-----END PRIVATE KEY-----
Index: b/test/certs/client-rsa-enc.crt
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-enc.crt
@@ -0,0 +1,19 @@
+-----BEGIN CERTIFICATE-----
+MIIDAzCCAeugAwIBAgIBEzANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdSb290
+IENBMCAXDTIyMDIxNTAzMzMxM1oYDzIxMjIwMTIyMDMzMzEzWjBaMQswCQYDVQQG
+EwJBQjELMAkGA1UECAwCQ0QxCzAJBgNVBAcMAkVGMQswCQYDVQQKDAJHSDELMAkG
+A1UECwwCSUoxFzAVBgNVBAMMDkNMSUVOVCBSU0EgRU5DMIIBIjANBgkqhkiG9w0B
+AQEFAAOCAQ8AMIIBCgKCAQEAveTwgAGlSgdKyU5ObLFQilckoPnyxdR+XC4nTy+o
++9fhdR0kZZAoK9AFiwL7j37KxacqPO0cBr6QkBxmyLfJ2whNpZVaOvn44lXSEcz3
+kBVz2aFmtJNKKukl8+QYXmngd80dIia8g4ydQTfjKqNQngc5Bp4eDdrnFTqNyeW+
+1mhV4Vx8nkZrzpzDRxFnDueZp98wpmhXTT25igktBErXANo5UMWC1POhFQzt6qbu
+st3GYprkMGchPl+GrL36hCaS4WlzOChF7jX2MNJGCi/g5g1egR+JecWEZBvPgi0f
+V+m3gr+fJv5eCgqlXhmnTAecc/haOYlijRUghtMsry2vGwIDAQABoxowGDAJBgNV
+HRMEAjAAMAsGA1UdDwQEAwIDODANBgkqhkiG9w0BAQsFAAOCAQEAOWReYcJU+Mv1
+rbVPhbQ61032sD3ukidzrpko3fymcCX/HGkxcBuvmtV0lpxoNAuEVbue0Z4SWcHU
+09A5mthsiq6hVk8kCiOmV8YVaMWOZQ0MvYS51t0tf8DDhR//6i/6pQvUVdf35OK1
+ZRSik+8r+Y2BE8vpq9UfM66pAxRjTqMycF3lz4WZyqcIp9hdPeibRGH6lsyVrJ1l
+dVx+HZw6aIsL0Wb2rktge5IDJEAVV9YTPgT9qUnSQKXKCoV80+/y1IzAXJkRzCAv
+GA/J47pBt8BDzrzVAKvxEjNLk6PKn5Fw0fFhJYykGBhYLjPBcx6UErdNH/tmhgMz
+o2EDMZeDhA==
+-----END CERTIFICATE-----
Index: b/test/certs/client-rsa-enc.key
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-enc.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC95PCAAaVKB0rJ
+Tk5ssVCKVySg+fLF1H5cLidPL6j71+F1HSRlkCgr0AWLAvuPfsrFpyo87RwGvpCQ
+HGbIt8nbCE2llVo6+fjiVdIRzPeQFXPZoWa0k0oq6SXz5BheaeB3zR0iJryDjJ1B
+N+Mqo1CeBzkGnh4N2ucVOo3J5b7WaFXhXHyeRmvOnMNHEWcO55mn3zCmaFdNPbmK
+CS0EStcA2jlQxYLU86EVDO3qpu6y3cZimuQwZyE+X4asvfqEJpLhaXM4KEXuNfYw
+0kYKL+DmDV6BH4l5xYRkG8+CLR9X6beCv58m/l4KCqVeGadMB5xz+Fo5iWKNFSCG
+0yyvLa8bAgMBAAECggEAa+r5FvZYdkrQoLkE7taSXByML4P9CZrquP5tzp3aXk3g
+zoriTWnwun19OPRX/MPk/xEyeu+Rtu+D/rJ1Y2q3p+f/ILRRVCUN4as+OGmQ4+yd
+KziDwunWA67+p62gf7+SFuOVw/vZtLUsBY16Z5fqz/Rw3ybrE5qtKy5cuDn+C6DD
+AwZXcQj8i64zrtuZwEycrhwymHYIrMSEN3VUQZrb/BC+CssjAbJPag/oLrPRogQP
+LjH5penusOD/eLZFl/Mc35qckwt4+GZae7onwT8B9cTw9HzxOpxUzpYJuOt/aSII
+P4rSrEBD+cxPaGS1TIhd6gW51BOQE1wC1qDnZWOqsQKBgQDoSdx9WrgXkHttswEZ
+BH6iX4m1tGWHoOqeCG2Vt9lC5AFsx6pInUdoPteC/dJwXnVkxJiHLyLAxLsYnx7c
+Hp6J9dd1DE52LYPDRMos9/Ah9kAUf5mvx5sPvOQZrRR/zgYywOeVi3354k95fQWw
++JvygGHA91ySgtwkCaVMk8wY+QKBgQDRRzye7HQHBbOHdVEmt/YFqeOVRBbAApBe
+xscp2pP51S4DxD5w9VsfN43zzEVN6+SRk/5dMrsjZj2mQlCaCnCuI2EGhlwI9D6R
+g2S09tiru+UGXJ+pdiL0NBwZAlJZxOvfwBHwB+4PzehSRq4Lo3285FaymGDs/4Um
+Lbz3P2lBswKBgEwIwU+W/mNYO86wpU9XFUx5EU6U+hbnKWUJRTWYtFkc4QqGYMrc
+EJ+i0lBiXRvDD5Iod/ToDOwkeUmZ7DQJIcPu4NPDb3tncpXcUoFdtxCm1lrfWaMc
+JzmDjvaInQkomwbJ9gQRYO8GkRUnQ1GmTwWV2GmdjoO2qfBx59WlG02hAoGBAJa/
+ocM4wDtut+uTbmldijJ6Nh2HdnvJXQVoWn6jnIQSM5sy+WeU1ZafBfnf4uxGR9c1
+q7ymlnbhZvckPbs4WgKWKYXxssogZhGbfCd+yISsTEVQ4xHGr1cJUlQRgBB58Q6z
+5Dfq/mkUAY2CrExl8GTodisf6HHPfbIKsFvJqaBRAoGBANt3wITPHb7zklX20B4e
+9IV8MR3tdb/pwm1eFIIYTNWYKBVnix0QaXt21rqcRGgHA9ZJFp4RrnlhAr37z13P
+WZLXkfkdNv2VR1QD1zp1B2ehFRjZyPPuG/UbHcJAw5lqt9qlOZELgMdek8ESnJN7
+7EMRcWWHA32yAekgfrhBF4t9
+-----END PRIVATE KEY-----
Index: b/test/certs/client-rsa-sign-expired.crt
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-sign-expired.crt
@@ -0,0 +1,19 @@
+-----BEGIN CERTIFICATE-----
+MIIDCjCCAfKgAwIBAgIBFDANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdSb290
+IENBMB4XDTAwMDEwMTAwMDAwMFoXDTAxMDEwMTAwMDAwMFowYzELMAkGA1UEBhMC
+QUIxCzAJBgNVBAgMAkNEMQswCQYDVQQHDAJFRjELMAkGA1UECgwCR0gxCzAJBgNV
+BAsMAklKMSAwHgYDVQQDDBdDTElFTlQgUlNBIFNJR04gRVhQSVJFRDCCASIwDQYJ
+KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMLLxeTuPTMMfwq8WMBRHbWH9+qFaZUy
+jLqkfYPg9YzjF/uZ/u1jVgnyK7AUtFvP3DSFgxIrGYXdOk3T/1bvkh1VHyeGEGN/
+/uUKXrnSPjua6U48ID5B++XasjMnpehnHnVK/8sXX4I8iagr9oR4w6R+iAsblTO7
+dfmKY6IxMy479r+0PnKHbUL3PVPxUU1AKnt2h/jVWLLXNI+vhDTroBuOayS/q62e
+zj1xjp4A+8ofS0eEyUP4mkfMcXo8SN0L/MKYGGfXgzviIWdBId839BEOdGKI0ynl
+jgdJsxBHk9peUGRsyZ7j3rtkRYm9bDAJbAmUn+2Ea5tgzFW22NGBMBcCAwEAAaMa
+MBgwCQYDVR0TBAIwADALBgNVHQ8EBAMCBsAwDQYJKoZIhvcNAQELBQADggEBAK6h
+H7SJAfuVEv+DgRnjKXgR77/kZVSkAUfTOwplrxDd+ZCvQPaLp/ALfCqkeO+uu4pb
+E8O+5fEv6JEgY8UqCVUdVhRJO6vh4mweJv7H0vzXKUkobTIltRUNt5H0nV6umx5m
+emWVZImkHZyPxk+RYWwkAAx7N6AsYP9YFDnJ6Mhe/uIeTW7OPHJ4XLGPqcEE7t0f
+r8LJ99qdN/t8ggNautZvtAemH5YNwkj2DXM3DDBlT+zgEAN9Yag2p996tSSePNqo
+SmrecixlKxTaPzgP8ONCwAcJ5mIMIcvwcqu03vAK3d5RnwqkhLJDCVIH5QWFQt+9
+uk+ckLxuRLbubmaIvLs=
+-----END CERTIFICATE-----
Index: b/test/certs/client-rsa-sign-expired.key
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-sign-expired.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDCy8Xk7j0zDH8K
+vFjAUR21h/fqhWmVMoy6pH2D4PWM4xf7mf7tY1YJ8iuwFLRbz9w0hYMSKxmF3TpN
+0/9W75IdVR8nhhBjf/7lCl650j47mulOPCA+Qfvl2rIzJ6XoZx51Sv/LF1+CPImo
+K/aEeMOkfogLG5Uzu3X5imOiMTMuO/a/tD5yh21C9z1T8VFNQCp7dof41Viy1zSP
+r4Q066Abjmskv6utns49cY6eAPvKH0tHhMlD+JpHzHF6PEjdC/zCmBhn14M74iFn
+QSHfN/QRDnRiiNMp5Y4HSbMQR5PaXlBkbMme4967ZEWJvWwwCWwJlJ/thGubYMxV
+ttjRgTAXAgMBAAECggEBALVGZHbSrekfq+oVtJHj6r3QNonsdYD+dbAK+zMK2feu
+LddaS74mPx8qWjWWTvFR0h6eUIdLzIiig2uB6ZDBiTv6xu9E92Ng7Ze/ur86Q+e8
+FXlUwrytMvmIN2UbdG196P5GORyKN7s/EuuJXfORXp9pkLilhoeJ4BPFEUsSdgqC
+6dAGtj8xdsF+657rBmaeX9wvwyQzG0CQgwlBlyW94aDd40JQDjh8YWi7op5gpEgH
+akzbLNXAjk5p+KKVc1tu16ktlqE2J/ziwXBm7TOU+N4TpTlIjEpsfis19AregR07
+T5tPBQrkHUTMiR5E3m/Sg3mGbhlVjLclrnv6NrQxGiECgYEA8x4vOOnYegtLEhyj
+FJ1zz9NSvCJrUgGtCcc8hoFmPhAXxNw6LfiIxXqzFbOHijoIlkzq4rw2ek5WZyHQ
+FTjyLNYnz9I9vaZUJOM4bM75h3Hz5175EL9aIb+TxMjNHG3DlYm+yetlUB59oyYQ
+R3/jBFz4MiJDovt5OofiX4do4uMCgYEAzR4eDfz5NHOj2l0SitrcoVUuXC7Wsc1f
+i3hkFGM53QV4rj2x1OnQKYwauGhv/xFXQWTkxxQRbLoLG5Hes+F5/X34gM2PHy4/
++CuuuNBdZnrzyQSlPoiYhE7hKyx8YXJtx2+Usc2upL0QNzBkCS7Pq3kOoyd3XCg2
+y6w/Jbs6YD0CgYBWpziPoZHeFi5gu0JJM8G2nozLr7zu0tgZNyFUk8ScdGH0ccZu
+4jnloVE5d+7kjsDGyY2i2RDV0Rws0Dl5hv2Si5ZPFZGaCjHNoAtZhQAdjbkwi4Jc
+vMdkZgNGTYgGDP18TEdrcvJ+dw+y2ftNcMC6qmRwghP3gIh6GzrNb9crnwKBgHMs
+aRXTqR6RnDydrC65q88PJGPwjO7zcaW/qPplqPT5AIVd8P+rdg4ONGa9hb2EQClg
+/LDoDMyvPlNxucnpXnU/CY1RXv7UGmlAJfByVy+W9FI4QIz3aCRKolZ6uTCCby/f
+8G9SHbE00+kZS+J4HXWcGOL14yilD/eXNTH7ilDFAoGBAMx6p0q84ryTtTNsTuQA
+XrqLj33aoUP/1dSkpkt205uGIiNE9gSwcacRGr4e4j4GZRzRDCtUpPQ5835+BLJ2
+GRwlvX3RddfrY/XzoLE12qGO5yvoi1GkWiM+clz8yN/5NXSdZQ/IgjYnT3wqPuWx
+JwlpBmqHLFPROqV1vjbCs7i3
+-----END PRIVATE KEY-----
Index: b/test/certs/client-rsa-sign.crt
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-sign.crt
@@ -0,0 +1,19 @@
+-----BEGIN CERTIFICATE-----
+MIIDBDCCAeygAwIBAgIBEjANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdSb290
+IENBMCAXDTIyMDIxNTAzMzAzM1oYDzIxMjIwMTIyMDMzMDMzWjBbMQswCQYDVQQG
+EwJBQjELMAkGA1UECAwCQ0QxCzAJBgNVBAcMAkVGMQswCQYDVQQKDAJHSDELMAkG
+A1UECwwCSUoxGDAWBgNVBAMMD0NMSUVOVCBSU0EgU0lHTjCCASIwDQYJKoZIhvcN
+AQEBBQADggEPADCCAQoCggEBAL7VnKBVPx/13o9WAWgLmxP32ZF4iGkPiycwJuJx
+WNemJjW0lSMbgmS8xgjfsXydUOhshbK+Ttc4Kj+jo6winOhcvJhV66Ri74V+rq5c
+thEK4ZERvTrc8lColIHYWfste5Ntu7J1c5hdvtkiGF5sQlrKcnQf3yv8TAiCMMTX
+M1NycGCBeGCsm+Skia+hv06lWPylhv1k/6eviBxcRSAm0d0xN5te1tAof4Blc0wg
+eEulTOjXg03KLSLWx7v2J+dPmqUqZLAK5wbOdItBUQCHYUaUYKsMuOjdtzcXElCE
+3OrIMeukRvOZn9Exhj4bv3lWzgIbXdtW9YaKp/Zj6rm5P/cCAwEAAaMaMBgwCQYD
+VR0TBAIwADALBgNVHQ8EBAMCBsAwDQYJKoZIhvcNAQELBQADggEBAHEp1xgBGL3p
+ab0TY1OZhWSzy71CiYY8y6aMtqYnC758KI2sypquHNHc5KGHk7uZDB5kOTR+ZAaB
+F1G0IVGFB0Bg2njsk3O447M8/yFUQRleVtqkRKfNQ+/v4Ncrraxxui2+PNbfmiFu
+4R+xpUz7XIlDUXjVpN0u5IZMPKkIbVb6MUm8TRSDYTnL6+Dah33u3XcywZhqdIv4
+ymLi0zvRvUEOqyTYx9dORsj9vQY4zPoUpBRtZLrqwE+6XFq56zPWz5JwucrqOFaE
+XBw4yhAalcoZjcC+b/52j62myHcbydoq68Sn8nz6HRDQZLENIUziaTkJRE7McW9T
+OcBhXe6f2u4=
+-----END CERTIFICATE-----
Index: b/test/certs/client-rsa-sign.key
===================================================================
--- /dev/null
+++ b/test/certs/client-rsa-sign.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+1ZygVT8f9d6P
+VgFoC5sT99mReIhpD4snMCbicVjXpiY1tJUjG4JkvMYI37F8nVDobIWyvk7XOCo/
+o6OsIpzoXLyYVeukYu+Ffq6uXLYRCuGREb063PJQqJSB2Fn7LXuTbbuydXOYXb7Z
+IhhebEJaynJ0H98r/EwIgjDE1zNTcnBggXhgrJvkpImvob9OpVj8pYb9ZP+nr4gc
+XEUgJtHdMTebXtbQKH+AZXNMIHhLpUzo14NNyi0i1se79ifnT5qlKmSwCucGznSL
+QVEAh2FGlGCrDLjo3bc3FxJQhNzqyDHrpEbzmZ/RMYY+G795Vs4CG13bVvWGiqf2
+Y+q5uT/3AgMBAAECggEAT+JHoG5O8GgR9FqCWDWTgzZbYyPbpm8VRyBHBr9/+zXY
+BN9FFt8rJFRJaemJ+Ko59jGHfh1gD4O5W856c1JB8Jrxb6t36uZncbBoGyFALb4q
+UnnkhsF6xfzrvbb9Y8HUWxCyY6/65atIeshk/xG+bRcV9jppR5ZjlaQ6GgwjtigW
+QprgrEV++JPKuWdtUk1LGxsxY2idFUwCkszrewSKuv+I5Kaur/kgSik1HLlR+SfW
+TmyQhRQRar0lc5Qd0JUUw/T+x/AH4sUGP+8b6jnMu+V6HrXNG01oIA0WYf11qbX2
+9i1dM4lSt7X6ZJ956n3gitH0e0hw+5YGSTmBn34uMQKBgQDpgYp8KFiHeygRyFCF
+1IO/b0RvgK3/lXKO/kjMwMfAjdjzYaubYMdSJB3oagZqWME2pJ5eDkp0Lf6PEW9D
+JtmtFG5asHM7VIoHiVc3Qm6lUZ+x6VexI7F3ubLZ5nsvmpU2sH9e0CkKae/LBBTp
+9fDbQywrdwfrnN5VpK1N3JYjowKBgQDRN8Cp/7jZI0Tb9pnRFDT/BOTnWYj90FkB
+kHKOMK0n5XxmJycw/xFMFhyDMdg5QthMCDaxHJf6z36n7ZF/8lHbyd03BgFEdsen
+gcfMput8d9/kVhjhA/zUqwLaAcAl69CCXkiT2Rmq8w36W58LUaUJwDLk2rKyTvwp
+ty+UBuNXnQKBgQCIVyT/HaejY5uf1nB90/ohOtygpmfyRdaf+4WSWDXKDojQgwTq
+MnXvVjtISy/3xF78gt4dWQbME1cBPlLSyMpsrvNIbKK7z77Qa7bLAzULvj8aaH7V
+ZVvn5jux00u2HfJl/mRAfhaYiAaFaZq0iO/bdrtBnby4K93976tpPRVFNQKBgQCF
+1IYXuI7Dxz3K/unRxn1IDBdoretlgJsO1xmQPy7kcHWs2qrFOsQTyakfewj3R/0Y
+VcC2drX5KDW6scr670TRtUUeZ2b0Jo78ZZYrITNNgVjktPZhKa3XVDUUwz3og/nz
+CuCeQqeapLNyTJ1mHinWHO3xWrwoN0IyZQ24QNe4OQKBgQCV6ZANWnHmlcHNULF1
++G+4JydjEGzhzUZ4UKMBLuYMI1TIa+a/ZCP+OUnVzDduFz4hb7D3eBI74E8XhhFj
+FyewqxoAzF1KjVJiQh7G9s0GNnL5yeZdY+rFSvV6HlvScD1NSQKuZGGTgqjkf97m
+WSVIEdTHBEiLcxkL8H/4RZfo8w==
+-----END PRIVATE KEY-----
Index: b/test/certs/server-rsa-enc.crt
===================================================================
--- /dev/null
+++ b/test/certs/server-rsa-enc.crt
@@ -0,0 +1,19 @@
+-----BEGIN CERTIFICATE-----
+MIIDAzCCAeugAwIBAgIBDzANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdSb290
+IENBMCAXDTIyMDIxNTAzMTIyN1oYDzIxMjIwMTIyMDMxMjI3WjBaMQswCQYDVQQG
+EwJBQjELMAkGA1UECAwCQ0QxCzAJBgNVBAcMAkVGMQswCQYDVQQKDAJHSDELMAkG
+A1UECwwCSUoxFzAVBgNVBAMMDlNFUlZFUiBSU0EgRU5DMIIBIjANBgkqhkiG9w0B
+AQEFAAOCAQ8AMIIBCgKCAQEA7TIykMa5+8ksjJM7tl2kKSwr2Q67PB0FFqb8JwzF
+0Q89iQIxSxRzDRPPdAIKvVP/4baiI6vJqUEA9U0aMBZYaDRGhY49z/97cpObmY9t
+zkTcz6mvW9PoOmYx1sfqrSuCW6/Mc1aJc7XH7/xGQzt3lDhNddfyNyxs2tZd8Fdp
+GuF3SPKlfQemqKcIIR+kTCtqgvikXNzEj/P6cKGBSRqEzIfOTF0XESgvHjzRSOvm
+MoJTrVODRh/6sRVFg0ChJbVEmGmYXflYr3yF+L+yW+xgTVY5VffHrDafKxUeIMS6
+Wk7Klk0HSgG3KH2bq9cF6kA8ecQTWM3g3uLECpQpI3smMwIDAQABoxowGDAJBgNV
+HRMEAjAAMAsGA1UdDwQEAwIDODANBgkqhkiG9w0BAQsFAAOCAQEAFVdyVjjQ/hqe
+N6TlIGSoPcl6VW5ssG9FXkdqAsIZKIuIqajXC/vu/7iQ2pZogyGBC79CHEZ+Bk35
+S9QQhtDQiTjsOL2xHO381qadQjL4MaaR7bEAtKjrENbghsQB8lFSm8Wt8GcUXPby
+7t9HQQ3bshHn6yQbPXvf32b+YHNyhdTTnepv8QHl8Pep+R6Uk638SwArOytM2Fvm
+llAaTyZjFAMnfRMBr4c0jjPa2JdLg1ZbASS0CjkVmhU5M1UdJqs+AHxSF0x94OmB
+aT+s2i5hN4SJkTd//r72Kes4cQd3GXXjsNv53yqxo2z3Ph5szbIRm98+HSI7VVbh
+fKZOps4tZA==
+-----END CERTIFICATE-----
Index: b/test/certs/server-rsa-enc.key
===================================================================
--- /dev/null
+++ b/test/certs/server-rsa-enc.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDtMjKQxrn7ySyM
+kzu2XaQpLCvZDrs8HQUWpvwnDMXRDz2JAjFLFHMNE890Agq9U//htqIjq8mpQQD1
+TRowFlhoNEaFjj3P/3tyk5uZj23ORNzPqa9b0+g6ZjHWx+qtK4Jbr8xzVolztcfv
+/EZDO3eUOE111/I3LGza1l3wV2ka4XdI8qV9B6aopwghH6RMK2qC+KRc3MSP8/pw
+oYFJGoTMh85MXRcRKC8ePNFI6+YyglOtU4NGH/qxFUWDQKEltUSYaZhd+VivfIX4
+v7Jb7GBNVjlV98esNp8rFR4gxLpaTsqWTQdKAbcofZur1wXqQDx5xBNYzeDe4sQK
+lCkjeyYzAgMBAAECggEAPRB3RB5lMxUPiwE8li51XMQqZa8NNOSjsrk6oTMAmlm6
+FdOirRmOpQc8mTkNWsCNV6aVB2nqeNBrVruKymZ2TB1pKmj8MNgtB8pIfLgYJMpF
+rpCYvKNJXf+BRTIikIJrBP+1OtxEdq2N05K25AgjON1l07jMerfNLmmRtZZLUMfL
+7CWvWnd3jYXQlR6nlN0ws+cmgtaZTSTNuPGu14w7cv9/L4hDl6wAn3FKQGa4jx3+
+IBzX3TuDXfHF8JzqWkbeGFuwyfYwIz0tCsZ1VdfakyvkUNwymIeyJNk2RDYcGXbi
+dj1DZWYlX+jyrzRXOAxfh3QOknWYihqJitjlOcGRwQKBgQD8KHX/tKoTA2WUE9lC
+aJ30knKoYkEvtlyW51uTjloQdF6JoTz6hcbh3QFJQTt4/6/8SQlvS/t6QxoLIacY
+ATKMfTTwCBPgNYyc0HpHq1czRNeh8hLVNQHzd3jBiHEELfS8vkywcioEAc86eBvy
+FnjN0atukaHnNFJmnjyWfSMFJQKBgQDwz2CtED46mE62hqvJ3K7Byc3OrB2kkrtG
+cCfUGUOBGfe10EcHTZn73/l48+ODzxDGXbCG5ZPNXYQ2Vt/kzNo7Va+aSmFfU/wL
+goc0m79KPa8nKKaf2jiDsneoA5CFQwFiP+khRawUpwKUycbgLBesgTLkhwR60vA0
+Eh3K7pYadwKBgDX4RwE63ugA4x3lfavMDnrJWYcWuJMIuhqGXEBhyH8bGRzmCNIq
+Dd5L2jmen6cPOtCJpV5P6fxKHmnhgw0NPI97QPhbEj372CO8L1/lmV1cz7ZWxJcj
+qE4+9PafSGk3mNlI9csSNFH1PTBrgre2/ZY32TRqMTf2J+jU12zyTauNAoGBAN7U
+xvzeHvdRoOS90ZFFqGCiQNOR6Qw0yx7vAav+hLyeLt4LEO7tHCQ6qTsHU+zQWxFz
++LmbDx3l/0XZNe0esoJdU9VOJrRznrN34W0JAgXM9pshvq4E3G7hYmASjFUEH++u
+fCfRtN6XfIf5/xHJO07hbxqQ5dBSCPvmF7OE+1kZAoGBALl6HFeGjB/4slIKj6r/
+n4GLkePiJXjTvXm52vDs7HLOwFZ/Sw6tN0iWTk1IDBmWykc8MYO3Y8GXUE0hbQGL
+5qWPgUffe8UH0J6j2X2awfFXOmhQ5nwbmN0W5XkWw8cJGNjrO9RxYon6hFctpHxO
+7FaSDafUmHdcu1EYPI4StWr/
+-----END PRIVATE KEY-----
Index: b/test/certs/server-rsa-sign.crt
===================================================================
--- /dev/null
+++ b/test/certs/server-rsa-sign.crt
@@ -0,0 +1,19 @@
+-----BEGIN CERTIFICATE-----
+MIIDBDCCAeygAwIBAgIBDjANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdSb290
+IENBMCAXDTIyMDIxNTAzMDk1NVoYDzIxMjIwMTIyMDMwOTU1WjBbMQswCQYDVQQG
+EwJBQjELMAkGA1UECAwCQ0QxCzAJBgNVBAcMAkVGMQswCQYDVQQKDAJHSDELMAkG
+A1UECwwCSUoxGDAWBgNVBAMMD1NFUlZFUiBSU0EgU0lHTjCCASIwDQYJKoZIhvcN
+AQEBBQADggEPADCCAQoCggEBAL9tQ1nkKJ+Xj68qYcakxRORCfM5PO9OMlUDTYLo
+/qs5XizIKR5/XOpVatSHvtEIaLSOnDlZitUu6mmi12qwcXHSCXAy0xqVtikQBlmz
+TV8fRo3sWPm4QGGe3j1unm1z7EWry+S9Ry8ylBpJwP+qSw9qApYYgwGsvmLhQJNK
+jt8l29VhcukOhXc7Lp4qJ6C2Ib4qpc/CLXLMO4Q6HXVR4xL+rVPhOUBsOaqhzaoR
+VLvsyldqqFuQHxc3ntKUcBtu7ug0wCBNUzP/IoNOhM+Oui06mk6tj7FjYsacy+4z
+QmoZ4B5tdvUs8ObXk5csb2OQeNSZUCd+3vbRfEYA+dUOcjsCAwEAAaMaMBgwCQYD
+VR0TBAIwADALBgNVHQ8EBAMCBsAwDQYJKoZIhvcNAQELBQADggEBANOfhZZcPmVW
+5CnVgYG9+J69cv44zd5Ylf0QZbl4jVCyp3JdMU9vWZQTJxu4MEDwhro+KsxxdfE1
+o8FLteabWV3N0tMtkksNBzRGjRIK9gsCqkomqvMOFMLppbOkBQA6xfvaxynFoquG
+FUK1fxqBPvjTCeFrBcDhrIPym6r+7KpR6A5urVexsbEJttuFXuKxp5dvEqD55H5X
+vYyx10nqMJPYWd/m1fpDw2yg365UYrroomwKHt+thHnqM/acV+uyal65xDw8aYDV
+dBmIwMu6eQ0q1B2DrBdjfRm4reSTJRzh14pZJEHmIvrvG/b451f733c91pZOCP9E
+FLEbPUVYzuI=
+-----END CERTIFICATE-----
Index: b/test/certs/server-rsa-sign.key
===================================================================
--- /dev/null
+++ b/test/certs/server-rsa-sign.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC/bUNZ5Cifl4+v
+KmHGpMUTkQnzOTzvTjJVA02C6P6rOV4syCkef1zqVWrUh77RCGi0jpw5WYrVLupp
+otdqsHFx0glwMtMalbYpEAZZs01fH0aN7Fj5uEBhnt49bp5tc+xFq8vkvUcvMpQa
+ScD/qksPagKWGIMBrL5i4UCTSo7fJdvVYXLpDoV3Oy6eKiegtiG+KqXPwi1yzDuE
+Oh11UeMS/q1T4TlAbDmqoc2qEVS77MpXaqhbkB8XN57SlHAbbu7oNMAgTVMz/yKD
+ToTPjrotOppOrY+xY2LGnMvuM0JqGeAebXb1LPDm15OXLG9jkHjUmVAnft720XxG
+APnVDnI7AgMBAAECggEBAISxg89rBfHiyLn+ofpluyreDkyob6Hezar6eB93zRj5
+0lsugLpgRRM3FK+wTUhvEM2gUZC7ji5KsDl7pOGS34CrvNkmkglKoBQExLInRUnb
+zzeQDvlDjHVe/+ULqgxrH+wHs3Wi8xY3dExotb1D2XYc4SAUa7Ocf/jg9bdkJndt
+fQe6k1AK24sAvKO5CFPKakNeQFLmZ7V4xjwh0ne0ofgfGGiU0ihDbjdOLcvD4Aw6
++vYAYI1aDLTWF0WDJdfSiSfYAtFauOm+CDgK8tKuJ65iICOhayjBGYfxyfOfhi3R
+daYPES5P6zZpWKsxnRDHCdC3FoLhWEDSWS+fmTOXL5kCgYEA96eA6wXYxJ7Gub99
+T6b2HqywaFF0Sbt3xBxH7lwNecPb7FKAeY2dm7THZL3pMc35CA2uBElERwK3uilW
+s735rlgdfuzwgqI2o2PN9DNfwlc6OaXYDapro/D8JaBUqPUkdVwrMIEylzJKzNiw
+HG/EmEAuNHJA48l/RIbZ17gpO6UCgYEAxeCwU83Iu2iLZ6n+bHaWXLa28DY7ZDct
+ilRXSWl18kGfTKWKUifuRF5LChPKb5naUKkfFvw+EkZsNA0zdfzV1s43taNV/qJj
+7Qw+8yMvbwzttJAZHq2hymc6KGUzuyRYEEn3cckLvNIDVv1zj1S4fp0gEa7l0Xbv
+gxseuI87EF8CgYEA8Q9qvVoDld+3MDbkkxPBnjoZvHEM8Hg6K/obSjjwJQYwm+fy
+hl8Cev2M2NLCmmgTb3NhX2qxuy06CUsTygGxd7Ltgw6/TWj4JjKP1pPrMhAV7Ocx
+Vpv8CqgXx8g4n/1+b343zA72X5XkmWCSjBt/EXPnhcVwxEjuSJW6le/8ssECgYA5
+ryuX8ph+0ZY6DRtnQRbKRlWEJzsfFtrGxZmAhCbnDWxD6sos8wkJkzdq46QS7pXv
+B65RhA0QRMlMT0DeN2ubKBijcc8i4PIia3x6Ypp0VB+DkLJR+Cn/GCKjHgV7m7e0
+X+urlwE99TcWB+LFONxjxKhRn1vNuU9PN/u3r8F3HwKBgQCxJUmKYEEqIM8janyh
+scki1IBRn2Pb3XCr/9pdObc7rBNIhLh9OwPvVgI1nczTejMrL7QyEHXZwQ/V3Bvg
+hNWATPOzCqAFultPPfRWmu6jDKH6xCuqIcH7wzEyKuKm7d8x55CFfmNE/go9007N
+4rP/7MaDg/Nepnu8F/ildDHDeg==
+-----END PRIVATE KEY-----
Index: b/test/certs/sm2/chain-ca.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/chain-ca.crt
@@ -0,0 +1,26 @@
+-----BEGIN CERTIFICATE-----
+MIIB4DCCAYagAwIBAgIBADAKBggqgRzPVQGDdTBGMQswCQYDVQQGEwJBQTELMAkG
+A1UECAwCQkIxCzAJBgNVBAoMAkNDMQswCQYDVQQLDAJERDEQMA4GA1UEAwwHcm9v
+dCBjYTAgFw0yMzAyMjIwMjMwMTNaGA8yMTIzMDEyOTAyMzAxM1owRjELMAkGA1UE
+BhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UECwwCREQxEDAO
+BgNVBAMMB3Jvb3QgY2EwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAASN55Ju2pvU
+Bi8UrWHc4ZaKnsqiFPWfcM/6H2Gu/VQ7I1oVnyPktvlTrtwhSy6K43JoCnjVPHrq
+jOXxnkOtGVDVo2MwYTAdBgNVHQ4EFgQUxu7mMmVaB3vq7JRi8UEFHcxVFY4wHwYD
+VR0jBBgwFoAUxu7mMmVaB3vq7JRi8UEFHcxVFY4wDwYDVR0TAQH/BAUwAwEB/zAO
+BgNVHQ8BAf8EBAMCAYYwCgYIKoEcz1UBg3UDSAAwRQIhAIz7tgrp7LmOQEJGPAU3
+8m9PNzMOTqGWZqux8CxIuEGjAiB4cFVYQ4sTCYb/4fNayKYO1FH+Q2Cc7xGq7WPd
+knwWpw==
+-----END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIB4zCCAYigAwIBAgIBATAKBggqgRzPVQGDdTBGMQswCQYDVQQGEwJBQTELMAkG
+A1UECAwCQkIxCzAJBgNVBAoMAkNDMQswCQYDVQQLDAJERDEQMA4GA1UEAwwHcm9v
+dCBjYTAgFw0yMzAyMjIwMjMwMTNaGA8yMTIzMDEyOTAyMzAxM1owRTELMAkGA1UE
+BhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UECwwCREQxDzAN
+BgNVBAMMBnN1YiBjYTBZMBMGByqGSM49AgEGCCqBHM9VAYItA0IABH0feWwae0S0
+w4QQA5cBGYwaQPaxZFcLzIqph+I6BQQCGXaIAabqpO0zjAyf1twYmoM3ZRLJgbZz
+HE/2rRMPBiajZjBkMB0GA1UdDgQWBBSsYesigGJZCD6WyNF/znRcAq88mTAfBgNV
+HSMEGDAWgBTG7uYyZVoHe+rslGLxQQUdzFUVjjASBgNVHRMBAf8ECDAGAQH/AgEA
+MA4GA1UdDwEB/wQEAwIBhjAKBggqgRzPVQGDdQNJADBGAiEApoHDue1bzGukE97O
+BqQbboU1d3jqNg4gAgpMe5fFIosCIQDwndSp7Tc3DZ0QCifXKNqgykjepsWTPZ3R
+NrMzM0rflg==
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/client_enc.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/client_enc.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB7TCCAZKgAwIBAgIUWy6/ole1R8GwTrzoOtZebFla3aowCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAgFw0yMzAyMjIwMjMwMTRaGA8yMTIzMDEy
+OTAyMzAxNFowSTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJD
+QzELMAkGA1UECwwCREQxEzARBgNVBAMMCmNsaWVudCBlbmMwWTATBgcqhkjOPQIB
+BggqgRzPVQGCLQNCAAQpIN3pNIBB3oZ+SaXKoZNtMkH5t5y13MXG1Zsx+NiEZ7Bb
+OFBbEB99vyQry6c9rzlM8IedPw6OwIc58dsA+ncMo1owWDAJBgNVHRMEAjAAMAsG
+A1UdDwQEAwIDODAdBgNVHQ4EFgQUfPE8T3aPRzOi/+LiWTRrkM+0dKgwHwYDVR0j
+BBgwFoAUrGHrIoBiWQg+lsjRf850XAKvPJkwCgYIKoEcz1UBg3UDSQAwRgIhAOIT
+GEUHnILUpLCbSZCyG8TigYmbg7ImyZFtXF/uEhOfAiEA59PnEVYaegvpI5Ltn5T2
+PKKqiZ2QOWEfRHJIi/FFZeo=
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/client_enc.key
===================================================================
--- /dev/null
+++ b/test/certs/sm2/client_enc.key
@@ -0,0 +1,5 @@
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqBHM9VAYItBG0wawIBAQQguz0M4/6qUhgHAxuG
+WI2NPtNciIwmYAN4AUDoBEka1tehRANCAAQpIN3pNIBB3oZ+SaXKoZNtMkH5t5y1
+3MXG1Zsx+NiEZ7BbOFBbEB99vyQry6c9rzlM8IedPw6OwIc58dsA+ncM
+-----END PRIVATE KEY-----
Index: b/test/certs/sm2/client_enc_expire.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/client_enc_expire.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB6zCCAZCgAwIBAgIUMB957+vqASBc5y4ZMBsfYU/FzlAwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAeFw0wMDAxMDEwMDAwMDBaFw0wMTAxMDEw
+MDAwMDBaMEkxCzAJBgNVBAYTAkFBMQswCQYDVQQIDAJCQjELMAkGA1UECgwCQ0Mx
+CzAJBgNVBAsMAkREMRMwEQYDVQQDDApjbGllbnQgZW5jMFkwEwYHKoZIzj0CAQYI
+KoEcz1UBgi0DQgAEKSDd6TSAQd6GfkmlyqGTbTJB+bectdzFxtWbMfjYhGewWzhQ
+WxAffb8kK8unPa85TPCHnT8OjsCHOfHbAPp3DKNaMFgwCQYDVR0TBAIwADALBgNV
+HQ8EBAMCAzgwHQYDVR0OBBYEFHzxPE92j0czov/i4lk0a5DPtHSoMB8GA1UdIwQY
+MBaAFKxh6yKAYlkIPpbI0X/OdFwCrzyZMAoGCCqBHM9VAYN1A0kAMEYCIQDCDf6A
+9OP6LX0TKlssMucsUuYPHBu+dybxydFIUol5kgIhAOgFxSFd6AF43SJbHij2yCsf
+2QugcC3FMVM68PU9iflK
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/client_sign.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/client_sign.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB7jCCAZOgAwIBAgIUbEstbqUWeJMWK3rlwLXE9YdtJ8QwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAgFw0yMzAyMjIwMjMwMTRaGA8yMTIzMDEy
+OTAyMzAxNFowSjELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJD
+QzELMAkGA1UECwwCREQxFDASBgNVBAMMC2NsaWVudCBzaWduMFkwEwYHKoZIzj0C
+AQYIKoEcz1UBgi0DQgAELWF+dNVYbd4j0kkPvUaOMPEdAS1QqPOSzRhJsQsWfpoG
+YffjoqAO5+xHGO2Te0qyxQqg00HRXkCVdDs4UK9tPKNaMFgwCQYDVR0TBAIwADAL
+BgNVHQ8EBAMCBsAwHQYDVR0OBBYEFFRpNXBAPyjFwT7w8EBNJLMVaFgdMB8GA1Ud
+IwQYMBaAFKxh6yKAYlkIPpbI0X/OdFwCrzyZMAoGCCqBHM9VAYN1A0kAMEYCIQDH
+LBaKDJFhHYRNLhYXFBtZH6BIa6cJfewLyVaH0oDaMgIhAMgZQDmGvHCzJ9vdgL2P
+7upTf3I28uj+3pq7ZiwKRBlO
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/client_sign.key
===================================================================
--- /dev/null
+++ b/test/certs/sm2/client_sign.key
@@ -0,0 +1,5 @@
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqBHM9VAYItBG0wawIBAQQg5zLNmBvXdesfATxu
+gMMpvEHfuxhUCr6L8rS2EEBr6SGhRANCAAQtYX501Vht3iPSSQ+9Ro4w8R0BLVCo
+85LNGEmxCxZ+mgZh9+OioA7n7EcY7ZN7SrLFCqDTQdFeQJV0OzhQr208
+-----END PRIVATE KEY-----
Index: b/test/certs/sm2/client_sign_expire.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/client_sign_expire.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB6zCCAZGgAwIBAgIUMcx8UyWHnfbVRe5biYw44Kx6bvwwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAeFw0wMDAxMDEwMDAwMDBaFw0wMTAxMDEw
+MDAwMDBaMEoxCzAJBgNVBAYTAkFBMQswCQYDVQQIDAJCQjELMAkGA1UECgwCQ0Mx
+CzAJBgNVBAsMAkREMRQwEgYDVQQDDAtjbGllbnQgc2lnbjBZMBMGByqGSM49AgEG
+CCqBHM9VAYItA0IABC1hfnTVWG3eI9JJD71GjjDxHQEtUKjzks0YSbELFn6aBmH3
+46KgDufsRxjtk3tKssUKoNNB0V5AlXQ7OFCvbTyjWjBYMAkGA1UdEwQCMAAwCwYD
+VR0PBAQDAgbAMB0GA1UdDgQWBBRUaTVwQD8oxcE+8PBATSSzFWhYHTAfBgNVHSME
+GDAWgBSsYesigGJZCD6WyNF/znRcAq88mTAKBggqgRzPVQGDdQNIADBFAiBiEQiy
+OfgcmIBIohgYJtk/5IrjWI8LbHVGl0jVV0OgKgIhAKs9Mjk/3Mlls/A/G0IPR6p2
+ljXD0/dra7WTooE1z42+
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/server_enc.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/server_enc.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB6zCCAZKgAwIBAgIUaNiS6WOsoEViDnmdb8Mdk3Qz5XwwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAgFw0yMzAyMjIwMjMwMTRaGA8yMTIzMDEy
+OTAyMzAxNFowSTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJD
+QzELMAkGA1UECwwCREQxEzARBgNVBAMMCnNlcnZlciBlbmMwWTATBgcqhkjOPQIB
+BggqgRzPVQGCLQNCAAR9vqVFQ0WBcr07aI5QnC31RYas4AtY7JQUmflKUKWMZ11v
+mtr/CJ6BN6djQ6zS81yjCopcz4G3zc5SZqAWueNko1owWDAJBgNVHRMEAjAAMAsG
+A1UdDwQEAwIDODAdBgNVHQ4EFgQUZ6Wt1ZR24FqcXla4hg/xOyju7FQwHwYDVR0j
+BBgwFoAUrGHrIoBiWQg+lsjRf850XAKvPJkwCgYIKoEcz1UBg3UDRwAwRAIgR1k1
+ecSt7I2335jEquFmHBE5pe8Sk/IqOqQS0Jvs1uYCIG5XMB0XeUaVb9OctaxgOQLN
+F8dRftiUHsyYXqfbaVjI
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/server_enc.key
===================================================================
--- /dev/null
+++ b/test/certs/sm2/server_enc.key
@@ -0,0 +1,5 @@
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqBHM9VAYItBG0wawIBAQQgLrRk3CWTe+WZOFSf
+TMYwbOocLs3MSRpOO0/AvSmvH5mhRANCAAR9vqVFQ0WBcr07aI5QnC31RYas4AtY
+7JQUmflKUKWMZ11vmtr/CJ6BN6djQ6zS81yjCopcz4G3zc5SZqAWueNk
+-----END PRIVATE KEY-----
Index: b/test/certs/sm2/server_enc_expire.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/server_enc_expire.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB6jCCAZCgAwIBAgIURlC8XDK83pSxF4VdK/sfDeNm42QwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAeFw0wMDAxMDEwMDAwMDBaFw0wMTAxMDEw
+MDAwMDBaMEkxCzAJBgNVBAYTAkFBMQswCQYDVQQIDAJCQjELMAkGA1UECgwCQ0Mx
+CzAJBgNVBAsMAkREMRMwEQYDVQQDDApzZXJ2ZXIgZW5jMFkwEwYHKoZIzj0CAQYI
+KoEcz1UBgi0DQgAEfb6lRUNFgXK9O2iOUJwt9UWGrOALWOyUFJn5SlCljGddb5ra
+/wiegTenY0Os0vNcowqKXM+Bt83OUmagFrnjZKNaMFgwCQYDVR0TBAIwADALBgNV
+HQ8EBAMCAzgwHQYDVR0OBBYEFGelrdWUduBanF5WuIYP8Tso7uxUMB8GA1UdIwQY
+MBaAFKxh6yKAYlkIPpbI0X/OdFwCrzyZMAoGCCqBHM9VAYN1A0gAMEUCIQCmSKvp
+2ArjHFa/Z9TrwRwiyw734+QS7ju8OEpJKNeE4QIgTxEwWFkeDEKL6eL6ftuF/a/2
+S/5Xwlef6wuGIE855PI=
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/server_sign.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/server_sign.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB7jCCAZOgAwIBAgIUcbKTlc6+CNoHglmEk+xm+WIqZcAwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAgFw0yMzAyMjIwMjMwMTRaGA8yMTIzMDEy
+OTAyMzAxNFowSjELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJD
+QzELMAkGA1UECwwCREQxFDASBgNVBAMMC3NlcnZlciBzaWduMFkwEwYHKoZIzj0C
+AQYIKoEcz1UBgi0DQgAEBb/67sQGyPP1gKbjnFKEdsDfK2EGXUp09HavD7ZokPiW
+rMSyHYsDbRPxe9TTgjSQi+23f44+rocGVPxvqASNDKNaMFgwCQYDVR0TBAIwADAL
+BgNVHQ8EBAMCBsAwHQYDVR0OBBYEFH3uBqkdowIvk//P7n5UtnpV9TR6MB8GA1Ud
+IwQYMBaAFKxh6yKAYlkIPpbI0X/OdFwCrzyZMAoGCCqBHM9VAYN1A0kAMEYCIQCz
+W/6Z/d/IJUTrO0o8nCxNle6R0AkRCKUFhW9zbIRlNwIhAJZxg4gs2cV2QF37oHs6
+9TD+MkRbql4Yb47+jLf8f247
+-----END CERTIFICATE-----
Index: b/test/certs/sm2/server_sign.key
===================================================================
--- /dev/null
+++ b/test/certs/sm2/server_sign.key
@@ -0,0 +1,5 @@
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqBHM9VAYItBG0wawIBAQQgeQTrKtO8mNXn/yvg
+R+pdbCgH5sl+WCFfXcqGl64soU2hRANCAAQFv/ruxAbI8/WApuOcUoR2wN8rYQZd
+SnT0dq8PtmiQ+JasxLIdiwNtE/F71NOCNJCL7bd/jj6uhwZU/G+oBI0M
+-----END PRIVATE KEY-----
Index: b/test/certs/sm2/server_sign_expire.crt
===================================================================
--- /dev/null
+++ b/test/certs/sm2/server_sign_expire.crt
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIIB6zCCAZGgAwIBAgIUGzfhuDTb9o1gFiWy8bqo3kcPkdQwCgYIKoEcz1UBg3Uw
+RTELMAkGA1UEBhMCQUExCzAJBgNVBAgMAkJCMQswCQYDVQQKDAJDQzELMAkGA1UE
+CwwCREQxDzANBgNVBAMMBnN1YiBjYTAeFw0wMDAxMDEwMDAwMDBaFw0wMTAxMDEw
+MDAwMDBaMEoxCzAJBgNVBAYTAkFBMQswCQYDVQQIDAJCQjELMAkGA1UECgwCQ0Mx
+CzAJBgNVBAsMAkREMRQwEgYDVQQDDAtzZXJ2ZXIgc2lnbjBZMBMGByqGSM49AgEG
+CCqBHM9VAYItA0IABAW/+u7EBsjz9YCm45xShHbA3ythBl1KdPR2rw+2aJD4lqzE
+sh2LA20T8XvU04I0kIvtt3+OPq6HBlT8b6gEjQyjWjBYMAkGA1UdEwQCMAAwCwYD
+VR0PBAQDAgbAMB0GA1UdDgQWBBR97gapHaMCL5P/z+5+VLZ6VfU0ejAfBgNVHSME
+GDAWgBSsYesigGJZCD6WyNF/znRcAq88mTAKBggqgRzPVQGDdQNIADBFAiB+CbW2
+jPan1KPG+AcuiYkaT/XLl0JzZp2pZSgRsL+c5QIhAIfi2T6PJc4ye0vFrRuSIxtq
+CqSPMt9fU97ol6FNXpux
+-----END CERTIFICATE-----
Index: b/test/ciphername_test.c
===================================================================
--- a/test/ciphername_test.c
+++ b/test/ciphername_test.c
@@ -363,6 +363,14 @@ static CIPHER_ID_NAME cipher_names[] = {
     {0x1305, "TLS_AES_128_CCM_8_SHA256"},
     {0xFEFE, "SSL_RSA_FIPS_WITH_DES_CBC_SHA"},
     {0xFEFF, "SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"},
+    {0xE011, "ECDHE_SM4_CBC_SM3"},
+    {0xE051, "ECDHE_SM4_GCM_SM3"},
+    {0xE013, "ECC_SM4_CBC_SM3"},
+    {0xE053, "ECC_SM4_GCM_SM3"},
+    {0xE019, "RSA_SM4_CBC_SM3"},
+    {0xE059, "RSA_SM4_GCM_SM3"},
+    {0xE01C, "RSA_SM4_CBC_SHA256"},
+    {0xE05A, "RSA_SM4_GCM_SHA256"},
 };
 
 static const char *get_std_name_by_id(int id)
Index: b/test/helpers/handshake.c
===================================================================
--- a/test/helpers/handshake.c
+++ b/test/helpers/handshake.c
@@ -1260,7 +1260,7 @@ static char *dup_str(const unsigned char
 
 static int pkey_type(EVP_PKEY *pkey)
 {
-    if (EVP_PKEY_is_a(pkey, "EC")) {
+    if (EVP_PKEY_is_a(pkey, "EC") || EVP_PKEY_is_a(pkey, "SM2")) {
         char name[80];
         size_t name_len;
 
Index: b/test/helpers/ssl_test_ctx.c
===================================================================
--- a/test/helpers/ssl_test_ctx.c
+++ b/test/helpers/ssl_test_ctx.c
@@ -124,6 +124,7 @@ static const test_enum ssl_alerts[] = {
     {"BadCertificate", SSL_AD_BAD_CERTIFICATE},
     {"NoApplicationProtocol", SSL_AD_NO_APPLICATION_PROTOCOL},
     {"CertificateRequired", SSL_AD_CERTIFICATE_REQUIRED},
+    {"CertificateExpired", SSL_AD_CERTIFICATE_EXPIRED},
 };
 
 __owur static int parse_alert(int *alert, const char *value)
@@ -156,6 +157,9 @@ static const test_enum ssl_protocols[] =
      {"SSLv3", SSL3_VERSION},
      {"DTLSv1", DTLS1_VERSION},
      {"DTLSv1.2", DTLS1_2_VERSION},
+#ifndef OPENSSL_NO_NTLS
+     {"NTLS", NTLS_VERSION},
+#endif
 };
 
 __owur static int parse_protocol(SSL_TEST_CTX *test_ctx, const char *value)
@@ -328,7 +332,10 @@ const char *ssl_session_id_name(ssl_sess
 static const test_enum ssl_test_methods[] = {
     {"TLS", SSL_TEST_METHOD_TLS},
     {"DTLS", SSL_TEST_METHOD_DTLS},
-    {"QUIC", SSL_TEST_METHOD_QUIC}
+    {"QUIC", SSL_TEST_METHOD_QUIC},
+#ifndef OPENSSL_NO_NTLS
+    {"NTLS", SSL_TEST_METHOD_NTLS},
+#endif
 };
 
 __owur static int parse_test_method(SSL_TEST_CTX *test_ctx, const char *value)
Index: b/test/recipes/80-test_sign_sm2.t
===================================================================
--- /dev/null
+++ b/test/recipes/80-test_sign_sm2.t
@@ -0,0 +1,249 @@
+#! /usr/bin/env perl
+# Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+
+use strict;
+use warnings;
+
+use POSIX;
+use File::Path 2.00 qw/rmtree/;
+use OpenSSL::Test qw/:DEFAULT data_file merge_files/;
+use OpenSSL::Test::Utils;
+use File::Spec::Functions qw/catfile catdir/;
+
+my $test_name = "test_sign_sm2";
+setup($test_name);
+
+plan skip_all => "sm2 is not supported by this OpenSSL build"
+    if disabled("sm2") || disabled("sm3");
+
+plan tests => 22;
+
+my $CADIR = catdir(".", "ca");
+my $SUBCADIR = catdir(".", "subca");
+
+rmtree(${test_name}, { safe => 0 });
+rmtree(${CADIR}, { safe => 0 });
+rmtree(${SUBCADIR}, { safe => 0 });
+
+sub setup_ca {
+    my $CATOP = shift;
+
+    mkdir($CATOP);
+    mkdir(catdir($CATOP, "newcerts"));
+    mkdir(catdir($CATOP, "db"));
+    mkdir(catdir($CATOP, "private"));
+    mkdir(catdir($CATOP, "crl"));
+
+    open OUT, ">", catfile($CATOP, "db", "index");
+    close OUT;
+    open OUT, ">", catfile($CATOP, "db", "serial");
+    print OUT "00\n";
+    close OUT;
+}
+
+mkdir($test_name);
+setup_ca(${CADIR});
+setup_ca(${SUBCADIR});
+
+# sm2 ca
+ok(run(app(["openssl", "ecparam",
+    "-genkey", "-name", "SM2",
+    "-out", catfile(".", $test_name, "ca.key")])));
+
+ok(run(app(["openssl", "req",
+    "-config", data_file("ca.cnf"),
+    "-new", "-key", catfile(".", $test_name, "ca.key"),
+    "-out", catfile(".", $test_name, "ca.csr"),
+    "-sm3", "-nodes", "-sigopt", "distid:1234567812345678",
+    "-subj", "/C=AA/ST=BB/O=CC/OU=DD/CN=root ca"])));
+
+ok(run(app(["openssl", "ca",
+    "-selfsign", "-config", data_file("ca.cnf"),
+    "-in", catfile(".", $test_name, "ca.csr"),
+    "-keyfile", catfile(".", $test_name, "ca.key"),
+    "-extensions", "v3_ca",
+    "-days", "365",
+    "-notext", "-out", catfile(".", $test_name, "ca.crt"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+# sm2 subca
+ok(run(app(["openssl", "ecparam",
+    "-genkey", "-name", "SM2",
+    "-out", catfile(".", $test_name, "subca.key")])));
+
+ok(run(app(["openssl", "req",
+    "-config", data_file("ca.cnf"),
+    "-new", "-key", catfile(".", $test_name, "subca.key"),
+    "-out", catfile(".", $test_name, "subca.csr"),
+    "-sm3", "-nodes", "-sigopt", "distid:1234567812345678",
+    "-subj", "/C=AA/ST=BB/O=CC/OU=DD/CN=sub ca"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("ca.cnf"),
+    "-in", catfile(".", $test_name, "subca.csr"),
+    "-cert", catfile(".", $test_name, "ca.crt"),
+    "-keyfile", catfile(".", $test_name, "ca.key"),
+    "-extensions", "v3_intermediate_ca",
+    "-days", "365",
+    "-notext", "-out", catfile(".", $test_name, "subca.crt"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+# cat ca.crt subca.crt > chain-ca.crt
+merge_files(catfile(".", $test_name, "ca.crt"),
+    catfile(".", $test_name, "subca.crt"),
+    catfile(".", $test_name, "chain-ca.crt"));
+
+# server sm2 double certs
+ok(run(app(["openssl", "ecparam",
+    "-genkey", "-name", "SM2",
+    "-out", catfile(".", $test_name, "server_sign.key")])));
+
+ok(run(app(["openssl", "req",
+    "-config", data_file("subca.cnf"),
+    "-key", catfile(".", $test_name, "server_sign.key"),
+    "-sm3", "-nodes", "-sigopt", "distid:1234567812345678",
+    "-new", "-out", catfile(".", $test_name, "server_sign.csr"),
+    "-subj", "/C=AA/ST=BB/O=CC/OU=DD/CN=server sign"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "sign_req",
+    "-days", "365",
+    "-in", catfile(".", $test_name, "server_sign.csr"),
+    "-notext", "-out", catfile(".", $test_name, "server_sign.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "sign_req",
+    "-startdate", "20000101000000Z",
+    "-enddate", "20010101000000Z",
+    "-in", catfile(".", $test_name, "server_sign.csr"),
+    "-notext", "-out", catfile(".", $test_name, "server_sign_expire.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+ok(run(app(["openssl", "ecparam",
+    "-genkey", "-name", "SM2",
+    "-out", catfile(".", $test_name, "server_enc.key")])));
+
+ok(run(app(["openssl", "req",
+    "-config", data_file("subca.cnf"),
+    "-key", catfile(".", $test_name, "server_enc.key"),
+    "-nodes", "-sm3", "-sigopt", "distid:1234567812345678",
+    "-new", "-out", catfile(".", $test_name, "server_enc.csr"),
+    "-subj", "/C=AA/ST=BB/O=CC/OU=DD/CN=server enc"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "enc_req",
+    "-days", "365",
+    "-in", catfile(".", $test_name, "server_enc.csr"),
+    "-notext", "-out", catfile(".", $test_name, "server_enc.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "enc_req",
+    "-startdate", "20000101000000Z",
+    "-enddate", "20010101000000Z",
+    "-in", catfile(".", $test_name, "server_enc.csr"),
+    "-notext", "-out", catfile(".", $test_name, "server_enc_expire.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+# client sm2 double certs
+ok(run(app(["openssl", "ecparam",
+    "-genkey", "-name", "SM2",
+    "-out", catfile(".", $test_name, "client_sign.key")])));
+
+ok(run(app(["openssl", "req",
+    "-config", data_file("subca.cnf"),
+    "-key", catfile(".", $test_name, "client_sign.key"),
+    "-nodes", "-sm3", "-sigopt", "distid:1234567812345678",
+    "-new", "-out", catfile(".", $test_name, "client_sign.csr"),
+    "-subj", "/C=AA/ST=BB/O=CC/OU=DD/CN=client sign"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "sign_req",
+    "-days", "365",
+    "-in", catfile(".", $test_name, "client_sign.csr"),
+    "-notext", "-out", catfile(".", $test_name, "client_sign.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-vfyopt", "distid:1234567812345678",
+    "-md", "sm3",
+    "-batch"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "sign_req",
+    "-startdate", "20000101000000Z",
+    "-enddate", "20010101000000Z",
+    "-in", catfile(".", $test_name, "client_sign.csr"),
+    "-notext", "-out", catfile(".", $test_name, "client_sign_expire.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+ok(run(app(["openssl", "ecparam",
+    "-genkey", "-name", "SM2",
+    "-out", catfile(".", $test_name, "client_enc.key")])));
+
+ok(run(app(["openssl", "req",
+    "-config", data_file("subca.cnf"),
+    "-key", catfile(".", $test_name, "client_enc.key"),
+    "-nodes", "-sm3", "-sigopt", "distid:1234567812345678",
+    "-new", "-out", catfile(".", $test_name, "client_enc.csr"),
+    "-subj", "/C=AA/ST=BB/O=CC/OU=DD/CN=client enc"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "enc_req",
+    "-days", "365",
+    "-in", catfile(".", $test_name, "client_enc.csr"),
+    "-notext", "-out", catfile(".", $test_name, "client_enc.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
+
+ok(run(app(["openssl", "ca",
+    "-config", data_file("subca.cnf"),
+    "-extensions", "enc_req",
+    "-startdate", "20000101000000Z",
+    "-enddate", "20010101000000Z",
+    "-in", catfile(".", $test_name, "client_enc.csr"),
+    "-notext", "-out", catfile(".", $test_name, "client_enc_expire.crt"),
+    "-cert", catfile(".", $test_name, "subca.crt"),
+    "-keyfile", catfile(".", $test_name, "subca.key"),
+    "-md", "sm3",
+    "-vfyopt", "distid:1234567812345678",
+    "-batch"])));
Index: b/test/recipes/80-test_sign_sm2_data/ca.cnf
===================================================================
--- /dev/null
+++ b/test/recipes/80-test_sign_sm2_data/ca.cnf
@@ -0,0 +1,135 @@
+[ ca ]
+# `man ca`
+default_ca = CA_default
+
+[ CA_default ]
+# Directory and file locations.
+dir               = ./ca
+certs             = $dir/certs
+crl_dir           = $dir/crl
+new_certs_dir     = $dir/newcerts
+database          = $dir/db/index
+unique_subject	  = no
+serial            = $dir/db/serial
+RANDFILE          = $dir/private/random
+
+# The root key and root certificate.
+private_key       = $dir/ca.key
+certificate       = $dir/ca.crt
+
+# For certificate revocation lists.
+crlnumber         = $dir/crlnumber
+crl               = $dir/crl/ca.crl.pem
+crl_extensions    = crl_ext
+default_crl_days  = 30
+
+# SHA-1 is deprecated, so use SHA-2 instead.
+default_md        = sha256
+
+name_opt          = ca_default
+cert_opt          = ca_default
+default_days      = 365
+preserve          = no
+policy            = policy_strict
+
+[ policy_strict ]
+# The root CA should only sign intermediate certificates that match.
+# See the POLICY FORMAT section of `man ca`.
+countryName             = optional
+stateOrProvinceName     = optional
+organizationName        = optional
+organizationalUnitName  = optional
+commonName              = supplied
+emailAddress            = optional
+
+[ policy_loose ]
+# Allow the intermediate CA to sign a more diverse range of certificates.
+# See the POLICY FORMAT section of the `ca` man page.
+countryName             = optional
+stateOrProvinceName     = optional
+localityName            = optional
+organizationName        = optional
+organizationalUnitName  = optional
+commonName              = supplied
+emailAddress            = optional
+
+[ req ]
+# Options for the `req` tool (`man req`).
+default_bits        = 2048
+distinguished_name  = req_distinguished_name
+string_mask         = utf8only
+
+# SHA-1 is deprecated, so use SHA-2 instead.
+default_md          = sha256
+
+# Extension to add when the -x509 option is used.
+x509_extensions     = v3_ca
+
+req_extensions = v3_req
+
+[ req_distinguished_name ]
+# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
+countryName                     = optional
+stateOrProvinceName             = optional
+localityName                    = optional
+0.organizationName              = optional
+organizationalUnitName          = optional
+commonName                      = optional
+emailAddress                    = optional
+
+[ v3_req ]
+# Extensions to add to a certificate request
+basicConstraints = CA:FALSE
+keyUsage = nonRepudiation, digitalSignature, keyEncipherment
+subjectAltName = @alt_names
+
+[ alt_names ]
+DNS.1 = localhost
+
+[ v3_ca ]
+# Extensions for a typical CA (`man x509v3_config`).
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid:always,issuer
+basicConstraints = critical, CA:true
+keyUsage = critical, digitalSignature, cRLSign, keyCertSign
+
+[ v3_intermediate_ca ]
+# Extensions for a typical intermediate CA (`man x509v3_config`).
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid:always,issuer
+basicConstraints = critical, CA:true, pathlen:0
+keyUsage = critical, digitalSignature, cRLSign, keyCertSign
+[ usr_cert ]
+# Extensions for client certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = client, email
+nsComment = "OpenSSL Generated Client Certificate"
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer
+keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
+extendedKeyUsage = clientAuth, emailProtection
+delegationUsage = serverDelegation, clientDelegation
+
+[ server_cert ]
+# Extensions for server certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = server
+nsComment = "OpenSSL Generated Server Certificate"
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer:always
+keyUsage = critical, digitalSignature, keyEncipherment
+extendedKeyUsage = serverAuth
+subjectAltName = @alt_names
+delegationUsage = serverDelegation, clientDelegation
+
+[ crl_ext ]
+# Extension for CRLs (`man x509v3_config`).
+authorityKeyIdentifier=keyid:always
+
+[ ocsp ]
+# Extension for OCSP signing certificates (`man ocsp`).
+basicConstraints = CA:FALSE
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer
+keyUsage = critical, digitalSignature
+extendedKeyUsage = critical, OCSPSigning
Index: b/test/recipes/80-test_sign_sm2_data/subca.cnf
===================================================================
--- /dev/null
+++ b/test/recipes/80-test_sign_sm2_data/subca.cnf
@@ -0,0 +1,150 @@
+[ ca ]
+# `man ca`
+default_ca = CA_default
+
+[ CA_default ]
+# Directory and file locations.
+dir               = ./subca
+certs             = $dir/certs
+crl_dir           = $dir/crl
+new_certs_dir     = $dir/newcerts
+database          = $dir/db/index
+unique_subject	  = no
+serial            = $dir/db/serial
+RANDFILE          = $dir/private/random
+
+# The root key and root certificate.
+private_key       = $dir/subca.key
+certificate       = $dir/subca.crt
+
+# For certificate revocation lists.
+crlnumber         = $dir/crlnumber
+crl               = $dir/crl/ca.crl.pem
+crl_extensions    = crl_ext
+default_crl_days  = 30
+
+# SHA-1 is deprecated, so use SHA-2 instead.
+default_md        = sm3
+
+name_opt          = ca_default
+cert_opt          = ca_default
+default_days      = 365
+preserve          = no
+policy            = policy_strict
+email_in_dn       = no
+rand_serial       = yes
+
+[ policy_strict ]
+# The root CA should only sign intermediate certificates that match.
+# See the POLICY FORMAT section of `man ca`.
+countryName             = optional
+stateOrProvinceName     = optional
+organizationName        = optional
+organizationalUnitName  = optional
+commonName              = supplied
+emailAddress            = optional
+
+[ policy_loose ]
+# Allow the intermediate CA to sign a more diverse range of certificates.
+# See the POLICY FORMAT section of the `ca` man page.
+countryName             = optional
+stateOrProvinceName     = optional
+localityName            = optional
+organizationName        = optional
+organizationalUnitName  = optional
+commonName              = supplied
+emailAddress            = optional
+
+[ req ]
+# Options for the `req` tool (`man req`).
+default_bits        = 2048
+distinguished_name  = req_distinguished_name
+string_mask         = utf8only
+
+# SHA-1 is deprecated, so use SHA-2 instead.
+default_md          = sha256
+
+# Extension to add when the -x509 option is used.
+x509_extensions     = v3_ca
+
+req_extensions = v3_req
+
+[ req_distinguished_name ]
+# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
+countryName                     = optional
+stateOrProvinceName             = optional
+localityName                    = optional
+0.organizationName              = optional
+organizationalUnitName          = optional
+commonName                      = optional
+emailAddress                    = optional
+
+[ v3_req ]
+
+# Extensions to add to a certificate request
+
+basicConstraints = CA:FALSE
+keyUsage = nonRepudiation, digitalSignature, keyEncipherment
+subjectAltName = @alt_names
+
+[ alt_names ]
+DNS.1 = localhost
+
+[ v3_ca ]
+# Extensions for a typical CA (`man x509v3_config`).
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid:always,issuer
+basicConstraints = critical, CA:true
+keyUsage = critical, digitalSignature, cRLSign, keyCertSign
+
+[ v3_intermediate_ca ]
+# Extensions for a typical intermediate CA (`man x509v3_config`).
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid:always,issuer
+basicConstraints = critical, CA:true, pathlen:0
+keyUsage = critical, digitalSignature, cRLSign, keyCertSign
+
+[ usr_cert ]
+# Extensions for client certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = client, email
+nsComment = "OpenSSL Generated Client Certificate"
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer
+keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
+extendedKeyUsage = clientAuth, emailProtection
+delegationUsage = serverDelegation, clientDelegation
+
+[ server_cert ]
+# Extensions for server certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = server
+nsComment = "OpenSSL Generated Server Certificate"
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer:always
+keyUsage = critical, digitalSignature, keyEncipherment
+extendedKeyUsage = serverAuth
+subjectAltName = @alt_names
+delegationUsage = serverDelegation, clientDelegation
+
+[ crl_ext ]
+# Extension for CRLs (`man x509v3_config`).
+authorityKeyIdentifier=keyid:always
+
+[ ocsp ]
+# Extension for OCSP signing certificates (`man ocsp`).
+basicConstraints = CA:FALSE
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer
+keyUsage = critical, digitalSignature
+extendedKeyUsage = critical, OCSPSigning
+
+[ sign_req ]
+# Extensions to add to a certificate request
+basicConstraints = CA:FALSE
+keyUsage = nonRepudiation, digitalSignature
+
+[ enc_req ]
+# Extensions to add to a certificate request
+basicConstraints = CA:FALSE
+keyUsage = keyAgreement, keyEncipherment, dataEncipherment
Index: b/test/recipes/88-test_ssl_ntls_api.t
===================================================================
--- /dev/null
+++ b/test/recipes/88-test_ssl_ntls_api.t
@@ -0,0 +1,32 @@
+#! /usr/bin/env perl
+# Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+
+use strict;
+use OpenSSL::Test;
+use OpenSSL::Test::Simple;
+use OpenSSL::Test::Utils;
+use OpenSSL::Test qw/:DEFAULT srctop_file/;
+
+setup("test_ssl_ntls_api");
+
+plan tests => 1;
+
+SKIP: {
+    skip "Skipping NTLS test because ntls is disabled in this build", 1
+        if disabled("ntls");
+
+    ok(run(test([ "ssl_ntls_api_test",
+        srctop_file("test", "certs", "sm2", "server_sign.crt"),
+        srctop_file("test", "certs", "sm2", "server_sign.key"),
+        srctop_file("test", "certs", "sm2", "server_enc.crt"),
+        srctop_file("test", "certs", "sm2", "server_enc.key"),
+        srctop_file("test", "certs", "server-rsa-sign.crt"),
+        srctop_file("test", "certs", "server-rsa-sign.key"),
+        srctop_file("test", "certs", "server-rsa-enc.crt"),
+        srctop_file("test", "certs", "server-rsa-enc.key")])));
+}
Index: b/test/recipes/90-test_babasslapi.t
===================================================================
--- /dev/null
+++ b/test/recipes/90-test_babasslapi.t
@@ -0,0 +1,21 @@
+#! /usr/bin/env perl
+
+use OpenSSL::Test::Utils;
+use OpenSSL::Test qw/:DEFAULT srctop_file srctop_dir/;
+use File::Temp qw(tempfile);
+
+setup("test_babasslapi");
+
+plan skip_all => "No TLS/SSL protocols are supported by this OpenSSL build"
+    if alldisabled(grep { $_ ne "ssl3" } available_protocols("tls"));
+
+plan tests => 1;
+
+(undef, my $tmpfilename) = tempfile();
+
+ok(run(test(["babasslapitest", srctop_dir("test", "certs"),
+    srctop_file("test", "recipes", "90-test_sslapi_data",
+        "passwd.txt"), $tmpfilename])),
+    "running babasslapitest");
+
+unlink $tmpfilename;
Index: b/test/ssl-tests/31-ntls.cnf
===================================================================
--- /dev/null
+++ b/test/ssl-tests/31-ntls.cnf
@@ -0,0 +1,580 @@
+# Generated with generate_ssl_tests.pl
+
+num_tests = 17
+
+test-0 = 0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only
+test-1 = 1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only
+test-2 = 2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode
+test-3 = 3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode
+test-4 = 4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode
+test-5 = 5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode
+test-6 = 6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode
+test-7 = 7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode
+test-8 = 8-test ntls client doing handshake without setting certs and pkey
+test-9 = 9-test server encryption certificate expired
+test-10 = 10-test server sign certificate expired
+test-11 = 11-test server certificates expired
+test-12 = 12-test server choose ECC-SM2-SM4 with SM2 double certs only
+test-13 = 13-test server choose RSA-SM4 with RSA double certs only
+test-14 = 14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs
+test-15 = 15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs
+test-16 = 16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs
+# ===========================================================
+
+[0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only]
+ssl_conf = 0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-ssl
+
+[0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-ssl]
+server = 0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-server
+client = 0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-client
+
+[0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[0-test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-client]
+CipherString = ECC-SM2-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-0]
+ExpectedCipher = ECC-SM2-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only]
+ssl_conf = 1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-ssl
+
+[1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-ssl]
+server = 1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-server
+client = 1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-client
+
+[1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[1-test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-1]
+ExpectedCipher = ECC-SM2-SM4-GCM-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode]
+ssl_conf = 2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode-ssl
+
+[2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode-ssl]
+server = 2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode-server
+client = 2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode-client
+
+[2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[2-test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode-client]
+CipherString = ECDHE-SM2-SM4-CBC-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-2]
+ExpectedCipher = ECDHE-SM2-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode]
+ssl_conf = 3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode-ssl
+
+[3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode-ssl]
+server = 3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode-server
+client = 3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode-client
+
+[3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[3-test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-3]
+ExpectedCipher = ECDHE-SM2-SM4-GCM-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode]
+ssl_conf = 4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode-ssl
+
+[4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode-ssl]
+server = 4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode-server
+client = 4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode-client
+
+[4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+
+[4-test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode-client]
+CipherString = RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-4]
+ExpectedCipher = RSA-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode]
+ssl_conf = 5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode-ssl
+
+[5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode-ssl]
+server = 5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode-server
+client = 5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode-client
+
+[5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+
+[5-test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode-client]
+CipherString = RSA-SM4-GCM-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-5]
+ExpectedCipher = RSA-SM4-GCM-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode]
+ssl_conf = 6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode-ssl
+
+[6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode-ssl]
+server = 6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode-server
+client = 6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode-client
+
+[6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+
+[6-test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode-client]
+CipherString = RSA-SM4-CBC-SHA256
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-6]
+ExpectedCipher = RSA-SM4-CBC-SHA256
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode]
+ssl_conf = 7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode-ssl
+
+[7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode-ssl]
+server = 7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode-server
+client = 7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode-client
+
+[7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+
+[7-test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode-client]
+CipherString = RSA-SM4-GCM-SHA256
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-7]
+ExpectedCipher = RSA-SM4-GCM-SHA256
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[8-test ntls client doing handshake without setting certs and pkey]
+ssl_conf = 8-test ntls client doing handshake without setting certs and pkey-ssl
+
+[8-test ntls client doing handshake without setting certs and pkey-ssl]
+server = 8-test ntls client doing handshake without setting certs and pkey-server
+client = 8-test ntls client doing handshake without setting certs and pkey-client
+
+[8-test ntls client doing handshake without setting certs and pkey-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+
+[8-test ntls client doing handshake without setting certs and pkey-client]
+CipherString = ECC-SM2-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
+VerifyMode = Peer
+
+[test-8]
+ExpectedResult = ServerFail
+Method = NTLS
+
+
+# ===========================================================
+
+[9-test server encryption certificate expired]
+ssl_conf = 9-test server encryption certificate expired-ssl
+
+[9-test server encryption certificate expired-ssl]
+server = 9-test server encryption certificate expired-server
+client = 9-test server encryption certificate expired-client
+
+[9-test server encryption certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc_expire.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[9-test server encryption certificate expired-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-9]
+ExpectedClientAlert = CertificateExpired
+ExpectedResult = ClientFail
+Method = NTLS
+
+
+# ===========================================================
+
+[10-test server sign certificate expired]
+ssl_conf = 10-test server sign certificate expired-ssl
+
+[10-test server sign certificate expired-ssl]
+server = 10-test server sign certificate expired-server
+client = 10-test server sign certificate expired-client
+
+[10-test server sign certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign_expire.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[10-test server sign certificate expired-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-10]
+ExpectedClientAlert = CertificateExpired
+ExpectedResult = ClientFail
+Method = NTLS
+
+
+# ===========================================================
+
+[11-test server certificates expired]
+ssl_conf = 11-test server certificates expired-ssl
+
+[11-test server certificates expired-ssl]
+server = 11-test server certificates expired-server
+client = 11-test server certificates expired-client
+
+[11-test server certificates expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc_expire.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign_expire.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[11-test server certificates expired-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-11]
+ExpectedClientAlert = CertificateExpired
+ExpectedResult = ClientFail
+Method = NTLS
+
+
+# ===========================================================
+
+[12-test server choose ECC-SM2-SM4 with SM2 double certs only]
+ssl_conf = 12-test server choose ECC-SM2-SM4 with SM2 double certs only-ssl
+
+[12-test server choose ECC-SM2-SM4 with SM2 double certs only-ssl]
+server = 12-test server choose ECC-SM2-SM4 with SM2 double certs only-server
+client = 12-test server choose ECC-SM2-SM4 with SM2 double certs only-client
+
+[12-test server choose ECC-SM2-SM4 with SM2 double certs only-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[12-test server choose ECC-SM2-SM4 with SM2 double certs only-client]
+CipherString = ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-12]
+ExpectedCipher = ECC-SM2-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[13-test server choose RSA-SM4 with RSA double certs only]
+ssl_conf = 13-test server choose RSA-SM4 with RSA double certs only-ssl
+
+[13-test server choose RSA-SM4 with RSA double certs only-ssl]
+server = 13-test server choose RSA-SM4 with RSA double certs only-server
+client = 13-test server choose RSA-SM4 with RSA double certs only-client
+
+[13-test server choose RSA-SM4 with RSA double certs only-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+
+[13-test server choose RSA-SM4 with RSA double certs only-client]
+CipherString = ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-13]
+ExpectedCipher = RSA-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs]
+ssl_conf = 14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs-ssl
+
+[14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs-ssl]
+server = 14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs-server
+client = 14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs-client
+
+[14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3
+Enable_ntls = on
+Options = ServerPreference
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+RSA.EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+RSA.EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+RSA.SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+RSA.SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+SM2.EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+SM2.EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+SM2.SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SM2.SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[14-test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs-client]
+CipherString = RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-14]
+ExpectedCipher = ECC-SM2-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs]
+ssl_conf = 15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs-ssl
+
+[15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs-ssl]
+server = 15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs-server
+client = 15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs-client
+
+[15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3
+Enable_ntls = on
+Options = ServerPreference
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+RSA.EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+RSA.EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+RSA.SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+RSA.SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+SM2.EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+SM2.EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+SM2.SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SM2.SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[15-test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs-client]
+CipherString = ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-15]
+ExpectedCipher = RSA-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs]
+ssl_conf = 16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs-ssl
+
+[16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs-ssl]
+server = 16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs-server
+client = 16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs-client
+
+[16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3
+Enable_ntls = on
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+RSA.EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+RSA.EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+RSA.SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+RSA.SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+SM2.EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+SM2.EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+SM2.SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SM2.SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[16-test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs-client]
+CipherString = ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-16]
+ExpectedCipher = ECC-SM2-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
Index: b/test/ssl-tests/31-ntls.cnf.in
===================================================================
--- /dev/null
+++ b/test/ssl-tests/31-ntls.cnf.in
@@ -0,0 +1,408 @@
+# -*- mode: perl; -*-
+# Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+
+## Test NTLS handshake
+
+use strict;
+use warnings;
+
+package ssltests;
+use OpenSSL::Test::Utils;
+
+our @tests = (
+
+    {
+        name => "test cipher ECC-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher ECC-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode, NTLS_UNIQUE test server and client all use NTLS only",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher ECDHE-SM2-SM4-CBC-SM3 in NTLS_UNIQUE mode",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECDHE-SM2-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECDHE-SM2-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher ECDHE-SM2-SM4-GCM-SM3 in NTLS_UNIQUE mode",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECDHE-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher RSA-SM4-CBC-SM3 in NTLS_UNIQUE mode",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher RSA-SM4-GCM-SM3 in NTLS_UNIQUE mode",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher RSA-SM4-CBC-SHA256 in NTLS_UNIQUE mode",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-CBC-SHA256",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-CBC-SHA256",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test cipher RSA-SM4-GCM-SHA256 in NTLS_UNIQUE mode",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-GCM-SHA256",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-GCM-SHA256",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test ntls client doing handshake without setting certs and pkey",
+        server => {
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+        },
+    },
+
+    {
+        name => "test server encryption certificate expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc_expire.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ClientFail",
+            "ExpectedClientAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "test server sign certificate expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign_expire.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ClientFail",
+            "ExpectedClientAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "test server certificates expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign_expire.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc_expire.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ClientFail",
+            "ExpectedClientAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "test server choose ECC-SM2-SM4 with SM2 double certs only",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "CipherString" => "RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3",
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test server choose RSA-SM4 with RSA double certs only",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3",
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test server choose the preferred cipher ECC-SM2 with SM2 and RSA double certs",
+        server => {
+            "SM2.SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SM2.SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "SM2.EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "SM2.EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "RSA.SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "RSA.SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "RSA.EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "RSA.EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3",
+            "Options" => "ServerPreference",
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test server choose the preferred cipher RSA-SM4 with SM2 and RSA double certs",
+        server => {
+            "SM2.SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SM2.SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "SM2.EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "SM2.EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "RSA.SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "RSA.SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "RSA.EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "RSA.EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "CipherString" => "RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3",
+            "Options" => "ServerPreference",
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "test server choose the client preferred cipher RSA-SM4 with SM2 and RSA double certs",
+        server => {
+            "SM2.SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SM2.SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "SM2.EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "SM2.EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "RSA.SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "RSA.SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "RSA.EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "RSA.EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "CipherString" => "RSA-SM4-CBC-SM3:ECC-SM2-SM4-CBC-SM3",
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-CBC-SM3:RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+);
Index: b/test/ssl-tests/39-ntls-sni-ticket.cnf
===================================================================
--- /dev/null
+++ b/test/ssl-tests/39-ntls-sni-ticket.cnf
@@ -0,0 +1,971 @@
+# Generated with generate_ssl_tests.pl
+
+num_tests = 17
+
+test-0 = 0-ntls-sni-session-ticket
+test-1 = 1-ntls-sni-session-ticket
+test-2 = 2-ntls-sni-session-ticket
+test-3 = 3-ntls-sni-session-ticket
+test-4 = 4-ntls-sni-session-ticket
+test-5 = 5-ntls-sni-session-ticket
+test-6 = 6-ntls-sni-session-ticket
+test-7 = 7-ntls-sni-session-ticket
+test-8 = 8-ntls-sni-session-ticket
+test-9 = 9-ntls-sni-session-ticket
+test-10 = 10-ntls-sni-session-ticket
+test-11 = 11-ntls-sni-session-ticket
+test-12 = 12-ntls-sni-session-ticket
+test-13 = 13-ntls-sni-session-ticket
+test-14 = 14-ntls-sni-session-ticket
+test-15 = 15-ntls-sni-session-ticket
+test-16 = 16-ntls-sni-session-ticket
+# ===========================================================
+
+[0-ntls-sni-session-ticket]
+ssl_conf = 0-ntls-sni-session-ticket-ssl
+
+[0-ntls-sni-session-ticket-ssl]
+server = 0-ntls-sni-session-ticket-server
+client = 0-ntls-sni-session-ticket-client
+server2 = 0-ntls-sni-session-ticket-server2
+
+[0-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[0-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[0-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-0]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+SessionTicketExpected = No
+server = 0-ntls-sni-session-ticket-server-extra
+client = 0-ntls-sni-session-ticket-client-extra
+
+[0-ntls-sni-session-ticket-server-extra]
+BrokenSessionTicket = Yes
+
+[0-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[1-ntls-sni-session-ticket]
+ssl_conf = 1-ntls-sni-session-ticket-ssl
+
+[1-ntls-sni-session-ticket-ssl]
+server = 1-ntls-sni-session-ticket-server
+client = 1-ntls-sni-session-ticket-client
+server2 = 1-ntls-sni-session-ticket-server2
+
+[1-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[1-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[1-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-1]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = Yes
+server = 1-ntls-sni-session-ticket-server-extra
+client = 1-ntls-sni-session-ticket-client-extra
+
+[1-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[1-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[2-ntls-sni-session-ticket]
+ssl_conf = 2-ntls-sni-session-ticket-ssl
+
+[2-ntls-sni-session-ticket-ssl]
+server = 2-ntls-sni-session-ticket-server
+client = 2-ntls-sni-session-ticket-client
+server2 = 2-ntls-sni-session-ticket-server2
+
+[2-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[2-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[2-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-2]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = Yes
+server = 2-ntls-sni-session-ticket-server-extra
+client = 2-ntls-sni-session-ticket-client-extra
+
+[2-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[2-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[3-ntls-sni-session-ticket]
+ssl_conf = 3-ntls-sni-session-ticket-ssl
+
+[3-ntls-sni-session-ticket-ssl]
+server = 3-ntls-sni-session-ticket-server
+client = 3-ntls-sni-session-ticket-client
+server2 = 3-ntls-sni-session-ticket-server2
+
+[3-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[3-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[3-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-3]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = Yes
+server = 3-ntls-sni-session-ticket-server-extra
+client = 3-ntls-sni-session-ticket-client-extra
+
+[3-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[3-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[4-ntls-sni-session-ticket]
+ssl_conf = 4-ntls-sni-session-ticket-ssl
+
+[4-ntls-sni-session-ticket-ssl]
+server = 4-ntls-sni-session-ticket-server
+client = 4-ntls-sni-session-ticket-client
+server2 = 4-ntls-sni-session-ticket-server2
+
+[4-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[4-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[4-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-4]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 4-ntls-sni-session-ticket-server-extra
+client = 4-ntls-sni-session-ticket-client-extra
+
+[4-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[4-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[5-ntls-sni-session-ticket]
+ssl_conf = 5-ntls-sni-session-ticket-ssl
+
+[5-ntls-sni-session-ticket-ssl]
+server = 5-ntls-sni-session-ticket-server
+client = 5-ntls-sni-session-ticket-client
+server2 = 5-ntls-sni-session-ticket-server2
+
+[5-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[5-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[5-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-5]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 5-ntls-sni-session-ticket-server-extra
+client = 5-ntls-sni-session-ticket-client-extra
+
+[5-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[5-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[6-ntls-sni-session-ticket]
+ssl_conf = 6-ntls-sni-session-ticket-ssl
+
+[6-ntls-sni-session-ticket-ssl]
+server = 6-ntls-sni-session-ticket-server
+client = 6-ntls-sni-session-ticket-client
+server2 = 6-ntls-sni-session-ticket-server2
+
+[6-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[6-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[6-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-6]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 6-ntls-sni-session-ticket-server-extra
+client = 6-ntls-sni-session-ticket-client-extra
+
+[6-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[6-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[7-ntls-sni-session-ticket]
+ssl_conf = 7-ntls-sni-session-ticket-ssl
+
+[7-ntls-sni-session-ticket-ssl]
+server = 7-ntls-sni-session-ticket-server
+client = 7-ntls-sni-session-ticket-client
+server2 = 7-ntls-sni-session-ticket-server2
+
+[7-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[7-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[7-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-7]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 7-ntls-sni-session-ticket-server-extra
+client = 7-ntls-sni-session-ticket-client-extra
+
+[7-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[7-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[8-ntls-sni-session-ticket]
+ssl_conf = 8-ntls-sni-session-ticket-ssl
+
+[8-ntls-sni-session-ticket-ssl]
+server = 8-ntls-sni-session-ticket-server
+client = 8-ntls-sni-session-ticket-client
+server2 = 8-ntls-sni-session-ticket-server2
+
+[8-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[8-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[8-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-8]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 8-ntls-sni-session-ticket-server-extra
+client = 8-ntls-sni-session-ticket-client-extra
+
+[8-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[8-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[9-ntls-sni-session-ticket]
+ssl_conf = 9-ntls-sni-session-ticket-ssl
+
+[9-ntls-sni-session-ticket-ssl]
+server = 9-ntls-sni-session-ticket-server
+client = 9-ntls-sni-session-ticket-client
+server2 = 9-ntls-sni-session-ticket-server2
+
+[9-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[9-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[9-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-9]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 9-ntls-sni-session-ticket-server-extra
+client = 9-ntls-sni-session-ticket-client-extra
+
+[9-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[9-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[10-ntls-sni-session-ticket]
+ssl_conf = 10-ntls-sni-session-ticket-ssl
+
+[10-ntls-sni-session-ticket-ssl]
+server = 10-ntls-sni-session-ticket-server
+client = 10-ntls-sni-session-ticket-client
+server2 = 10-ntls-sni-session-ticket-server2
+
+[10-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[10-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[10-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-10]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 10-ntls-sni-session-ticket-server-extra
+client = 10-ntls-sni-session-ticket-client-extra
+
+[10-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[10-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[11-ntls-sni-session-ticket]
+ssl_conf = 11-ntls-sni-session-ticket-ssl
+
+[11-ntls-sni-session-ticket-ssl]
+server = 11-ntls-sni-session-ticket-server
+client = 11-ntls-sni-session-ticket-client
+server2 = 11-ntls-sni-session-ticket-server2
+
+[11-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[11-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[11-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-11]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 11-ntls-sni-session-ticket-server-extra
+client = 11-ntls-sni-session-ticket-client-extra
+
+[11-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[11-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[12-ntls-sni-session-ticket]
+ssl_conf = 12-ntls-sni-session-ticket-ssl
+
+[12-ntls-sni-session-ticket-ssl]
+server = 12-ntls-sni-session-ticket-server
+client = 12-ntls-sni-session-ticket-client
+server2 = 12-ntls-sni-session-ticket-server2
+
+[12-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[12-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[12-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-12]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 12-ntls-sni-session-ticket-server-extra
+client = 12-ntls-sni-session-ticket-client-extra
+
+[12-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[12-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[13-ntls-sni-session-ticket]
+ssl_conf = 13-ntls-sni-session-ticket-ssl
+
+[13-ntls-sni-session-ticket-ssl]
+server = 13-ntls-sni-session-ticket-server
+client = 13-ntls-sni-session-ticket-client
+server2 = 13-ntls-sni-session-ticket-server2
+
+[13-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[13-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[13-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-13]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 13-ntls-sni-session-ticket-server-extra
+client = 13-ntls-sni-session-ticket-client-extra
+
+[13-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[13-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[14-ntls-sni-session-ticket]
+ssl_conf = 14-ntls-sni-session-ticket-ssl
+
+[14-ntls-sni-session-ticket-ssl]
+server = 14-ntls-sni-session-ticket-server
+client = 14-ntls-sni-session-ticket-client
+server2 = 14-ntls-sni-session-ticket-server2
+
+[14-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[14-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[14-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-14]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 14-ntls-sni-session-ticket-server-extra
+client = 14-ntls-sni-session-ticket-client-extra
+
+[14-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[14-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
+# ===========================================================
+
+[15-ntls-sni-session-ticket]
+ssl_conf = 15-ntls-sni-session-ticket-ssl
+
+[15-ntls-sni-session-ticket-ssl]
+server = 15-ntls-sni-session-ticket-server
+client = 15-ntls-sni-session-ticket-client
+server2 = 15-ntls-sni-session-ticket-server2
+
+[15-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[15-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[15-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-15]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server1
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 15-ntls-sni-session-ticket-server-extra
+client = 15-ntls-sni-session-ticket-client-extra
+
+[15-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[15-ntls-sni-session-ticket-client-extra]
+ServerName = server1
+
+
+# ===========================================================
+
+[16-ntls-sni-session-ticket]
+ssl_conf = 16-ntls-sni-session-ticket-ssl
+
+[16-ntls-sni-session-ticket-ssl]
+server = 16-ntls-sni-session-ticket-server
+client = 16-ntls-sni-session-ticket-client
+server2 = 16-ntls-sni-session-ticket-server2
+
+[16-ntls-sni-session-ticket-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[16-ntls-sni-session-ticket-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+Options = -SessionTicket
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[16-ntls-sni-session-ticket-client]
+CipherString = DEFAULT
+Enable_ntls = on
+Options = -SessionTicket
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-16]
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+ExpectedServerName = server2
+Method = NTLS
+SessionIdExpected = Yes
+SessionTicketExpected = No
+server = 16-ntls-sni-session-ticket-server-extra
+client = 16-ntls-sni-session-ticket-client-extra
+
+[16-ntls-sni-session-ticket-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[16-ntls-sni-session-ticket-client-extra]
+ServerName = server2
+
+
Index: b/test/ssl-tests/39-ntls-sni-ticket.cnf.in
===================================================================
--- /dev/null
+++ b/test/ssl-tests/39-ntls-sni-ticket.cnf.in
@@ -0,0 +1,123 @@
+# -*- mode: perl; -*-
+# Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+
+## Test NTLS SNI/Session tickets
+
+use strict;
+use warnings;
+
+package ssltests;
+use OpenSSL::Test::Utils;
+
+our @tests = ();
+
+sub generate_tests() {
+    foreach my $c ("SessionTicket", "-SessionTicket") {
+        foreach my $s1 ("SessionTicket", "-SessionTicket") {
+            foreach my $s2 ("SessionTicket", "-SessionTicket") {
+                foreach my $n ("server1", "server2") {
+                    my $ticket_result = expected_result($c, $s1, $s2, $n);
+                    my $session_id_result = "Yes"; # always, even with a ticket
+                    push @tests, {
+                        "name" => "ntls-sni-session-ticket",
+                        "client" => {
+                            "Enable_ntls" => "on",
+                            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+                            "Options" => $c,
+                            "extra" => {
+                                "ServerName" => $n,
+                            },
+                        },
+                        "server" => {
+                            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+                            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+                            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+                            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+                            "Enable_ntls" => "on",
+                            "Options" => $s1,
+                            "extra" => {
+                                # We don't test mismatch here.
+                                "ServerNameCallback" => "IgnoreMismatch",
+                            },
+                        },
+                        "server2" => {
+                            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+                            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+                            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+                            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+                            "Enable_ntls" => "on",
+                            "Options" => $s2,
+                        },
+                        "test" => {
+                            "Method" => "NTLS",
+                            "ExpectedServerName" => $n,
+                            "ExpectedResult" => "Success",
+                            "SessionIdExpected" => $session_id_result,
+                            "SessionTicketExpected" => $ticket_result,
+                            "ExpectedProtocol" => "NTLS",
+                        }
+                    };
+                }
+            }
+        }
+    }
+}
+
+# If the client has session tickets disabled, then No support
+# If the server initial_ctx has session tickets disabled, then No support
+# If SNI is in use, then if the "switched-to" context has session tickets disabled,
+#    then No support
+sub expected_result {
+    my ($c, $s1, $s2, $n) = @_;
+
+    return "No" if $c eq "-SessionTicket";
+    return "No" if $s1 eq "-SessionTicket";
+    return "No" if ($s2 eq "-SessionTicket" && $n eq "server2");
+
+    return "Yes";
+}
+
+# Add a "Broken" case.
+push @tests, {
+    "name" => "ntls-sni-session-ticket",
+    "client" => {
+        "Enable_ntls" => "on",
+        "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        "Options" => "SessionTicket",
+        "extra" => {
+            "ServerName" => "server1",
+        }
+    },
+    "server" => {
+        "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+        "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+        "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+        "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+        "Enable_ntls" => "on",
+        "Options" => "SessionTicket",
+        "extra" => {
+              "BrokenSessionTicket" => "Yes",
+        },
+    },
+    "server2" => {
+        "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+        "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+        "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+        "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+        "Enable_ntls" => "on",
+        "Options" => "SessionTicket",
+    },
+    "test" => {
+        "Method" => "NTLS",
+        "ExpectedResult" => "Success",
+        "SessionTicketExpected" => "No",
+        "ExpectedProtocol" => "NTLS",
+    }
+};
+
+generate_tests();
Index: b/test/ssl-tests/40-ntls_client_auth.cnf
===================================================================
--- /dev/null
+++ b/test/ssl-tests/40-ntls_client_auth.cnf
@@ -0,0 +1,836 @@
+# Generated with generate_ssl_tests.pl
+
+num_tests = 22
+
+test-0 = 0-ECC SM2 client auth request
+test-1 = 1-ECC SM2 client auth require fail
+test-2 = 2-ECC SM2 client auth require
+test-3 = 3-ECC SM2 client auth non empty names
+test-4 = 4-ECC SM2 client auth noroot
+test-5 = 5-ECC SM2 client encryption certificate expired
+test-6 = 6-ECC SM2 client sign certificate expired
+test-7 = 7-ECC SM2 client certificates expired
+test-8 = 8-ECDHE SM2 client auth
+test-9 = 9-ECDHE SM2 client auth non empty names
+test-10 = 10-ECDHE SM2 client auth noroot
+test-11 = 11-ECDHE SM2 client encryption certificate expired
+test-12 = 12-ECDHE SM2 client sign certificate expired
+test-13 = 13-ECDHE SM2 client certificates expired
+test-14 = 14-RSA client auth request
+test-15 = 15-RSA client auth require fail
+test-16 = 16-RSA client auth require
+test-17 = 17-RSA client auth non empty names
+test-18 = 18-RSA client auth noroot
+test-19 = 19-RSA client encryption certificate expired
+test-20 = 20-RSA client sign certificate expired
+test-21 = 21-RSA client certificates expired
+# ===========================================================
+
+[0-ECC SM2 client auth request]
+ssl_conf = 0-ECC SM2 client auth request-ssl
+
+[0-ECC SM2 client auth request-ssl]
+server = 0-ECC SM2 client auth request-server
+client = 0-ECC SM2 client auth request-client
+
+[0-ECC SM2 client auth request-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Request
+
+[0-ECC SM2 client auth request-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-0]
+ExpectedCipher = ECC-SM2-SM4-GCM-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[1-ECC SM2 client auth require fail]
+ssl_conf = 1-ECC SM2 client auth require fail-ssl
+
+[1-ECC SM2 client auth require fail-ssl]
+server = 1-ECC SM2 client auth require fail-server
+client = 1-ECC SM2 client auth require fail-client
+
+[1-ECC SM2 client auth require fail-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Require
+
+[1-ECC SM2 client auth require fail-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-1]
+ExpectedResult = ServerFail
+ExpectedServerAlert = HandshakeFailure
+Method = NTLS
+
+
+# ===========================================================
+
+[2-ECC SM2 client auth require]
+ssl_conf = 2-ECC SM2 client auth require-ssl
+
+[2-ECC SM2 client auth require-ssl]
+server = 2-ECC SM2 client auth require-server
+client = 2-ECC SM2 client auth require-client
+
+[2-ECC SM2 client auth require-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Require
+
+[2-ECC SM2 client auth require-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-2]
+ExpectedCipher = ECC-SM2-SM4-GCM-SM3
+ExpectedClientCANames = empty
+ExpectedClientCertType = SM2
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[3-ECC SM2 client auth non empty names]
+ssl_conf = 3-ECC SM2 client auth non empty names-ssl
+
+[3-ECC SM2 client auth non empty names-ssl]
+server = 3-ECC SM2 client auth non empty names-server
+client = 3-ECC SM2 client auth non empty names-client
+
+[3-ECC SM2 client auth non empty names-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+ClientCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Require
+
+[3-ECC SM2 client auth non empty names-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-3]
+ExpectedCipher = ECC-SM2-SM4-GCM-SM3
+ExpectedClientCANames = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+ExpectedClientCertType = SM2
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[4-ECC SM2 client auth noroot]
+ssl_conf = 4-ECC SM2 client auth noroot-ssl
+
+[4-ECC SM2 client auth noroot-ssl]
+server = 4-ECC SM2 client auth noroot-server
+client = 4-ECC SM2 client auth noroot-client
+
+[4-ECC SM2 client auth noroot-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyMode = Require
+
+[4-ECC SM2 client auth noroot-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-4]
+ExpectedResult = ServerFail
+ExpectedServerAlert = UnknownCA
+Method = NTLS
+
+
+# ===========================================================
+
+[5-ECC SM2 client encryption certificate expired]
+ssl_conf = 5-ECC SM2 client encryption certificate expired-ssl
+
+[5-ECC SM2 client encryption certificate expired-ssl]
+server = 5-ECC SM2 client encryption certificate expired-server
+client = 5-ECC SM2 client encryption certificate expired-client
+
+[5-ECC SM2 client encryption certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Require
+
+[5-ECC SM2 client encryption certificate expired-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc_expire.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-5]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[6-ECC SM2 client sign certificate expired]
+ssl_conf = 6-ECC SM2 client sign certificate expired-ssl
+
+[6-ECC SM2 client sign certificate expired-ssl]
+server = 6-ECC SM2 client sign certificate expired-server
+client = 6-ECC SM2 client sign certificate expired-client
+
+[6-ECC SM2 client sign certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Require
+
+[6-ECC SM2 client sign certificate expired-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign_expire.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-6]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[7-ECC SM2 client certificates expired]
+ssl_conf = 7-ECC SM2 client certificates expired-ssl
+
+[7-ECC SM2 client certificates expired-ssl]
+server = 7-ECC SM2 client certificates expired-server
+client = 7-ECC SM2 client certificates expired-client
+
+[7-ECC SM2 client certificates expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Require
+
+[7-ECC SM2 client certificates expired-client]
+CipherString = ECC-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc_expire.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign_expire.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-7]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[8-ECDHE SM2 client auth]
+ssl_conf = 8-ECDHE SM2 client auth-ssl
+
+[8-ECDHE SM2 client auth-ssl]
+server = 8-ECDHE SM2 client auth-server
+client = 8-ECDHE SM2 client auth-client
+
+[8-ECDHE SM2 client auth-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[8-ECDHE SM2 client auth-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-8]
+ExpectedCipher = ECDHE-SM2-SM4-GCM-SM3
+ExpectedClientCANames = empty
+ExpectedClientCertType = SM2
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[9-ECDHE SM2 client auth non empty names]
+ssl_conf = 9-ECDHE SM2 client auth non empty names-ssl
+
+[9-ECDHE SM2 client auth non empty names-ssl]
+server = 9-ECDHE SM2 client auth non empty names-server
+client = 9-ECDHE SM2 client auth non empty names-client
+
+[9-ECDHE SM2 client auth non empty names-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+ClientCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[9-ECDHE SM2 client auth non empty names-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-9]
+ExpectedCipher = ECDHE-SM2-SM4-GCM-SM3
+ExpectedClientCANames = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+ExpectedClientCertType = SM2
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[10-ECDHE SM2 client auth noroot]
+ssl_conf = 10-ECDHE SM2 client auth noroot-ssl
+
+[10-ECDHE SM2 client auth noroot-ssl]
+server = 10-ECDHE SM2 client auth noroot-server
+client = 10-ECDHE SM2 client auth noroot-client
+
+[10-ECDHE SM2 client auth noroot-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[10-ECDHE SM2 client auth noroot-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-10]
+ExpectedResult = ServerFail
+ExpectedServerAlert = UnknownCA
+Method = NTLS
+
+
+# ===========================================================
+
+[11-ECDHE SM2 client encryption certificate expired]
+ssl_conf = 11-ECDHE SM2 client encryption certificate expired-ssl
+
+[11-ECDHE SM2 client encryption certificate expired-ssl]
+server = 11-ECDHE SM2 client encryption certificate expired-server
+client = 11-ECDHE SM2 client encryption certificate expired-client
+
+[11-ECDHE SM2 client encryption certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[11-ECDHE SM2 client encryption certificate expired-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc_expire.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-11]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[12-ECDHE SM2 client sign certificate expired]
+ssl_conf = 12-ECDHE SM2 client sign certificate expired-ssl
+
+[12-ECDHE SM2 client sign certificate expired-ssl]
+server = 12-ECDHE SM2 client sign certificate expired-server
+client = 12-ECDHE SM2 client sign certificate expired-client
+
+[12-ECDHE SM2 client sign certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[12-ECDHE SM2 client sign certificate expired-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign_expire.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-12]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[13-ECDHE SM2 client certificates expired]
+ssl_conf = 13-ECDHE SM2 client certificates expired-ssl
+
+[13-ECDHE SM2 client certificates expired-ssl]
+server = 13-ECDHE SM2 client certificates expired-server
+client = 13-ECDHE SM2 client certificates expired-client
+
+[13-ECDHE SM2 client certificates expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+
+[13-ECDHE SM2 client certificates expired-client]
+CipherString = ECDHE-SM2-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_enc_expire.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/client_sign_expire.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/client_sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-13]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[14-RSA client auth request]
+ssl_conf = 14-RSA client auth request-ssl
+
+[14-RSA client auth request-ssl]
+server = 14-RSA client auth request-server
+client = 14-RSA client auth request-client
+
+[14-RSA client auth request-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyMode = Request
+
+[14-RSA client auth request-client]
+CipherString = RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-14]
+ExpectedCipher = RSA-SM4-CBC-SM3
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[15-RSA client auth require fail]
+ssl_conf = 15-RSA client auth require fail-ssl
+
+[15-RSA client auth require fail-ssl]
+server = 15-RSA client auth require fail-server
+client = 15-RSA client auth require fail-client
+
+[15-RSA client auth require fail-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyMode = Require
+
+[15-RSA client auth require fail-client]
+CipherString = RSA-SM4-CBC-SM3
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-15]
+ExpectedResult = ServerFail
+ExpectedServerAlert = HandshakeFailure
+Method = NTLS
+
+
+# ===========================================================
+
+[16-RSA client auth require]
+ssl_conf = 16-RSA client auth require-ssl
+
+[16-RSA client auth require-ssl]
+server = 16-RSA client auth require-server
+client = 16-RSA client auth require-client
+
+[16-RSA client auth require-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Require
+
+[16-RSA client auth require-client]
+CipherString = RSA-SM4-CBC-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-16]
+ExpectedCipher = RSA-SM4-CBC-SM3
+ExpectedClientCANames = empty
+ExpectedClientCertType = RSA
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[17-RSA client auth non empty names]
+ssl_conf = 17-RSA client auth non empty names-ssl
+
+[17-RSA client auth non empty names-ssl]
+server = 17-RSA client auth non empty names-server
+client = 17-RSA client auth non empty names-client
+
+[17-RSA client auth non empty names-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+ClientCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Require
+
+[17-RSA client auth non empty names-client]
+CipherString = RSA-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-17]
+ExpectedCipher = RSA-SM4-GCM-SM3
+ExpectedClientCANames = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+ExpectedClientCertType = RSA
+ExpectedProtocol = NTLS
+ExpectedResult = Success
+Method = NTLS
+
+
+# ===========================================================
+
+[18-RSA client auth noroot]
+ssl_conf = 18-RSA client auth noroot-ssl
+
+[18-RSA client auth noroot-ssl]
+server = 18-RSA client auth noroot-server
+client = 18-RSA client auth noroot-client
+
+[18-RSA client auth noroot-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyMode = Require
+
+[18-RSA client auth noroot-client]
+CipherString = RSA-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-18]
+ExpectedResult = ServerFail
+ExpectedServerAlert = UnknownCA
+Method = NTLS
+
+
+# ===========================================================
+
+[19-RSA client encryption certificate expired]
+ssl_conf = 19-RSA client encryption certificate expired-ssl
+
+[19-RSA client encryption certificate expired-ssl]
+server = 19-RSA client encryption certificate expired-server
+client = 19-RSA client encryption certificate expired-client
+
+[19-RSA client encryption certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Require
+
+[19-RSA client encryption certificate expired-client]
+CipherString = RSA-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-enc-expired.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-enc-expired.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-19]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[20-RSA client sign certificate expired]
+ssl_conf = 20-RSA client sign certificate expired-ssl
+
+[20-RSA client sign certificate expired-ssl]
+server = 20-RSA client sign certificate expired-server
+client = 20-RSA client sign certificate expired-client
+
+[20-RSA client sign certificate expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Require
+
+[20-RSA client sign certificate expired-client]
+CipherString = RSA-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-enc.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-sign-expired.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-sign-expired.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-20]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
+# ===========================================================
+
+[21-RSA client certificates expired]
+ssl_conf = 21-RSA client certificates expired-ssl
+
+[21-RSA client certificates expired-ssl]
+server = 21-RSA client certificates expired-server
+client = 21-RSA client certificates expired-client
+
+[21-RSA client certificates expired-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/server-rsa-sign.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Require
+
+[21-RSA client certificates expired-client]
+CipherString = RSA-SM4-GCM-SM3
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-enc-expired.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-enc-expired.key
+SignCertificate = ${ENV::TEST_CERTS_DIR}/client-rsa-sign-expired.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/client-rsa-sign-expired.key
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
+VerifyMode = Peer
+
+[test-21]
+ExpectedResult = ServerFail
+ExpectedServerAlert = CertificateExpired
+Method = NTLS
+
+
Index: b/test/ssl-tests/40-ntls_client_auth.cnf.in
===================================================================
--- /dev/null
+++ b/test/ssl-tests/40-ntls_client_auth.cnf.in
@@ -0,0 +1,608 @@
+# -*- mode: perl; -*-
+# Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+
+## Test NTLS client auth
+
+use strict;
+use warnings;
+
+package ssltests;
+use OpenSSL::Test::Utils;
+
+our @tests = (
+
+    {
+        name => "ECC SM2 client auth request",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "VerifyMode" => "Request",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "ECC SM2 client auth require fail",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "HandshakeFailure",
+        },
+    },
+
+    {
+        name => "ECC SM2 client auth require",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedClientCANames" => "empty",
+            "ExpectedClientCertType" => "SM2",
+        },
+    },
+
+    {
+        name => "ECC SM2 client auth non empty names",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "ClientCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECC-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedClientCANames" => test_pem("sm2", "chain-ca.crt"),
+            "ExpectedClientCertType" => "SM2",
+        },
+    },
+
+    {
+        name => "ECC SM2 client auth noroot",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "UnknownCA",
+        },
+    },
+
+    {
+        name => "ECC SM2 client encryption certificate expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc_expire.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "ECC SM2 client sign certificate expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign_expire.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "ECC SM2 client certificates expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign_expire.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc_expire.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            "CipherString" => "ECC-SM2-SM4-GCM-SM3",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "ECDHE SM2 client auth",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECDHE-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedClientCANames" => "empty",
+            "ExpectedClientCertType" => "SM2",
+        },
+    },
+
+    {
+        name => "ECDHE SM2 client auth non empty names",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "ClientCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "ECDHE-SM2-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedClientCANames" => test_pem("sm2", "chain-ca.crt"),
+            "ExpectedClientCertType" => "SM2",
+        },
+    },
+
+    {
+        name => "ECDHE SM2 client auth noroot",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "UnknownCA",
+        },
+    },
+
+    {
+        name => "ECDHE SM2 client encryption certificate expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc_expire.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "ECDHE SM2 client sign certificate expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign_expire.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "ECDHE SM2 client certificates expired",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+        },
+        client => {
+            "SignCertificate" => test_pem("sm2", "client_sign_expire.crt"),
+            "SignPrivateKey" => test_pem("sm2", "client_sign.key"),
+            "EncCertificate" => test_pem("sm2", "client_enc_expire.crt"),
+            "EncPrivateKey" => test_pem("sm2", "client_enc.key"),
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            "CipherString" => "ECDHE-SM2-SM4-GCM-SM3",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "RSA client auth request",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Request",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+        },
+    },
+
+    {
+        name => "RSA client auth require fail",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "CipherString" => "RSA-SM4-CBC-SM3",
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "HandshakeFailure",
+        },
+    },
+
+    {
+        name => "RSA client auth require",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("client-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("client-rsa-sign.key"),
+            "EncCertificate" => test_pem("client-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("client-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "CipherString" => "RSA-SM4-CBC-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-CBC-SM3",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedClientCANames" => "empty",
+            "ExpectedClientCertType" => "RSA",
+        },
+    },
+
+    {
+        name => "RSA client auth non empty names",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "ClientCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("client-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("client-rsa-sign.key"),
+            "EncCertificate" => test_pem("client-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("client-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "CipherString" => "RSA-SM4-GCM-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "Success",
+            "ExpectedCipher" => "RSA-SM4-GCM-SM3",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedClientCANames" => test_pem("root-cert.pem"),
+            "ExpectedClientCertType" => "RSA",
+        },
+    },
+
+    {
+        name => "RSA client auth noroot",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("client-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("client-rsa-sign.key"),
+            "EncCertificate" => test_pem("client-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("client-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "CipherString" => "RSA-SM4-GCM-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "UnknownCA",
+        },
+    },
+
+    {
+        name => "RSA client encryption certificate expired",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("client-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("client-rsa-sign.key"),
+            "EncCertificate" => test_pem("client-rsa-enc-expired.crt"),
+            "EncPrivateKey" => test_pem("client-rsa-enc-expired.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "CipherString" => "RSA-SM4-GCM-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "RSA client sign certificate expired",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("client-rsa-sign-expired.crt"),
+            "SignPrivateKey" => test_pem("client-rsa-sign-expired.key"),
+            "EncCertificate" => test_pem("client-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("client-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "CipherString" => "RSA-SM4-GCM-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+
+    {
+        name => "RSA client certificates expired",
+        server => {
+            "SignCertificate" => test_pem("server-rsa-sign.crt"),
+            "SignPrivateKey" => test_pem("server-rsa-sign.key"),
+            "EncCertificate" => test_pem("server-rsa-enc.crt"),
+            "EncPrivateKey" => test_pem("server-rsa-enc.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "Enable_ntls" => "on",
+            "VerifyMode" => "Require",
+        },
+        client => {
+            "SignCertificate" => test_pem("client-rsa-sign-expired.crt"),
+            "SignPrivateKey" => test_pem("client-rsa-sign-expired.key"),
+            "EncCertificate" => test_pem("client-rsa-enc-expired.crt"),
+            "EncPrivateKey" => test_pem("client-rsa-enc-expired.key"),
+            "VerifyCAFile" => test_pem("root-cert.pem"),
+            "CipherString" => "RSA-SM4-GCM-SM3",
+            "Enable_ntls" => "on",
+        },
+        test   => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "CertificateExpired",
+        },
+    },
+);
Index: b/test/ssl-tests/41-ntls-alpn.cnf
===================================================================
--- /dev/null
+++ b/test/ssl-tests/41-ntls-alpn.cnf
@@ -0,0 +1,783 @@
+# Generated with generate_ssl_tests.pl
+
+num_tests = 16
+
+test-0 = 0-alpn-simple
+test-1 = 1-alpn-server-finds-match
+test-2 = 2-alpn-server-honours-server-pref
+test-3 = 3-alpn-alert-on-mismatch
+test-4 = 4-alpn-no-server-support
+test-5 = 5-alpn-no-client-support
+test-6 = 6-alpn-with-sni-no-context-switch
+test-7 = 7-alpn-with-sni-context-switch
+test-8 = 8-alpn-selected-sni-server-supports-alpn
+test-9 = 9-alpn-selected-sni-server-does-not-support-alpn
+test-10 = 10-alpn-simple-resumption
+test-11 = 11-alpn-server-switch-resumption
+test-12 = 12-alpn-client-switch-resumption
+test-13 = 13-alpn-alert-on-mismatch-resumption
+test-14 = 14-alpn-no-server-support-resumption
+test-15 = 15-alpn-no-client-support-resumption
+# ===========================================================
+
+[0-alpn-simple]
+ssl_conf = 0-alpn-simple-ssl
+
+[0-alpn-simple-ssl]
+server = 0-alpn-simple-server
+client = 0-alpn-simple-client
+
+[0-alpn-simple-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[0-alpn-simple-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-0]
+ExpectedALPNProtocol = foo
+ExpectedProtocol = NTLS
+Method = NTLS
+server = 0-alpn-simple-server-extra
+client = 0-alpn-simple-client-extra
+
+[0-alpn-simple-server-extra]
+ALPNProtocols = foo
+
+[0-alpn-simple-client-extra]
+ALPNProtocols = foo
+
+
+# ===========================================================
+
+[1-alpn-server-finds-match]
+ssl_conf = 1-alpn-server-finds-match-ssl
+
+[1-alpn-server-finds-match-ssl]
+server = 1-alpn-server-finds-match-server
+client = 1-alpn-server-finds-match-client
+
+[1-alpn-server-finds-match-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[1-alpn-server-finds-match-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-1]
+ExpectedALPNProtocol = bar
+ExpectedProtocol = NTLS
+Method = NTLS
+server = 1-alpn-server-finds-match-server-extra
+client = 1-alpn-server-finds-match-client-extra
+
+[1-alpn-server-finds-match-server-extra]
+ALPNProtocols = baz,bar
+
+[1-alpn-server-finds-match-client-extra]
+ALPNProtocols = foo,bar
+
+
+# ===========================================================
+
+[2-alpn-server-honours-server-pref]
+ssl_conf = 2-alpn-server-honours-server-pref-ssl
+
+[2-alpn-server-honours-server-pref-ssl]
+server = 2-alpn-server-honours-server-pref-server
+client = 2-alpn-server-honours-server-pref-client
+
+[2-alpn-server-honours-server-pref-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[2-alpn-server-honours-server-pref-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-2]
+ExpectedALPNProtocol = bar
+ExpectedProtocol = NTLS
+Method = NTLS
+server = 2-alpn-server-honours-server-pref-server-extra
+client = 2-alpn-server-honours-server-pref-client-extra
+
+[2-alpn-server-honours-server-pref-server-extra]
+ALPNProtocols = bar,foo
+
+[2-alpn-server-honours-server-pref-client-extra]
+ALPNProtocols = foo,bar
+
+
+# ===========================================================
+
+[3-alpn-alert-on-mismatch]
+ssl_conf = 3-alpn-alert-on-mismatch-ssl
+
+[3-alpn-alert-on-mismatch-ssl]
+server = 3-alpn-alert-on-mismatch-server
+client = 3-alpn-alert-on-mismatch-client
+
+[3-alpn-alert-on-mismatch-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[3-alpn-alert-on-mismatch-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-3]
+ExpectedResult = ServerFail
+ExpectedServerAlert = NoApplicationProtocol
+Method = NTLS
+server = 3-alpn-alert-on-mismatch-server-extra
+client = 3-alpn-alert-on-mismatch-client-extra
+
+[3-alpn-alert-on-mismatch-server-extra]
+ALPNProtocols = baz
+
+[3-alpn-alert-on-mismatch-client-extra]
+ALPNProtocols = foo,bar
+
+
+# ===========================================================
+
+[4-alpn-no-server-support]
+ssl_conf = 4-alpn-no-server-support-ssl
+
+[4-alpn-no-server-support-ssl]
+server = 4-alpn-no-server-support-server
+client = 4-alpn-no-server-support-client
+
+[4-alpn-no-server-support-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[4-alpn-no-server-support-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-4]
+ExpectedProtocol = NTLS
+Method = NTLS
+client = 4-alpn-no-server-support-client-extra
+
+[4-alpn-no-server-support-client-extra]
+ALPNProtocols = foo
+
+
+# ===========================================================
+
+[5-alpn-no-client-support]
+ssl_conf = 5-alpn-no-client-support-ssl
+
+[5-alpn-no-client-support-ssl]
+server = 5-alpn-no-client-support-server
+client = 5-alpn-no-client-support-client
+
+[5-alpn-no-client-support-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[5-alpn-no-client-support-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-5]
+ExpectedProtocol = NTLS
+Method = NTLS
+server = 5-alpn-no-client-support-server-extra
+
+[5-alpn-no-client-support-server-extra]
+ALPNProtocols = foo
+
+
+# ===========================================================
+
+[6-alpn-with-sni-no-context-switch]
+ssl_conf = 6-alpn-with-sni-no-context-switch-ssl
+
+[6-alpn-with-sni-no-context-switch-ssl]
+server = 6-alpn-with-sni-no-context-switch-server
+client = 6-alpn-with-sni-no-context-switch-client
+server2 = 6-alpn-with-sni-no-context-switch-server2
+
+[6-alpn-with-sni-no-context-switch-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[6-alpn-with-sni-no-context-switch-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[6-alpn-with-sni-no-context-switch-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-6]
+ExpectedALPNProtocol = foo
+ExpectedProtocol = NTLS
+ExpectedServerName = server1
+Method = NTLS
+server = 6-alpn-with-sni-no-context-switch-server-extra
+server2 = 6-alpn-with-sni-no-context-switch-server2-extra
+client = 6-alpn-with-sni-no-context-switch-client-extra
+
+[6-alpn-with-sni-no-context-switch-server-extra]
+ALPNProtocols = foo
+ServerNameCallback = IgnoreMismatch
+
+[6-alpn-with-sni-no-context-switch-server2-extra]
+ALPNProtocols = bar
+
+[6-alpn-with-sni-no-context-switch-client-extra]
+ALPNProtocols = foo,bar
+ServerName = server1
+
+
+# ===========================================================
+
+[7-alpn-with-sni-context-switch]
+ssl_conf = 7-alpn-with-sni-context-switch-ssl
+
+[7-alpn-with-sni-context-switch-ssl]
+server = 7-alpn-with-sni-context-switch-server
+client = 7-alpn-with-sni-context-switch-client
+server2 = 7-alpn-with-sni-context-switch-server2
+
+[7-alpn-with-sni-context-switch-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[7-alpn-with-sni-context-switch-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[7-alpn-with-sni-context-switch-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-7]
+ExpectedALPNProtocol = bar
+ExpectedProtocol = NTLS
+ExpectedServerName = server2
+Method = NTLS
+server = 7-alpn-with-sni-context-switch-server-extra
+server2 = 7-alpn-with-sni-context-switch-server2-extra
+client = 7-alpn-with-sni-context-switch-client-extra
+
+[7-alpn-with-sni-context-switch-server-extra]
+ALPNProtocols = foo
+ServerNameCallback = IgnoreMismatch
+
+[7-alpn-with-sni-context-switch-server2-extra]
+ALPNProtocols = bar
+
+[7-alpn-with-sni-context-switch-client-extra]
+ALPNProtocols = foo,bar
+ServerName = server2
+
+
+# ===========================================================
+
+[8-alpn-selected-sni-server-supports-alpn]
+ssl_conf = 8-alpn-selected-sni-server-supports-alpn-ssl
+
+[8-alpn-selected-sni-server-supports-alpn-ssl]
+server = 8-alpn-selected-sni-server-supports-alpn-server
+client = 8-alpn-selected-sni-server-supports-alpn-client
+server2 = 8-alpn-selected-sni-server-supports-alpn-server2
+
+[8-alpn-selected-sni-server-supports-alpn-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[8-alpn-selected-sni-server-supports-alpn-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[8-alpn-selected-sni-server-supports-alpn-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-8]
+ExpectedALPNProtocol = bar
+ExpectedProtocol = NTLS
+ExpectedServerName = server2
+Method = NTLS
+server = 8-alpn-selected-sni-server-supports-alpn-server-extra
+server2 = 8-alpn-selected-sni-server-supports-alpn-server2-extra
+client = 8-alpn-selected-sni-server-supports-alpn-client-extra
+
+[8-alpn-selected-sni-server-supports-alpn-server-extra]
+ServerNameCallback = IgnoreMismatch
+
+[8-alpn-selected-sni-server-supports-alpn-server2-extra]
+ALPNProtocols = bar
+
+[8-alpn-selected-sni-server-supports-alpn-client-extra]
+ALPNProtocols = foo,bar
+ServerName = server2
+
+
+# ===========================================================
+
+[9-alpn-selected-sni-server-does-not-support-alpn]
+ssl_conf = 9-alpn-selected-sni-server-does-not-support-alpn-ssl
+
+[9-alpn-selected-sni-server-does-not-support-alpn-ssl]
+server = 9-alpn-selected-sni-server-does-not-support-alpn-server
+client = 9-alpn-selected-sni-server-does-not-support-alpn-client
+server2 = 9-alpn-selected-sni-server-does-not-support-alpn-server2
+
+[9-alpn-selected-sni-server-does-not-support-alpn-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[9-alpn-selected-sni-server-does-not-support-alpn-server2]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[9-alpn-selected-sni-server-does-not-support-alpn-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-9]
+ExpectedProtocol = NTLS
+ExpectedServerName = server2
+Method = NTLS
+server = 9-alpn-selected-sni-server-does-not-support-alpn-server-extra
+client = 9-alpn-selected-sni-server-does-not-support-alpn-client-extra
+
+[9-alpn-selected-sni-server-does-not-support-alpn-server-extra]
+ALPNProtocols = bar
+ServerNameCallback = IgnoreMismatch
+
+[9-alpn-selected-sni-server-does-not-support-alpn-client-extra]
+ALPNProtocols = foo,bar
+ServerName = server2
+
+
+# ===========================================================
+
+[10-alpn-simple-resumption]
+ssl_conf = 10-alpn-simple-resumption-ssl
+
+[10-alpn-simple-resumption-ssl]
+server = 10-alpn-simple-resumption-server
+client = 10-alpn-simple-resumption-client
+resume-server = 10-alpn-simple-resumption-server
+resume-client = 10-alpn-simple-resumption-client
+
+[10-alpn-simple-resumption-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[10-alpn-simple-resumption-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-10]
+ExpectedALPNProtocol = foo
+ExpectedProtocol = NTLS
+HandshakeMode = Resume
+Method = NTLS
+ResumptionExpected = Yes
+server = 10-alpn-simple-resumption-server-extra
+resume-server = 10-alpn-simple-resumption-server-extra
+client = 10-alpn-simple-resumption-client-extra
+resume-client = 10-alpn-simple-resumption-client-extra
+
+[10-alpn-simple-resumption-server-extra]
+ALPNProtocols = foo
+
+[10-alpn-simple-resumption-client-extra]
+ALPNProtocols = foo
+
+
+# ===========================================================
+
+[11-alpn-server-switch-resumption]
+ssl_conf = 11-alpn-server-switch-resumption-ssl
+
+[11-alpn-server-switch-resumption-ssl]
+server = 11-alpn-server-switch-resumption-server
+client = 11-alpn-server-switch-resumption-client
+resume-server = 11-alpn-server-switch-resumption-resume-server
+resume-client = 11-alpn-server-switch-resumption-client
+
+[11-alpn-server-switch-resumption-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[11-alpn-server-switch-resumption-resume-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[11-alpn-server-switch-resumption-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-11]
+ExpectedALPNProtocol = baz
+ExpectedProtocol = NTLS
+HandshakeMode = Resume
+Method = NTLS
+ResumptionExpected = Yes
+server = 11-alpn-server-switch-resumption-server-extra
+resume-server = 11-alpn-server-switch-resumption-resume-server-extra
+client = 11-alpn-server-switch-resumption-client-extra
+resume-client = 11-alpn-server-switch-resumption-client-extra
+
+[11-alpn-server-switch-resumption-server-extra]
+ALPNProtocols = bar,foo
+
+[11-alpn-server-switch-resumption-resume-server-extra]
+ALPNProtocols = baz,foo
+
+[11-alpn-server-switch-resumption-client-extra]
+ALPNProtocols = foo,bar,baz
+
+
+# ===========================================================
+
+[12-alpn-client-switch-resumption]
+ssl_conf = 12-alpn-client-switch-resumption-ssl
+
+[12-alpn-client-switch-resumption-ssl]
+server = 12-alpn-client-switch-resumption-server
+client = 12-alpn-client-switch-resumption-client
+resume-server = 12-alpn-client-switch-resumption-server
+resume-client = 12-alpn-client-switch-resumption-resume-client
+
+[12-alpn-client-switch-resumption-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[12-alpn-client-switch-resumption-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[12-alpn-client-switch-resumption-resume-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-12]
+ExpectedALPNProtocol = bar
+ExpectedProtocol = NTLS
+HandshakeMode = Resume
+Method = NTLS
+ResumptionExpected = Yes
+server = 12-alpn-client-switch-resumption-server-extra
+resume-server = 12-alpn-client-switch-resumption-server-extra
+client = 12-alpn-client-switch-resumption-client-extra
+resume-client = 12-alpn-client-switch-resumption-resume-client-extra
+
+[12-alpn-client-switch-resumption-server-extra]
+ALPNProtocols = foo,bar,baz
+
+[12-alpn-client-switch-resumption-client-extra]
+ALPNProtocols = foo,baz
+
+[12-alpn-client-switch-resumption-resume-client-extra]
+ALPNProtocols = bar,baz
+
+
+# ===========================================================
+
+[13-alpn-alert-on-mismatch-resumption]
+ssl_conf = 13-alpn-alert-on-mismatch-resumption-ssl
+
+[13-alpn-alert-on-mismatch-resumption-ssl]
+server = 13-alpn-alert-on-mismatch-resumption-server
+client = 13-alpn-alert-on-mismatch-resumption-client
+resume-server = 13-alpn-alert-on-mismatch-resumption-resume-server
+resume-client = 13-alpn-alert-on-mismatch-resumption-client
+
+[13-alpn-alert-on-mismatch-resumption-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[13-alpn-alert-on-mismatch-resumption-resume-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[13-alpn-alert-on-mismatch-resumption-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-13]
+ExpectedProtocol = NTLS
+ExpectedResult = ServerFail
+ExpectedServerAlert = NoApplicationProtocol
+HandshakeMode = Resume
+Method = NTLS
+server = 13-alpn-alert-on-mismatch-resumption-server-extra
+resume-server = 13-alpn-alert-on-mismatch-resumption-resume-server-extra
+client = 13-alpn-alert-on-mismatch-resumption-client-extra
+resume-client = 13-alpn-alert-on-mismatch-resumption-client-extra
+
+[13-alpn-alert-on-mismatch-resumption-server-extra]
+ALPNProtocols = bar
+
+[13-alpn-alert-on-mismatch-resumption-resume-server-extra]
+ALPNProtocols = baz
+
+[13-alpn-alert-on-mismatch-resumption-client-extra]
+ALPNProtocols = foo,bar
+
+
+# ===========================================================
+
+[14-alpn-no-server-support-resumption]
+ssl_conf = 14-alpn-no-server-support-resumption-ssl
+
+[14-alpn-no-server-support-resumption-ssl]
+server = 14-alpn-no-server-support-resumption-server
+client = 14-alpn-no-server-support-resumption-client
+resume-server = 14-alpn-no-server-support-resumption-resume-server
+resume-client = 14-alpn-no-server-support-resumption-client
+
+[14-alpn-no-server-support-resumption-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[14-alpn-no-server-support-resumption-resume-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[14-alpn-no-server-support-resumption-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-14]
+ExpectedProtocol = NTLS
+HandshakeMode = Resume
+Method = NTLS
+ResumptionExpected = Yes
+server = 14-alpn-no-server-support-resumption-server-extra
+client = 14-alpn-no-server-support-resumption-client-extra
+resume-client = 14-alpn-no-server-support-resumption-client-extra
+
+[14-alpn-no-server-support-resumption-server-extra]
+ALPNProtocols = foo
+
+[14-alpn-no-server-support-resumption-client-extra]
+ALPNProtocols = foo
+
+
+# ===========================================================
+
+[15-alpn-no-client-support-resumption]
+ssl_conf = 15-alpn-no-client-support-resumption-ssl
+
+[15-alpn-no-client-support-resumption-ssl]
+server = 15-alpn-no-client-support-resumption-server
+client = 15-alpn-no-client-support-resumption-client
+resume-server = 15-alpn-no-client-support-resumption-server
+resume-client = 15-alpn-no-client-support-resumption-resume-client
+
+[15-alpn-no-client-support-resumption-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Enable_ntls = on
+EncCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.crt
+EncPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_enc.key
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+SignCertificate = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.crt
+SignPrivateKey = ${ENV::TEST_CERTS_DIR}/sm2/server_sign.key
+
+[15-alpn-no-client-support-resumption-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[15-alpn-no-client-support-resumption-resume-client]
+CipherString = DEFAULT
+Enable_ntls = on
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/sm2/chain-ca.crt
+VerifyMode = Peer
+
+[test-15]
+ExpectedProtocol = NTLS
+HandshakeMode = Resume
+Method = NTLS
+ResumptionExpected = Yes
+server = 15-alpn-no-client-support-resumption-server-extra
+resume-server = 15-alpn-no-client-support-resumption-server-extra
+client = 15-alpn-no-client-support-resumption-client-extra
+
+[15-alpn-no-client-support-resumption-server-extra]
+ALPNProtocols = foo
+
+[15-alpn-no-client-support-resumption-client-extra]
+ALPNProtocols = foo
+
+
Index: b/test/ssl-tests/41-ntls-alpn.cnf.in
===================================================================
--- /dev/null
+++ b/test/ssl-tests/41-ntls-alpn.cnf.in
@@ -0,0 +1,510 @@
+# -*- mode: perl; -*-
+# Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+
+## Test NTLS ALPN
+
+use strict;
+use warnings;
+
+package ssltests;
+use OpenSSL::Test::Utils;
+
+our @tests = (
+    {
+        name => "alpn-simple",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedALPNProtocol" => "foo",
+        },
+    },
+    {
+        name => "alpn-server-finds-match",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "baz,bar",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedALPNProtocol" => "bar",
+        },
+    },
+    {
+        name => "alpn-server-honours-server-pref",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar,foo",
+            },
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedALPNProtocol" => "bar",
+        },
+    },
+    {
+        name => "alpn-alert-on-mismatch",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "baz",
+            },
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "NoApplicationProtocol",
+        },
+    },
+    {
+        name => "alpn-no-server-support",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedALPNProtocol" => undef,
+        },
+    },
+    {
+        name => "alpn-no-client-support",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedALPNProtocol" => undef,
+        },
+    },
+    {
+        name => "alpn-with-sni-no-context-switch",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+                "ServerNameCallback" => "IgnoreMismatch",
+            },
+        },
+        server2 => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar",
+            },
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+                "ServerName" => "server1",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedServerName" => "server1",
+            "ExpectedALPNProtocol" => "foo",
+        },
+    },
+    {
+        name => "alpn-with-sni-context-switch",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+                "ServerNameCallback" => "IgnoreMismatch",
+            },
+        },
+        server2 => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar",
+            },
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+                "ServerName" => "server2",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedServerName" => "server2",
+            "ExpectedALPNProtocol" => "bar",
+        },
+    },
+    {
+        name => "alpn-selected-sni-server-supports-alpn",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+               "ServerNameCallback" => "IgnoreMismatch",
+            },
+        },
+        server2 => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar",
+            },
+        },
+        client => {
+           "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+           "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+                "ServerName" => "server2",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedServerName" => "server2",
+            "ExpectedALPNProtocol" => "bar",
+        },
+    },
+    {
+        name => "alpn-selected-sni-server-does-not-support-alpn",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar",
+                "ServerNameCallback" => "IgnoreMismatch",
+            },
+        },
+        server2 => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+                "ServerName" => "server2",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "ExpectedServerName" => "server2",
+            "ExpectedALPNProtocol" => undef,
+        },
+    },
+    {
+        name => "alpn-simple-resumption",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "HandshakeMode" => "Resume",
+            "ResumptionExpected" => "Yes",
+            "ExpectedALPNProtocol" => "foo",
+        },
+    },
+    {
+        name => "alpn-server-switch-resumption",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar,foo",
+            },
+        },
+        resume_server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "baz,foo",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar,baz",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "HandshakeMode" => "Resume",
+            "ResumptionExpected" => "Yes",
+            "ExpectedALPNProtocol" => "baz",
+        },
+    },
+    {
+        name => "alpn-client-switch-resumption",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar,baz",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,baz",
+            },
+        },
+        resume_client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar,baz",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "HandshakeMode" => "Resume",
+            "ResumptionExpected" => "Yes",
+            "ExpectedALPNProtocol" => "bar",
+        },
+    },
+    {
+        name => "alpn-alert-on-mismatch-resumption",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "bar",
+            },
+        },
+        resume_server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "baz",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo,bar",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "HandshakeMode" => "Resume",
+            "ExpectedResult" => "ServerFail",
+            "ExpectedServerAlert" => "NoApplicationProtocol",
+        },
+    },
+    {
+        name => "alpn-no-server-support-resumption",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        resume_server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "HandshakeMode" => "Resume",
+            "ResumptionExpected" => "Yes",
+            "ExpectedALPNProtocol" => undef,
+        },
+    },
+    {
+        name => "alpn-no-client-support-resumption",
+        server => {
+            "SignCertificate" => test_pem("sm2", "server_sign.crt"),
+            "SignPrivateKey" => test_pem("sm2", "server_sign.key"),
+            "EncCertificate" => test_pem("sm2", "server_enc.crt"),
+            "EncPrivateKey" => test_pem("sm2", "server_enc.key"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+            extra => {
+                "ALPNProtocols" => "foo",
+            },
+        },
+        resume_client => {
+            "VerifyCAFile" => test_pem("sm2", "chain-ca.crt"),
+            "Enable_ntls" => "on",
+        },
+        test => {
+            "Method" => "NTLS",
+            "ExpectedProtocol" => "NTLS",
+            "HandshakeMode" => "Resume",
+            "ResumptionExpected" => "Yes",
+            "ExpectedALPNProtocol" => undef,
+        },
+    },
+);
Index: b/test/ssl-tests/ssltests_base.pm
===================================================================
--- a/test/ssl-tests/ssltests_base.pm
+++ b/test/ssl-tests/ssltests_base.pm
@@ -1,5 +1,5 @@
 # -*- mode: perl; -*-
-# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the Apache License 2.0 (the "License").  You may not use
 # this file except in compliance with the License.  You can obtain a copy
@@ -12,13 +12,15 @@ package ssltests;
 
 sub test_pem
 {
-    my ($file) = @_;
     my $dir_sep = $^O ne "VMS" ? "/" : "";
-    return "\${ENV::TEST_CERTS_DIR}" . $dir_sep . $file,
-}
+    my $ret = "\${ENV::TEST_CERTS_DIR}";
+
+    foreach (@_) {
+        $ret = $ret . $dir_sep . $_;
+    }
 
-our $fips_mode = 0;
-our $no_deflt_libctx = 0;
+    return $ret;
+}
 
 our %base_server = (
     "Certificate" => test_pem("servercert.pem"),
Index: b/test/ssl_cert_table_internal_test.c
===================================================================
--- a/test/ssl_cert_table_internal_test.c
+++ b/test/ssl_cert_table_internal_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2017-2022 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -55,7 +55,15 @@ static int test_ssl_cert_table(void)
            && test_cert_table(NID_id_GostR3410_2012_512, SSL_aGOST12,
                               SSL_PKEY_GOST12_512)
            && test_cert_table(EVP_PKEY_ED25519, SSL_aECDSA, SSL_PKEY_ED25519)
-           && test_cert_table(EVP_PKEY_ED448, SSL_aECDSA, SSL_PKEY_ED448);
+           && test_cert_table(EVP_PKEY_ED448, SSL_aECDSA, SSL_PKEY_ED448)
+           && test_cert_table(EVP_PKEY_SM2, SSL_aSM2, SSL_PKEY_SM2)
+#ifndef OPENSSL_NO_NTLS
+           && test_cert_table(EVP_PKEY_SM2, SSL_aSM2, SSL_PKEY_SM2_SIGN)
+           && test_cert_table(EVP_PKEY_SM2, SSL_aSM2, SSL_PKEY_SM2_ENC)
+           && test_cert_table(EVP_PKEY_RSA, SSL_aRSA, SSL_PKEY_RSA_SIGN)
+           && test_cert_table(EVP_PKEY_RSA, SSL_aRSA, SSL_PKEY_RSA_ENC)
+#endif
+           ;
 }
 
 int setup_tests(void)
Index: b/test/ssl_ntls_api_test.c
===================================================================
--- /dev/null
+++ b/test/ssl_ntls_api_test.c
@@ -0,0 +1,623 @@
+/*
+ * Copyright 2022 The Tongsuo Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://github.com/Tongsuo-Project/Tongsuo/blob/master/LICENSE.txt
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <openssl/ssl.h>
+#include "testutil.h"
+#include "internal/nelem.h"
+#include "../ssl/ssl_local.h"
+
+static const char *sm2_sign_cert_file;
+static const char *sm2_sign_key_file;
+static const char *sm2_enc_cert_file;
+static const char *sm2_enc_key_file;
+static const char *rsa_sign_cert_file;
+static const char *rsa_sign_key_file;
+static const char *rsa_enc_cert_file;
+static const char *rsa_enc_key_file;
+
+static const char *cipher_list[] = {
+#ifndef OPENSSL_NO_SM4
+# ifndef OPENSSL_NO_SM3
+#  ifndef OPENSSL_NO_SM2
+    NTLS_TXT_SM2DHE_WITH_SM4_SM3,
+    NTLS_TXT_SM2_WITH_SM4_SM3,
+    NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3,
+    NTLS_TXT_ECDHE_SM2_SM4_GCM_SM3,
+    NTLS_TXT_ECC_SM2_SM4_CBC_SM3,
+    NTLS_TXT_ECC_SM2_SM4_GCM_SM3,
+    NTLS_TXT_SM2DHE_WITH_SM4_SM3":"NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3,
+    NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3":"NTLS_TXT_ECDHE_SM2_SM4_GCM_SM3,
+    NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3":"NTLS_TXT_ECC_SM2_SM4_CBC_SM3,
+    NTLS_TXT_ECDHE_SM2_SM4_CBC_SM3":"NTLS_TXT_RSA_SM4_CBC_SM3,
+#  endif /* OPENSSL_NO_SM2 */
+    NTLS_TXT_RSA_SM4_CBC_SM3,
+    NTLS_TXT_RSA_SM4_GCM_SM3,
+# endif /* OPENSSL_NO_SM3 */
+    NTLS_TXT_RSA_SM4_CBC_SHA256,
+    NTLS_TXT_RSA_SM4_GCM_SHA256,
+#endif /* OPENSSL_NO_SM4 */
+    NULL,   /* suppress compile error: zero or negative size array */
+};
+
+static int test_ntls_ctx_set_cipher_list(int i)
+{
+    int           ret = 1;
+    SSL_CTX      *ctx = NULL;
+
+    ret = 0;
+    ctx = SSL_CTX_new(NTLS_client_method());
+    if (!TEST_true(ctx != NULL))
+        goto err;
+
+    SSL_CTX_enable_ntls(ctx);
+    if (!TEST_true(ctx->enable_ntls == 1))
+        goto err;
+
+    if (!TEST_true(SSL_CTX_set_cipher_list(ctx, cipher_list[i]))) {
+        goto err;
+    }
+
+    ret = 1;
+err:
+    SSL_CTX_free(ctx);
+    return ret;
+}
+
+static int test_ntls_ssl_set_cipher_list(int i)
+{
+    int           ret = 1;
+    SSL_CTX      *ctx = NULL;
+    SSL          *ssl = NULL;
+
+    ret = 0;
+    ctx = SSL_CTX_new(NTLS_client_method());
+    if (!TEST_true(ctx != NULL))
+        goto err;
+
+    SSL_CTX_enable_ntls(ctx);
+    if (!TEST_true(ctx->enable_ntls == 1))
+        goto err;
+
+
+    ssl = SSL_new(ctx);
+    if (!TEST_true(ssl != NULL))
+        goto err;
+
+    if (!TEST_true(SSL_CTX_set_cipher_list(ctx, cipher_list[i]))) {
+        goto err;
+    }
+
+    ret = 1;
+err:
+    SSL_CTX_free(ctx);
+    SSL_free(ssl);
+    return ret;
+}
+
+static int test_ntls_ctx_set_cert_pkey_file_api(int i)
+{
+    int ret = 1;
+    const char *sign_cert_file = NULL;
+    const char *sign_key_file = NULL;
+    const char *enc_cert_file = NULL;
+    const char *enc_key_file = NULL;
+    SSL_CTX *ctx = NULL;
+
+    if (i == 0) {
+# ifndef OPENSSL_NO_SM2
+        sign_cert_file = sm2_sign_cert_file;
+        sign_key_file = sm2_sign_key_file;
+        enc_cert_file = sm2_enc_cert_file;
+        enc_key_file = sm2_enc_key_file;
+# endif
+    } else {
+        sign_cert_file = rsa_sign_cert_file;
+        sign_key_file = rsa_sign_key_file;
+        enc_cert_file = rsa_enc_cert_file;
+        enc_key_file = rsa_enc_key_file;
+    }
+
+    if (sign_cert_file == NULL || sign_key_file == NULL
+        || enc_cert_file == NULL || enc_key_file == NULL)
+        return 1;
+
+    ret = 0;
+    ctx = SSL_CTX_new(NTLS_method());
+    if (!TEST_true(ctx != NULL))
+        goto err;
+
+    SSL_CTX_enable_ntls(ctx);
+    if (!TEST_true(ctx->enable_ntls == 1))
+        goto err;
+    SSL_CTX_disable_ntls(ctx);
+    if (!TEST_true(ctx->enable_ntls == 0))
+        goto err;
+
+    if (!TEST_int_eq(SSL_CTX_use_sign_certificate_file(ctx,
+                                                       sign_cert_file,
+                                                       SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_SIGN].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_SIGN].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_CTX_use_sign_PrivateKey_file(ctx,
+                                                      sign_key_file,
+                                                      SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_SIGN].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_CTX_use_enc_certificate_file(ctx,
+                                                      enc_cert_file,
+                                                      SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_ENC].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_ENC].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_CTX_use_enc_PrivateKey_file(ctx,
+                                                     enc_key_file,
+                                                     SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_ENC].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL))
+            goto err;
+    }
+
+    ret = 1;
+err:
+    SSL_CTX_free(ctx);
+    return ret;
+}
+
+static int test_ntls_ssl_set_cert_pkey_file_api(int i)
+{
+    int           ret = 1;
+    const char   *sign_cert_file = NULL;
+    const char   *sign_key_file = NULL;
+    const char   *enc_cert_file = NULL;
+    const char   *enc_key_file = NULL;
+    SSL_CTX      *ctx = NULL;
+    SSL          *ssl = NULL;
+
+    if (i == 0) {
+# ifndef OPENSSL_NO_SM2
+        sign_cert_file = sm2_sign_cert_file;
+        sign_key_file = sm2_sign_key_file;
+        enc_cert_file = sm2_enc_cert_file;
+        enc_key_file = sm2_enc_key_file;
+# endif
+    } else {
+        sign_cert_file = rsa_sign_cert_file;
+        sign_key_file = rsa_sign_key_file;
+        enc_cert_file = rsa_enc_cert_file;
+        enc_key_file = rsa_enc_key_file;
+    }
+
+    if (sign_cert_file == NULL || sign_key_file == NULL
+        || enc_cert_file == NULL || enc_key_file == NULL)
+        return 1;
+
+    ret = 0;
+    ctx = SSL_CTX_new(NTLS_method());
+    if (!TEST_true(ctx != NULL))
+        goto err;
+
+    ssl = SSL_new(ctx);
+    if (!TEST_true(ssl != NULL))
+        goto err;
+
+    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL_ONLY(ssl);
+    if (!TEST_true(SSL_is_ntls(ssl) == 1))
+        goto err;
+
+    SSL_enable_ntls(ssl);
+    if (!TEST_true(sc->enable_ntls == 1))
+        goto err;
+    SSL_disable_ntls(ssl);
+    if (!TEST_true(sc->enable_ntls == 0))
+        goto err;
+
+    if (!TEST_int_eq(SSL_use_sign_certificate_file(ssl,
+                                                   sign_cert_file,
+                                                   SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_SIGN].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_SIGN].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_use_sign_PrivateKey_file(ssl,
+                                                  sign_key_file,
+                                                  SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_SIGN].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_use_enc_certificate_file(ssl,
+                                                  enc_cert_file,
+                                                  SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_ENC].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_ENC].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_use_enc_PrivateKey_file(ssl,
+                                                 enc_key_file,
+                                                 SSL_FILETYPE_PEM), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_ENC].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL))
+            goto err;
+    }
+
+    ret = 1;
+err:
+    SSL_CTX_free(ctx);
+    SSL_free(ssl);
+    return ret;
+}
+
+static int test_ntls_ctx_set_cert_pkey_api(int i)
+{
+    int           ret = 1;
+    SSL_CTX      *ctx = NULL;
+    X509         *sign_cert = NULL;
+    EVP_PKEY     *sign_pkey = NULL;
+    X509         *enc_cert = NULL;
+    EVP_PKEY     *enc_pkey = NULL;
+    BIO          *sign_cert_bio = NULL;
+    BIO          *sign_pkey_bio = NULL;
+    BIO          *enc_cert_bio = NULL;
+    BIO          *enc_pkey_bio = NULL;
+    const char   *sign_cert_file = NULL;
+    const char   *sign_key_file = NULL;
+    const char   *enc_cert_file = NULL;
+    const char   *enc_key_file = NULL;
+
+    if (i == 0) {
+# ifndef OPENSSL_NO_SM2
+        sign_cert_file = sm2_sign_cert_file;
+        sign_key_file = sm2_sign_key_file;
+        enc_cert_file = sm2_enc_cert_file;
+        enc_key_file = sm2_enc_key_file;
+# endif
+    } else {
+        sign_cert_file = rsa_sign_cert_file;
+        sign_key_file = rsa_sign_key_file;
+        enc_cert_file = rsa_enc_cert_file;
+        enc_key_file = rsa_enc_key_file;
+    }
+
+    if (sign_cert_file == NULL || sign_key_file == NULL
+        || enc_cert_file == NULL || enc_key_file == NULL)
+        return 1;
+
+    ret = 0;
+    sign_cert_bio = BIO_new(BIO_s_file());
+    enc_cert_bio = BIO_new(BIO_s_file());
+    if (!TEST_ptr(sign_cert_bio) || !TEST_ptr(enc_cert_bio))
+        goto err;
+
+    if (!TEST_int_eq(BIO_read_filename(sign_cert_bio, sign_cert_file), 1)
+        || !TEST_int_eq(BIO_read_filename(enc_cert_bio, enc_cert_file), 1))
+        goto err;
+
+    sign_cert = PEM_read_bio_X509(sign_cert_bio, NULL, NULL, NULL);
+    enc_cert = PEM_read_bio_X509(enc_cert_bio, NULL, NULL, NULL);
+    if (!TEST_ptr(sign_cert) || !TEST_ptr(enc_cert))
+        goto err;
+
+    sign_pkey_bio = BIO_new(BIO_s_file());
+    enc_pkey_bio = BIO_new(BIO_s_file());
+    if (!TEST_ptr(sign_pkey_bio) || !TEST_ptr(enc_pkey_bio))
+        goto err;
+
+    if (!TEST_int_eq(BIO_read_filename(sign_pkey_bio, sign_key_file), 1)
+        || !TEST_int_eq(BIO_read_filename(enc_pkey_bio, enc_key_file), 1))
+        goto err;
+
+    sign_pkey = PEM_read_bio_PrivateKey(sign_pkey_bio, NULL, NULL, NULL);
+    enc_pkey = PEM_read_bio_PrivateKey(enc_pkey_bio, NULL, NULL, NULL);
+    if (!TEST_ptr(sign_pkey) || !TEST_ptr(enc_pkey))
+        goto err;
+
+
+    ctx = SSL_CTX_new(NTLS_method());
+    if (!TEST_true(ctx != NULL))
+        goto err;
+
+
+    if (!TEST_int_eq(SSL_CTX_use_sign_certificate(ctx, sign_cert), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_SIGN].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_SIGN].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_CTX_use_sign_PrivateKey(ctx, sign_pkey), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_SIGN].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_CTX_use_enc_certificate(ctx, enc_cert), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_ENC].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_ENC].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_CTX_use_enc_PrivateKey(ctx, enc_pkey), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_SM2_ENC].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(ctx->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL))
+            goto err;
+    }
+
+    ret = 1;
+err:
+    BIO_free(sign_cert_bio);
+    BIO_free(enc_cert_bio);
+    BIO_free(sign_pkey_bio);
+    BIO_free(enc_pkey_bio);
+    X509_free(sign_cert);
+    X509_free(enc_cert);
+    EVP_PKEY_free(sign_pkey);
+    EVP_PKEY_free(enc_pkey);
+    SSL_CTX_free(ctx);
+    return ret;
+}
+
+static int test_ntls_ssl_set_cert_pkey_api(int i)
+{
+    int           ret = 1;
+    const char   *sign_cert_file = NULL;
+    const char   *sign_key_file = NULL;
+    const char   *enc_cert_file = NULL;
+    const char   *enc_key_file = NULL;
+    SSL_CTX      *ctx = NULL;
+    SSL          *ssl = NULL;
+    X509         *sign_cert = NULL;
+    EVP_PKEY     *sign_pkey = NULL;
+    X509         *enc_cert = NULL;
+    EVP_PKEY     *enc_pkey = NULL;
+    BIO          *sign_cert_bio = NULL;
+    BIO          *sign_pkey_bio = NULL;
+    BIO          *enc_cert_bio = NULL;
+    BIO          *enc_pkey_bio = NULL;
+
+    if (i == 0) {
+# ifndef OPENSSL_NO_SM2
+        sign_cert_file = sm2_sign_cert_file;
+        sign_key_file = sm2_sign_key_file;
+        enc_cert_file = sm2_enc_cert_file;
+        enc_key_file = sm2_enc_key_file;
+# endif
+    } else {
+        sign_cert_file = rsa_sign_cert_file;
+        sign_key_file = rsa_sign_key_file;
+        enc_cert_file = rsa_enc_cert_file;
+        enc_key_file = rsa_enc_key_file;
+    }
+
+    if (sign_cert_file == NULL || sign_key_file == NULL
+        || enc_cert_file == NULL || enc_key_file == NULL)
+        return 1;
+
+    ret = 0;
+    sign_cert_bio = BIO_new(BIO_s_file());
+    enc_cert_bio = BIO_new(BIO_s_file());
+    if (!TEST_ptr(sign_cert_bio) || !TEST_ptr(enc_cert_bio))
+        goto err;
+    if (!TEST_int_eq(BIO_read_filename(sign_cert_bio, sign_cert_file), 1)
+        || !TEST_int_eq(BIO_read_filename(enc_cert_bio, enc_cert_file), 1))
+        goto err;
+    sign_cert = PEM_read_bio_X509(sign_cert_bio, NULL, NULL, NULL);
+    enc_cert = PEM_read_bio_X509(enc_cert_bio, NULL, NULL, NULL);
+    if (!TEST_ptr(sign_cert) || !TEST_ptr(enc_cert))
+        goto err;
+
+    sign_pkey_bio = BIO_new(BIO_s_file());
+    enc_pkey_bio = BIO_new(BIO_s_file());
+    if (!TEST_ptr(sign_pkey_bio) || !TEST_ptr(enc_pkey_bio))
+        goto err;
+    if (!TEST_int_eq(BIO_read_filename(sign_pkey_bio, sign_key_file), 1)
+        || !TEST_int_eq(BIO_read_filename(enc_pkey_bio, enc_key_file), 1))
+        goto err;
+    sign_pkey = PEM_read_bio_PrivateKey(sign_pkey_bio, NULL, NULL, NULL);
+    enc_pkey = PEM_read_bio_PrivateKey(enc_pkey_bio, NULL, NULL, NULL);
+    if (!TEST_ptr(sign_pkey) || !TEST_ptr(enc_pkey))
+        goto err;
+
+    ctx = SSL_CTX_new(NTLS_method());
+    if (!TEST_true(ctx != NULL))
+        goto err;
+    ssl = SSL_new(ctx);
+    if (!TEST_true(ssl != NULL))
+        goto err;
+
+    const SSL_CONNECTION *sc = SSL_CONNECTION_FROM_CONST_SSL_ONLY(ssl);
+    if (!TEST_int_eq(SSL_use_sign_certificate(ssl, sign_cert), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_SIGN].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_SIGN].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_use_sign_PrivateKey(ssl, sign_pkey), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_SIGN].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_use_enc_certificate(ssl, enc_cert), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_ENC].x509 != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_ENC].x509 != NULL))
+            goto err;
+    }
+
+    if (!TEST_int_eq(SSL_use_enc_PrivateKey(ssl, enc_pkey), 1))
+        goto err;
+
+    if (i == 0) {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_SM2_ENC].privatekey != NULL))
+            goto err;
+    } else {
+        if (!TEST_true(sc->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL))
+            goto err;
+    }
+
+    ret = 1;
+err:
+    BIO_free(sign_cert_bio);
+    BIO_free(enc_cert_bio);
+    BIO_free(sign_pkey_bio);
+    BIO_free(enc_pkey_bio);
+    X509_free(sign_cert);
+    X509_free(enc_cert);
+    EVP_PKEY_free(sign_pkey);
+    EVP_PKEY_free(enc_pkey);
+    SSL_CTX_free(ctx);
+    SSL_free(ssl);
+    return ret;
+}
+
+static int test_ntls_method_api(void)
+{
+    int ret = 1;
+    const SSL_METHOD *meth = NULL;
+
+    ret = 0;
+    meth = NTLS_method();
+    if (!TEST_true(meth->version == NTLS_VERSION))
+        goto err;
+    if (!TEST_true(meth->flags == SSL_METHOD_NO_SUITEB))
+        goto err;
+    if (!TEST_true(meth->mask == SSL_OP_NO_NTLS))
+        goto err;
+
+    meth = NTLS_server_method();
+    if (!TEST_true(meth->version == NTLS_VERSION))
+        goto err;
+    if (!TEST_true(meth->flags == SSL_METHOD_NO_SUITEB))
+        goto err;
+    if (!TEST_true(meth->mask == SSL_OP_NO_NTLS))
+        goto err;
+
+    meth = NTLS_client_method();
+    if (!TEST_true(meth->version == NTLS_VERSION))
+        goto err;
+    if (!TEST_true(meth->flags == SSL_METHOD_NO_SUITEB))
+        goto err;
+    if (!TEST_true(meth->mask == SSL_OP_NO_NTLS))
+        goto err;
+
+    ret = 1;
+err:
+    return ret;
+}
+
+int setup_tests(void)
+{
+    if (!TEST_ptr(sm2_sign_cert_file = test_get_argument(0))
+            || !TEST_ptr(sm2_sign_key_file = test_get_argument(1))
+            || !TEST_ptr(sm2_enc_cert_file = test_get_argument(2))
+            || !TEST_ptr(sm2_enc_key_file = test_get_argument(3))
+            || !TEST_ptr(rsa_sign_cert_file = test_get_argument(4))
+            || !TEST_ptr(rsa_sign_key_file = test_get_argument(5))
+            || !TEST_ptr(rsa_enc_cert_file = test_get_argument(6))
+            || !TEST_ptr(rsa_enc_key_file = test_get_argument(7))) {
+        TEST_note("usage: ssl_ntls_api_test cert.pem|key.pem");
+        return 0;
+    }
+    ADD_ALL_TESTS(test_ntls_ctx_set_cert_pkey_file_api, 2);
+    ADD_ALL_TESTS(test_ntls_ctx_set_cert_pkey_api, 2);
+    ADD_ALL_TESTS(test_ntls_ssl_set_cert_pkey_file_api, 2);
+    ADD_ALL_TESTS(test_ntls_ssl_set_cert_pkey_api, 2);
+    ADD_TEST(test_ntls_method_api);
+
+    ADD_ALL_TESTS(test_ntls_ctx_set_cipher_list, OSSL_NELEM(cipher_list) - 1);
+    ADD_ALL_TESTS(test_ntls_ssl_set_cipher_list, OSSL_NELEM(cipher_list) - 1);
+    return 1;
+}
Index: b/test/ssl_test.c
===================================================================
--- a/test/ssl_test.c
+++ b/test/ssl_test.c
@@ -448,6 +448,34 @@ static int test_handshake(int idx)
         }
     }
 #endif
+#ifndef OPENSSL_NO_NTLS
+    if (test_ctx->method == SSL_TEST_METHOD_NTLS) {
+        server_ctx = SSL_CTX_new_ex(libctx, NULL, NTLS_server_method());
+        if (!TEST_ptr(server_ctx)) {
+            goto err;
+        }
+
+        if (test_ctx->extra.server.servername_callback !=
+            SSL_TEST_SERVERNAME_CB_NONE) {
+            if (!TEST_ptr(server2_ctx = SSL_CTX_new_ex(libctx, NULL, NTLS_server_method())))
+                goto err;
+        }
+
+        client_ctx = SSL_CTX_new_ex(libctx, NULL, NTLS_client_method());
+        if (!TEST_ptr(client_ctx)) {
+            goto err;
+        }
+
+        if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RESUME) {
+            resume_server_ctx = SSL_CTX_new_ex(libctx, NULL, NTLS_server_method());
+            resume_client_ctx = SSL_CTX_new_ex(libctx, NULL, NTLS_client_method());
+
+            if (!TEST_ptr(resume_server_ctx)
+                || !TEST_ptr(resume_client_ctx))
+                goto err;
+        }
+    }
+#endif
     if (test_ctx->method == SSL_TEST_METHOD_TLS) {
 #if !defined(OPENSSL_NO_TLS1_3) \
     && defined(OPENSSL_NO_EC) \
Index: b/util/other.syms
===================================================================
--- a/util/other.syms
+++ b/util/other.syms
@@ -741,3 +741,25 @@ EVP_PKEY_size
 EVP_PKEY_id                             define
 EVP_PKEY_base_id                        define
 SSL_set_retry_verify                    define
+SSL_CIPHER_get_auth                     define
+SSL_CIPHER_get_enc                      define
+SSL_CIPHER_get_mac                      define
+SSL_CIPHER_get_mkey                     define
+SSL_client_hello_get1_extensions        define
+SSL_get_enc_certificate_ntls            define
+SSL_get_sign_certificate_ntls           define
+SSL_CTX_get_cert_cb                     define
+SSL_get_cert_cb                         define
+SSL_CTX_get_cert_cb_arg                 define
+SSL_get_cert_cb_arg                     define
+SSL_cert_cb_fn                          datatype
+SSL_SESSION_get_ref                     define
+SSL_get_master_key                      define
+SSL_get0_alpn_proposed                  define
+SSL_get0_wbio                           define
+SSL_get_use_certificate                 define
+SSL_check_tlsext_status                 define
+SSL_CTX_certs_clear                     define
+OPENSSL_CHECK_TLSEXT_STATUS             define
+SSL_set_SESSION_CTX                     define
+SSL_debug                               define
\ No newline at end of file
Index: b/util/perl/OpenSSL/Test.pm
===================================================================
--- a/util/perl/OpenSSL/Test.pm
+++ b/util/perl/OpenSSL/Test.pm
@@ -1,4 +1,4 @@
-# Copyright 2016-2021 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the Apache License 2.0 (the "License").  You may not use
 # this file except in compliance with the License.  You can obtain a copy
@@ -25,7 +25,8 @@ $VERSION = "1.0";
                                          result_file result_dir
                                          pipe with cmdstr
                                          openssl_versions
-                                         ok_nofips is_nofips isnt_nofips));
+                                         ok_nofips is_nofips isnt_nofips
+                                         merge_files));
 
 =head1 NAME
 
@@ -1304,6 +1305,29 @@ sub __decorate_cmd {
     return ($cmdstr, $display_cmd);
 }
 
+sub merge_files {
+    return __merge_files(@_);
+}
+
+sub __merge_files {
+    my $dest_file = pop @_;
+
+    open my $dest, '>', $dest_file
+        or die "Trying to write to $dest_file: $!\n";
+
+    foreach my $file (@_) {
+        open my $src, "<", $file
+            or die "Could not open $file: $!\n";
+
+        while (my $line = <$src>) {
+            print $dest $line;
+        }
+
+        close($src);
+    }
+
+    close($dest);
+}
 =head1 SEE ALSO
 
 L<Test::More>, L<Test::Harness>
Index: b/include/crypto/sm2.h
===================================================================
--- a/include/crypto/sm2.h
+++ b/include/crypto/sm2.h
@@ -30,7 +30,7 @@ int ossl_sm2_key_private_check(const EC_
 int ossl_sm2_compute_z_digest(uint8_t *out,
                               const EVP_MD *digest,
                               const uint8_t *id,
-                              const size_t id_len,
+                              size_t id_len,
                               const EC_KEY *key);
 
 /*
@@ -85,6 +85,14 @@ int ossl_sm2_decrypt(const EC_KEY *key,
 const unsigned char *ossl_sm2_algorithmidentifier_encoding(int md_nid,
                                                            size_t *len);
 
+int SM2_compute_key(void *out, size_t outlen, int initiator,
+                    const uint8_t *peer_id, size_t peer_id_len,
+                    const uint8_t *self_id, size_t self_id_len,
+                    const EC_KEY *peer_ecdhe_key, const EC_KEY *self_ecdhe_key,
+                    const EC_KEY *peer_pub_key, const EC_KEY *self_eckey,
+                    const EVP_MD *md, OSSL_LIB_CTX *libctx,
+                    const char *propq);
+
 # if !defined(I386_ONLY) && (\
     defined(__i386) || defined(__i386__) || defined(_M_IX86) || \
     defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64) )
Index: b/include/openssl/prov_ssl.h
===================================================================
--- a/include/openssl/prov_ssl.h
+++ b/include/openssl/prov_ssl.h
@@ -20,6 +20,7 @@ extern "C" {
 # define SSL_MAX_MASTER_KEY_LENGTH 48
 
 /* SSL/TLS uses a 2 byte unsigned version number */
+# define NTLS1_1_VERSION                 0x0101
 # define SSL3_VERSION                    0x0300
 # define TLS1_VERSION                    0x0301
 # define TLS1_1_VERSION                  0x0302
Index: b/test/helpers/ssl_test_ctx.h
===================================================================
--- a/test/helpers/ssl_test_ctx.h
+++ b/test/helpers/ssl_test_ctx.h
@@ -66,7 +66,10 @@ typedef enum {
 typedef enum {
     SSL_TEST_METHOD_TLS = 0, /* Default */
     SSL_TEST_METHOD_DTLS,
-    SSL_TEST_METHOD_QUIC
+    SSL_TEST_METHOD_QUIC,
+#ifndef OPENSSL_NO_NTLS
+    SSL_TEST_METHOD_NTLS,
+#endif
 } ssl_test_method_t;
 
 typedef enum {
Index: b/ssl/build.info
===================================================================
--- a/ssl/build.info
+++ b/ssl/build.info
@@ -31,6 +31,15 @@ IF[{- !$disabled{'deprecated-3.0'} -}]
   SOURCE[../libssl]=ssl_rsa_legacy.c
 ENDIF
 
+IF[{- !$disabled{ntls} -}]
+  SOURCE[../libssl]=statem_ntls/ntls_extensions.c \
+        statem_ntls/ntls_extensions_clnt.c \
+        statem_ntls/ntls_extensions_cust.c statem_ntls/ntls_extensions_srvr.c \
+        statem_ntls/ntls_statem.c statem_ntls/ntls_statem_clnt.c \
+        statem_ntls/ntls_statem_lib.c statem_ntls/ntls_statem_srvr.c
+ENDIF
+
+
 IF[{- !$disabled{quic} -}]
   SOURCE[../libssl]=priority_queue.c event_queue.c
 ENDIF
Index: b/test/recipes/80-test_ssl_new.t
===================================================================
--- a/test/recipes/80-test_ssl_new.t
+++ b/test/recipes/80-test_ssl_new.t
@@ -42,7 +42,7 @@ if (defined $ENV{SSL_TESTS}) {
     @conf_srcs = glob(srctop_file("test", "ssl-tests", "*.cnf.in"));
     # We hard-code the number of tests to double-check that the globbing above
     # finds all files as expected.
-    plan tests => 31;
+    plan tests => 35;
 }
 map { s/;.*// } @conf_srcs if $^O eq "VMS";
 my @conf_files = map { basename($_, ".in") } @conf_srcs;
@@ -94,6 +94,10 @@ my %conf_dependent_tests = (
   "28-seclevel.cnf" => disabled("tls1_2") || $no_ecx,
   "30-extended-master-secret.cnf" => disabled("tls1_2"),
   "32-compressed-certificate.cnf" => disabled("comp") || disabled("tls1_3"),
+  "31-ntls.cnf" => disabled("ntls"),
+  "39-ntls-sni-ticket.cnf" => disabled("ntls"),
+  "40-ntls_client_auth.cnf" => disabled("ntls"),
+  "41-ntls-alpn.cnf" => disabled("ntls"),
 );
 
 # Add your test here if it should be skipped for some compile-time
@@ -129,6 +133,16 @@ my %skip = (
   "26-tls13_client_auth.cnf" => disabled("tls1_3") || ($no_ec && $no_dh),
   "29-dtls-sctp-label-bug.cnf" => disabled("sctp") || disabled("sock"),
   "32-compressed-certificate.cnf" => disabled("comp") || disabled("tls1_3"),
+  "31-ntls.cnf" => disabled("ntls") || disabled("sm2") || disabled("sm3")
+                    || disabled("sm4") || !$no_fips,
+  "39-ntls-sni-ticket.cnf" => disabled("ntls") || disabled("sm2")
+                                || disabled("sm3") || disabled("sm4")
+                                || !$no_fips,
+  "40-ntls_client_auth.cnf" => disabled("ntls") || disabled("sm2")
+                                || disabled("sm3") || disabled("sm4")
+                                || !$no_fips,
+  "41-ntls-alpn.cnf" => disabled("ntls") || disabled("sm2")
+                         || disabled("sm3") || disabled("sm4") || !$no_fips,
 );
 
 foreach my $conf (@conf_files) {
Index: b/util/libssl.num
===================================================================
--- a/util/libssl.num
+++ b/util/libssl.num
@@ -577,3 +577,51 @@ SSL_handle_events
 SSL_get_event_timeout                   578	3_2_0	EXIST::FUNCTION:
 SSL_get0_group_name                     579	3_2_0	EXIST::FUNCTION:
 SSL_is_stream_local                     580	3_2_0	EXIST::FUNCTION:
+NTLS_method                             581	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_enc_PrivateKey              582	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_sign_certificate_file       583	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_sign_PrivateKey             584	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_enc_certificate             585	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_sign_certificate            586	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_enc_PrivateKey_file         587	3_2_4	EXIST::FUNCTION:NTLS
+NTLS_server_method                      588	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_sign_PrivateKey_file        589	3_2_4	EXIST::FUNCTION:NTLS
+SSL_is_ntls                             590	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_use_enc_certificate_file        591	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_disable_ntls                    592	3_2_4	EXIST::FUNCTION:NTLS
+SSL_enable_ntls                         593	3_2_4	EXIST::FUNCTION:NTLS
+SSL_disable_ntls                        594	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_enable_ntls                     595	3_2_4	EXIST::FUNCTION:NTLS
+NTLS_client_method                      596	3_2_4	EXIST::FUNCTION:NTLS
+BABASSL_get_sign_certificate_ntls       597	3_2_4	EXIST::FUNCTION:NTLS
+BABASSL_get_enc_certificate_ntls        598	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_sign_certificate                599	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_enc_PrivateKey_file             600	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_sign_certificate_file           601	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_sign_PrivateKey_file            602	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_sign_PrivateKey                 603	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_enc_certificate                 604	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_enc_certificate_file            605	3_2_4	EXIST::FUNCTION:NTLS
+SSL_use_enc_PrivateKey                  606	3_2_4	EXIST::FUNCTION:NTLS
+SSL_CTX_enable_sm_tls13_strict          607	3_2_4	EXIST::FUNCTION:SM2
+SSL_CTX_disable_sm_tls13_strict         608	3_2_4	EXIST::FUNCTION:SM2
+SSL_enable_sm_tls13_strict              609	3_2_4	EXIST::FUNCTION:SM2
+SSL_disable_sm_tls13_strict             610	3_2_4	EXIST::FUNCTION:SM2
+BABASSL_get_cert_cb                     611	3_2_4	EXIST::FUNCTION:
+BABASSL_get_cert_cb_arg                 612	3_2_4	EXIST::FUNCTION:
+BABASSL_CIPHER_get_mkey                 613	3_2_4	EXIST::FUNCTION:
+BABASSL_CIPHER_get_auth                 614	3_2_4	EXIST::FUNCTION:
+BABASSL_CIPHER_get_enc                  615	3_2_4	EXIST::FUNCTION:
+BABASSL_CIPHER_get_mac                  616	3_2_4	EXIST::FUNCTION:
+BABASSL_get0_wbio                       617	3_2_4	EXIST::FUNCTION:
+BABASSL_CTX_get_cert_cb                 618	3_2_4	EXIST::FUNCTION:
+BABASSL_CTX_get_cert_cb_arg             619	3_2_4	EXIST::FUNCTION:
+BABASSL_SESSION_get_ref                 620	3_2_4	EXIST::FUNCTION:
+BABASSL_set_SESSION_CTX                 621	3_2_4	EXIST::FUNCTION:
+BABASSL_client_hello_get1_extensions    622	3_2_4	EXIST::FUNCTION:
+BABASSL_get_use_certificate             623	3_2_4	EXIST::FUNCTION:
+BABASSL_get0_alpn_proposed              624	3_2_4	EXIST::FUNCTION:
+BABASSL_CTX_certs_clear                 625	3_2_4	EXIST::FUNCTION:
+BABASSL_check_tlsext_status             626	3_2_4	EXIST::FUNCTION:
+BABASSL_get_master_key                  627	3_2_4	EXIST::FUNCTION:
+BABASSL_debug                           628	3_2_4	EXIST::FUNCTION:
\ No newline at end of file
Index: b/include/crypto/sm2err.h
===================================================================
--- a/include/crypto/sm2err.h
+++ b/include/crypto/sm2err.h
@@ -40,6 +40,7 @@ int ossl_err_load_SM2_strings(void);
 #  define SM2_R_INVALID_PRIVATE_KEY                        113
 #  define SM2_R_NO_PARAMETERS_SET                          109
 #  define SM2_R_USER_ID_TOO_LARGE                          106
+#  define SM2_R_POINT_ARITHMETIC_FAILURE                   114
 
 # endif
 
Index: b/crypto/sm2/sm2_err.c
===================================================================
--- a/crypto/sm2/sm2_err.c
+++ b/crypto/sm2/sm2_err.c
@@ -32,6 +32,7 @@ static const ERR_STRING_DATA SM2_str_rea
     "invalid private key"},
     {ERR_PACK(ERR_LIB_SM2, 0, SM2_R_NO_PARAMETERS_SET), "no parameters set"},
     {ERR_PACK(ERR_LIB_SM2, 0, SM2_R_USER_ID_TOO_LARGE), "user id too large"},
+    {ERR_PACK(ERR_LIB_SM2, 0, SM2_R_POINT_ARITHMETIC_FAILURE), "point arithmetic failure"},
     {0, NULL}
 };
 
Index: b/include/openssl/sslerr.h
===================================================================
--- a/include/openssl/sslerr.h
+++ b/include/openssl/sslerr.h
@@ -366,5 +366,5 @@
 # define SSL_R_WRONG_VERSION_NUMBER                       267
 # define SSL_R_X509_LIB                                   268
 # define SSL_R_X509_VERIFICATION_SETUP_PROBLEMS           269
-
+# define SSL_R_MISSING_ENC_CERTIFICATE                    412
 #endif
Index: b/ssl/ssl_err.c
===================================================================
--- a/ssl/ssl_err.c
+++ b/ssl/ssl_err.c
@@ -250,6 +250,8 @@ static const ERR_STRING_DATA SSL_str_rea
     "missing dsa signing cert"},
     {ERR_PACK(ERR_LIB_SSL, 0, SSL_R_MISSING_ECDSA_SIGNING_CERT),
     "missing ecdsa signing cert"},
+    {ERR_PACK(ERR_LIB_SSL, 0, SSL_R_MISSING_ENC_CERTIFICATE),
+    "missing encryption certificate"},
     {ERR_PACK(ERR_LIB_SSL, 0, SSL_R_MISSING_FATAL), "missing fatal"},
     {ERR_PACK(ERR_LIB_SSL, 0, SSL_R_MISSING_PARAMETERS), "missing parameters"},
     {ERR_PACK(ERR_LIB_SSL, 0, SSL_R_MISSING_PSK_KEX_MODES_EXTENSION),
Index: b/crypto/objects/obj_dat.h
===================================================================
--- a/crypto/objects/obj_dat.h
+++ b/crypto/objects/obj_dat.h
@@ -1184,7 +1184,7 @@ static const unsigned char so[8476] = {
     0x55,0x1D,0x4B,                                /* [ 8472] OBJ_associated_information */
 };
 
-#define NUM_NID 1320
+#define NUM_NID 1323
 static const ASN1_OBJECT nid_objs[NUM_NID] = {
     {"UNDEF", "undefined", NID_undef},
     {"rsadsi", "RSA Data Security, Inc.", NID_rsadsi, 6, &so[0]},
@@ -2506,9 +2506,12 @@ static const ASN1_OBJECT nid_objs[NUM_NI
     {"altSignatureAlgorithm", "X509v3 Alternative Signature Algorithm", NID_alt_signature_algorithm, 3, &so[8466]},
     {"altSignatureValue", "X509v3 Alternative Signature Value", NID_alt_signature_value, 3, &so[8469]},
     {"associatedInformation", "X509v3 Associated Information", NID_associated_information, 3, &so[8472]},
+    {"KxSM2", "kx-sm2", NID_kx_sm2},
+    {"KxSM2DHE", "kx-sm2dhe", NID_kx_sm2dhe},
+    {"AuthSM2", "auth-sm2", NID_auth_sm2},
 };
 
-#define NUM_SN 1311
+#define NUM_SN 1314
 static const unsigned int sn_objs[NUM_SN] = {
      364,    /* "AD_DVCS" */
      419,    /* "AES-128-CBC" */
@@ -2581,6 +2584,7 @@ static const unsigned int sn_objs[NUM_SN
     1053,    /* "AuthNULL" */
     1048,    /* "AuthPSK" */
     1046,    /* "AuthRSA" */
+    1322,    /* "AuthSM2" */
     1052,    /* "AuthSRP" */
       91,    /* "BF-CBC" */
       93,    /* "BF-CFB" */
@@ -2691,6 +2695,8 @@ static const unsigned int sn_objs[NUM_SN
     1043,    /* "KxPSK" */
     1037,    /* "KxRSA" */
     1042,    /* "KxRSA_PSK" */
+    1320,    /* "KxSM2" */
+    1321,    /* "KxSM2DHE" */
     1044,    /* "KxSRP" */
       15,    /* "L" */
      856,    /* "LocalKeySet" */
@@ -3823,7 +3829,7 @@ static const unsigned int sn_objs[NUM_SN
     1289,    /* "zstd" */
 };
 
-#define NUM_LN 1311
+#define NUM_LN 1314
 static const unsigned int ln_objs[NUM_LN] = {
      363,    /* "AD Time Stamping" */
      405,    /* "ANSI X9.62" */
@@ -4171,6 +4177,7 @@ static const unsigned int ln_objs[NUM_LN
     1053,    /* "auth-null" */
     1048,    /* "auth-psk" */
     1046,    /* "auth-rsa" */
+    1322,    /* "auth-sm2" */
     1052,    /* "auth-srp" */
      882,    /* "authorityRevocationList" */
       91,    /* "bf-cbc" */
@@ -4733,6 +4740,8 @@ static const unsigned int ln_objs[NUM_LN
     1043,    /* "kx-psk" */
     1037,    /* "kx-rsa" */
     1042,    /* "kx-rsa-psk" */
+    1320,    /* "kx-sm2" */
+    1321,    /* "kx-sm2dhe" */
     1044,    /* "kx-srp" */
      477,    /* "lastModifiedBy" */
      476,    /* "lastModifiedTime" */
Index: b/crypto/objects/obj_mac.num
===================================================================
--- a/crypto/objects/obj_mac.num
+++ b/crypto/objects/obj_mac.num
@@ -1317,3 +1317,6 @@ subject_alt_public_key_info		1316
 alt_signature_algorithm		1317
 alt_signature_value		1318
 associated_information		1319
+kx_sm2		1320
+kx_sm2dhe		1321
+auth_sm2		1322
\ No newline at end of file
Index: b/ssl/record/methods/tls_common.c
===================================================================
--- a/ssl/record/methods/tls_common.c
+++ b/ssl/record/methods/tls_common.c
@@ -664,7 +664,11 @@ int tls_get_more_records(OSSL_RECORD_LAY
                     return OSSL_RECORD_RETURN_FATAL;
                 }
             }
-
+#ifndef OPENSSL_NO_NTLS
+            if (thisrr->rec_version == NTLS_VERSION) {
+                /* do nothing */
+            } else
+#endif
             if (!rl->funcs->validate_record_header(rl, thisrr)) {
                 /* RLAYERfatal already called */
                 return OSSL_RECORD_RETURN_FATAL;
@@ -1413,6 +1417,9 @@ tls_new_record_layer(OSSL_LIB_CTX *libct
     case TLS1_2_VERSION:
     case TLS1_1_VERSION:
     case TLS1_VERSION:
+#ifndef OPENSSL_NO_NTLS
+    case NTLS_VERSION:
+#endif
         (*retrl)->funcs = &tls_1_funcs;
         break;
     case SSL3_VERSION:
Index: b/crypto/asn1/a_verify.c
===================================================================
--- a/crypto/asn1/a_verify.c
+++ b/crypto/asn1/a_verify.c
@@ -96,14 +96,58 @@ int ASN1_item_verify_ex(const ASN1_ITEM
                         const ASN1_OCTET_STRING *id, EVP_PKEY *pkey,
                         OSSL_LIB_CTX *libctx, const char *propq)
 {
-    EVP_MD_CTX *ctx;
     int rv = -1;
+    int mdnid, pknid;
+    const EVP_MD *md = NULL;
+    EVP_MD_CTX *ctx = evp_md_ctx_new_ex(pkey, id, libctx, propq);
 
-    if ((ctx = evp_md_ctx_new_ex(pkey, id, libctx, propq)) != NULL) {
-        rv = ASN1_item_verify_ctx(it, alg, signature, data, ctx);
-        EVP_PKEY_CTX_free(EVP_MD_CTX_get_pkey_ctx(ctx));
-        EVP_MD_CTX_free(ctx);
+    if (ctx == NULL) {
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
+        return rv;
     }
+
+    /* Convert signature OID into digest and public key OIDs */
+    if (!OBJ_find_sigid_algs(OBJ_obj2nid(alg->algorithm), &mdnid, &pknid)) {
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
+        goto err;
+    }
+
+    if (mdnid != NID_undef) {
+        md = EVP_get_digestbynid(mdnid);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
+            goto err;
+        }
+    }
+
+#ifndef OPENSSL_NO_SM2
+    if (pknid == NID_sm2) {
+        EVP_PKEY_CTX *pctx = NULL, *opctx = EVP_MD_CTX_get_pkey_ctx(ctx);
+
+        pctx = EVP_PKEY_CTX_new_from_pkey(opctx->libctx, pkey,
+                                          opctx->propquery);
+        if (pctx == NULL) {
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
+            goto err;
+        }
+
+        if (EVP_PKEY_CTX_set1_id(pctx,
+                                 opctx->cached_parameters.dist_id,
+                                 opctx->cached_parameters.dist_id_len) != 1) {
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
+            goto err;
+        }
+
+        EVP_PKEY_CTX_free(opctx);
+        EVP_MD_CTX_set_pkey_ctx(ctx, pctx);
+    }
+#endif
+
+    rv = ASN1_item_verify_ctx(it, alg, signature, data, ctx);
+
+ err:
+    EVP_PKEY_CTX_free(EVP_MD_CTX_get_pkey_ctx(ctx));
+    EVP_MD_CTX_free(ctx);
     return rv;
 }
 
Index: b/apps/ca.c
===================================================================
--- a/apps/ca.c
+++ b/apps/ca.c
@@ -156,7 +156,8 @@ typedef enum OPTION_choice {
     OPT_RAND_SERIAL, OPT_QUIET,
     OPT_R_ENUM, OPT_PROV_ENUM,
     /* Do not change the order here; see related case statements below */
-    OPT_CRL_REASON, OPT_CRL_HOLD, OPT_CRL_COMPROMISE, OPT_CRL_CA_COMPROMISE
+    OPT_CRL_REASON, OPT_CRL_HOLD, OPT_CRL_COMPROMISE, OPT_CRL_CA_COMPROMISE,
+    OPT_SM2ID, OPT_SM2HEXID
 } OPTION_CHOICE;
 
 const OPTIONS ca_options[] = {
@@ -255,6 +256,12 @@ const OPTIONS ca_options[] = {
 
     OPT_PARAMETERS(),
     {"certreq", 0, 0, "Certificate requests to be signed (optional)"},
+#ifndef OPENSSL_NO_SM2
+    {"sm2-id", OPT_SM2ID, 's',
+     "Specify an ID string to verify an SM2 certificate request"},
+    {"sm2-hex-id", OPT_SM2HEXID, 's',
+     "Specify a hex ID string to verify an SM2 certificate request"},
+#endif
     {NULL}
 };
 
@@ -302,6 +309,11 @@ int ca_main(int argc, char **argv)
     REVINFO_TYPE rev_type = REV_NONE;
     X509_REVOKED *r = NULL;
     OPTION_CHOICE o;
+#ifndef OPENSSL_NO_SM2
+    char *sm2_id = NULL;
+    char *sig_sm2_id = NULL;
+#endif
+    char *sigopt_str = NULL;
 
     prog = opt_init(argc, argv, ca_options);
     while ((o = opt_next()) != OPT_EOF) {
@@ -410,9 +422,53 @@ opthelp:
         case OPT_SIGOPT:
             if (sigopts == NULL)
                 sigopts = sk_OPENSSL_STRING_new_null();
-            if (sigopts == NULL || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))
+            if (sigopts == NULL)
+                goto end;
+            sigopt_str = opt_arg();
+#ifndef OPENSSL_NO_SM2
+            /*
+             * trying to find out if we need to rebuild the string.
+             * multiple sm2 ids are not allowed, so we only try to
+             * rebuild the string once.
+             */
+            if (sig_sm2_id == NULL) {
+                if (!build_sigopt_compat_string(&sig_sm2_id, opt_arg()))
+                    goto end;
+                if (sig_sm2_id != NULL)
+                    sigopt_str = sig_sm2_id;
+            }
+#endif
+            if (!sk_OPENSSL_STRING_push(sigopts, sigopt_str))
                 goto end;
             break;
+        case OPT_SM2ID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto end;
+            }
+            if (!build_vfyopt_compat_string(0, &sm2_id, opt_arg()))
+                 goto end;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto end;
+#endif
+            break;
+        case OPT_SM2HEXID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto end;
+            }
+            if (!build_vfyopt_compat_string(1, &sm2_id, opt_arg()))
+                goto end;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto end;
+#endif
+            break;
         case OPT_VFYOPT:
             if (vfyopts == NULL)
                 vfyopts = sk_OPENSSL_STRING_new_null();
@@ -1324,6 +1380,10 @@ end_of_options:
     NCONF_free(conf);
     NCONF_free(extfile_conf);
     release_engine(e);
+#ifndef OPENSSL_NO_SM2
+    OPENSSL_free(sm2_id);
+    OPENSSL_free(sig_sm2_id);
+#endif
     return ret;
 }
 
Index: b/apps/lib/apps.c
===================================================================
--- a/apps/lib/apps.c
+++ b/apps/lib/apps.c
@@ -3456,3 +3456,82 @@ int opt_legacy_okay(void)
         return 0;
     return 1;
 }
+
+
+/*-
+ * This function returns a new string built by input option and value
+ * This is only used for SM2 related option compatibility
+ *
+ * The caller needs to free the memory pointed by ret.
+ *
+ * options: 0 for sm2-id and 1 for sm2-hex-id.
+ */
+int build_vfyopt_compat_string(int option, char **ret, const char *value)
+{
+    int prefix_len = 0;
+    char *prefix = NULL;
+    char *tmp = NULL;
+
+    if (option == 0) {
+        prefix_len = DISTID_LEN;
+        prefix = DISTID;
+    } else if (option == 1) {
+        prefix_len = HEXDISTID_LEN;
+        prefix = HEXDISTID;
+    } else {
+        /* unknown option */
+        return 0;
+    }
+
+    tmp = OPENSSL_zalloc(strlen(value) + prefix_len + 1);
+    if (tmp == NULL)
+        return 0;
+
+    memcpy(tmp, prefix, prefix_len);
+    memcpy(tmp + prefix_len, value, strlen(value));
+    *ret = tmp;
+
+    return 1;
+}
+
+/*-
+ * This function returns a new string rebuilt from the input value
+ * This is only used for SM2 related option compatibility
+ *
+ * The caller needs to free the memory pointed by ret.
+ *
+ * detailed substitution rules are:
+ *   sm2_id -> distid
+ *   sm2_hex_id -> hexdistid
+ */
+int build_sigopt_compat_string(char **ret, const char *value)
+{
+    int prefix_len = 0;
+    int new_prefix_len = 0;
+    char *new_prefix = NULL;
+    char *tmp = NULL;
+
+    if (!strncmp(value, SM2ID, SM2ID_LEN)) {
+        prefix_len = SM2ID_LEN;
+        new_prefix = DISTID;
+        new_prefix_len = DISTID_LEN;
+    } else if (!strncmp(value, SM2HEXID, SM2HEXID_LEN)) {
+        prefix_len = SM2HEXID_LEN;
+        new_prefix = HEXDISTID;
+        new_prefix_len = HEXDISTID_LEN;
+    } else {
+        /* pattern not found */
+        return -1;
+    }
+
+    tmp = OPENSSL_zalloc(new_prefix_len + strlen(value) - prefix_len + 1);
+    if (tmp == NULL)
+        return 0;
+
+    memcpy(tmp, new_prefix, new_prefix_len);
+    memcpy(tmp + new_prefix_len, value + prefix_len,
+           strlen(value) - prefix_len);
+    *ret = tmp;
+
+    return 1;
+}
Index: b/apps/include/apps.h
===================================================================
--- a/apps/include/apps.h
+++ b/apps/include/apps.h
@@ -351,4 +351,17 @@ void app_providers_cleanup(void);
 EVP_PKEY *app_keygen(EVP_PKEY_CTX *ctx, const char *alg, int bits, int verbose);
 EVP_PKEY *app_paramgen(EVP_PKEY_CTX *ctx, const char *alg);
 
+/* for SM2 compatibility usage */
+#define DISTID           "distid:"
+#define DISTID_LEN       (sizeof("distid:") - 1)
+#define HEXDISTID        "hexdistid:"
+#define HEXDISTID_LEN    (sizeof("hexdistid:") - 1)
+#define SM2ID            "sm2_id:"
+#define SM2ID_LEN        (sizeof("sm2_id:") - 1)
+#define SM2HEXID         "sm2_hex_id:"
+#define SM2HEXID_LEN     (sizeof("sm2_hex_id:") - 1)
+
+int build_vfyopt_compat_string(int option, char **ret, const char *value);
+int build_sigopt_compat_string(char **ret, const char *value);
+
 #endif
Index: b/apps/pkeyutl.c
===================================================================
--- a/apps/pkeyutl.c
+++ b/apps/pkeyutl.c
@@ -129,6 +129,10 @@ int pkeyutl_main(int argc, char **argv)
     EVP_MD *md = NULL;
     int filesize = -1;
     OSSL_LIB_CTX *libctx = app_get0_libctx();
+    char *pkeyopt_str = NULL;
+#ifndef OPENSSL_NO_SM2
+    char *sm2_id = NULL;
+#endif
 
     prog = opt_init(argc, argv, pkeyutl_options);
     while ((o = opt_next()) != OPT_EOF) {
@@ -229,12 +233,27 @@ int pkeyutl_main(int argc, char **argv)
             rev = 1;
             break;
         case OPT_PKEYOPT:
-            if ((pkeyopts == NULL &&
-                 (pkeyopts = sk_OPENSSL_STRING_new_null()) == NULL) ||
-                sk_OPENSSL_STRING_push(pkeyopts, opt_arg()) == 0) {
+            if (pkeyopts == NULL &&
+                 (pkeyopts = sk_OPENSSL_STRING_new_null()) == NULL) {
                 BIO_puts(bio_err, "out of memory\n");
                 goto end;
             }
+            pkeyopt_str = opt_arg();
+#ifndef OPENSSL_NO_SM2
+            /*
+             * trying to find out if we need to rebuild the string.
+             * multiple sm2 ids are not allowed, so we only try to
+             * rebuild the string once.
+             */
+            if (sm2_id == NULL) {
+                if (!build_sigopt_compat_string(&sm2_id, opt_arg()))
+                    goto end;
+                if (sm2_id != NULL)
+                    pkeyopt_str = sm2_id;
+            }
+#endif
+            if (sk_OPENSSL_STRING_push(pkeyopts, pkeyopt_str) == 0)
+                goto end;
             break;
         case OPT_PKEYOPT_PASSIN:
             if ((pkeyopts_passin == NULL &&
@@ -517,6 +536,9 @@ int pkeyutl_main(int argc, char **argv)
     sk_OPENSSL_STRING_free(pkeyopts);
     sk_OPENSSL_STRING_free(pkeyopts_passin);
     NCONF_free(conf);
+#ifndef OPENSSL_NO_SM2
+    OPENSSL_free(sm2_id);
+#endif
     return ret;
 }
 
Index: b/apps/req.c
===================================================================
--- a/apps/req.c
+++ b/apps/req.c
@@ -91,7 +91,8 @@ typedef enum OPTION_choice {
     OPT_COPY_EXTENSIONS, OPT_EXTENSIONS, OPT_REQEXTS, OPT_ADDEXT,
     OPT_PRECERT, OPT_MD,
     OPT_SECTION, OPT_QUIET,
-    OPT_R_ENUM, OPT_PROV_ENUM
+    OPT_R_ENUM, OPT_PROV_ENUM,
+    OPT_SM2ID, OPT_SM2HEXID
 } OPTION_CHOICE;
 
 const OPTIONS req_options[] = {
@@ -167,6 +168,13 @@ const OPTIONS req_options[] = {
 
     OPT_R_OPTIONS,
     OPT_PROV_OPTIONS,
+
+#ifndef OPENSSL_NO_SM2
+    {"sm2-id", OPT_SM2ID, 's',
+     "Specify an ID string to verify an SM2 certificate request"},
+    {"sm2-hex-id", OPT_SM2HEXID, 's',
+     "Specify a hex ID string to verify an SM2 certificate request"},
+#endif
     {NULL}
 };
 
@@ -266,6 +274,11 @@ int req_main(int argc, char **argv)
     int noenc = 0, newhdr = 0, subject = 0, pubkey = 0, precert = 0, x509v1 = 0;
     long newkey_len = -1;
     unsigned long chtype = MBSTRING_ASC, reqflag = 0;
+#ifndef OPENSSL_NO_SM2
+    char *sm2_id = NULL;
+    char *sig_sm2_id = NULL;
+#endif
+    char *sigopt_str = NULL;
 
 #ifndef OPENSSL_NO_DES
     cipher = (EVP_CIPHER *)EVP_des_ede3_cbc();
@@ -360,8 +373,52 @@ int req_main(int argc, char **argv)
         case OPT_SIGOPT:
             if (!sigopts)
                 sigopts = sk_OPENSSL_STRING_new_null();
-            if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))
-                goto opthelp;
+            if (!sigopts)
+                goto end;
+            sigopt_str = opt_arg();
+#ifndef OPENSSL_NO_SM2
+            /*
+             * trying to find out if we need to rebuild the string.
+             * multiple sm2 ids are not allowed, so we only try to
+             * rebuild the string once.
+             */
+            if (sig_sm2_id == NULL) {
+                if (!build_sigopt_compat_string(&sig_sm2_id, opt_arg()))
+                    goto end;
+                if (sig_sm2_id != NULL)
+                    sigopt_str = sig_sm2_id;
+            }
+#endif
+            if (!sk_OPENSSL_STRING_push(sigopts, sigopt_str))
+                goto end;
+            break;
+        case OPT_SM2ID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto end;
+            }
+            if (!build_vfyopt_compat_string(0, &sm2_id, opt_arg()))
+                goto end;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto end;
+#endif
+            break;
+        case OPT_SM2HEXID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto end;
+            }
+            if (!build_vfyopt_compat_string(1, &sm2_id, opt_arg()))
+                goto end;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto end;
+#endif
             break;
         case OPT_VFYOPT:
             if (!vfyopts)
@@ -1045,6 +1102,11 @@ int req_main(int argc, char **argv)
         OPENSSL_free(passin);
     if (passout != nofree_passout)
         OPENSSL_free(passout);
+
+#ifndef OPENSSL_NO_SM2
+    OPENSSL_free(sm2_id);
+    OPENSSL_free(sig_sm2_id);
+#endif
     return ret;
 }
 
Index: b/apps/verify.c
===================================================================
--- a/apps/verify.c
+++ b/apps/verify.c
@@ -32,7 +32,8 @@ typedef enum OPTION_choice {
     OPT_UNTRUSTED, OPT_TRUSTED, OPT_CRLFILE, OPT_CRL_DOWNLOAD, OPT_SHOW_CHAIN,
     OPT_V_ENUM, OPT_NAMEOPT, OPT_VFYOPT,
     OPT_VERBOSE,
-    OPT_PROV_ENUM
+    OPT_PROV_ENUM,
+    OPT_SM2ID, OPT_SM2HEXID
 } OPTION_CHOICE;
 
 const OPTIONS verify_options[] = {
@@ -73,6 +74,12 @@ const OPTIONS verify_options[] = {
 
     OPT_PARAMETERS(),
     {"cert", 0, 0, "Certificate(s) to verify (optional; stdin used otherwise)"},
+#ifndef OPENSSL_NO_SM2
+    {"sm2-id", OPT_SM2ID, 's',
+     "Specify an ID string to verify an SM2 certificate request"},
+    {"sm2-hex-id", OPT_SM2HEXID, 's',
+     "Specify a hex ID string to verify an SM2 certificate request"},
+#endif
     {NULL}
 };
 
@@ -88,6 +95,9 @@ int verify_main(int argc, char **argv)
     int noCApath = 0, noCAfile = 0, noCAstore = 0;
     int vpmtouched = 0, crl_download = 0, show_chain = 0, i = 0, ret = 1;
     OPTION_CHOICE o;
+#ifndef OPENSSL_NO_SM2
+    char *sm2_id = NULL;
+#endif
 
     if ((vpm = X509_VERIFY_PARAM_new()) == NULL)
         goto end;
@@ -178,6 +188,34 @@ int verify_main(int argc, char **argv)
             if (!set_nameopt(opt_arg()))
                 goto end;
             break;
+        case OPT_SM2ID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto end;
+            }
+            if (!build_vfyopt_compat_string(0, &sm2_id, opt_arg()))
+                goto end;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto end;
+#endif
+            break;
+        case OPT_SM2HEXID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto end;
+            }
+            if (!build_vfyopt_compat_string(1, &sm2_id, opt_arg()))
+                goto end;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto end;
+#endif
+            break;
         case OPT_VFYOPT:
             if (!vfyopts)
                 vfyopts = sk_OPENSSL_STRING_new_null();
@@ -239,6 +277,9 @@ int verify_main(int argc, char **argv)
     sk_X509_CRL_pop_free(crls, X509_CRL_free);
     sk_OPENSSL_STRING_free(vfyopts);
     release_engine(e);
+#ifndef OPENSSL_NO_SM2
+    OPENSSL_free(sm2_id);
+#endif
     return (ret < 0 ? 2 : ret);
 }
 
Index: b/apps/x509.c
===================================================================
--- a/apps/x509.c
+++ b/apps/x509.c
@@ -54,7 +54,8 @@ typedef enum OPTION_choice {
     OPT_CLRREJECT, OPT_ALIAS, OPT_CACREATESERIAL, OPT_CLREXT, OPT_OCSPID,
     OPT_SUBJECT_HASH_OLD, OPT_ISSUER_HASH_OLD, OPT_COPY_EXTENSIONS,
     OPT_BADSIG, OPT_MD, OPT_ENGINE, OPT_NOCERT, OPT_PRESERVE_DATES,
-    OPT_R_ENUM, OPT_PROV_ENUM, OPT_EXT
+    OPT_R_ENUM, OPT_PROV_ENUM, OPT_EXT,
+    OPT_SM2ID, OPT_SM2HEXID
 } OPTION_CHOICE;
 
 const OPTIONS x509_options[] = {
@@ -179,6 +180,12 @@ const OPTIONS x509_options[] = {
     {"engine", OPT_ENGINE, 's', "Use engine, possibly a hardware device"},
 #endif
     OPT_PROV_OPTIONS,
+#ifndef OPENSSL_NO_SM2
+    {"sm2-id", OPT_SM2ID, 's',
+     "Specify an ID string to verify an SM2 certificate request"},
+    {"sm2-hex-id", OPT_SM2HEXID, 's',
+     "Specify a hex ID string to verify an SM2 certificate request"},
+#endif
     {NULL}
 };
 
@@ -298,6 +305,11 @@ int x509_main(int argc, char **argv)
 #ifndef OPENSSL_NO_MD5
     int subject_hash_old = 0, issuer_hash_old = 0;
 #endif
+#ifndef OPENSSL_NO_SM2
+    char *sm2_id = NULL;
+    char *sig_sm2_id = NULL;
+#endif
+    char *sigopt_str = NULL;
 
     ctx = X509_STORE_new();
     if (ctx == NULL)
@@ -365,9 +377,53 @@ int x509_main(int argc, char **argv)
         case OPT_SIGOPT:
             if (!sigopts)
                 sigopts = sk_OPENSSL_STRING_new_null();
-            if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))
+            if (!sigopts)
+                goto opthelp;
+            sigopt_str = opt_arg();
+#ifndef OPENSSL_NO_SM2
+            /*
+             * trying to find out if we need to rebuild the string.
+             * multiple sm2 ids are not allowed, so we only try to
+             * rebuild the string once.
+             */
+            if (sig_sm2_id == NULL) {
+                if (!build_sigopt_compat_string(&sig_sm2_id, opt_arg()))
+                    goto opthelp;
+                if (sig_sm2_id != NULL)
+                    sigopt_str = sig_sm2_id;
+            }
+#endif
+            if (!sk_OPENSSL_STRING_push(sigopts, sigopt_str))
                 goto opthelp;
             break;
+        case OPT_SM2ID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto opthelp;
+            }
+            if (!build_vfyopt_compat_string(0, &sm2_id, opt_arg()))
+                 goto opthelp;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto opthelp;
+#endif
+            break;
+        case OPT_SM2HEXID:
+#ifndef OPENSSL_NO_SM2
+            if (sm2_id != NULL) {
+                /* the ID has already been set */
+                goto opthelp;
+            }
+            if (!build_vfyopt_compat_string(1, &sm2_id, opt_arg()))
+                goto opthelp;
+            if (vfyopts == NULL)
+                vfyopts = sk_OPENSSL_STRING_new_null();
+            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, sm2_id))
+                goto opthelp;
+#endif
+            break;
         case OPT_VFYOPT:
             if (!vfyopts)
                 vfyopts = sk_OPENSSL_STRING_new_null();
@@ -1090,6 +1146,10 @@ int x509_main(int argc, char **argv)
     sk_OPENSSL_STRING_free(sigopts);
     sk_OPENSSL_STRING_free(vfyopts);
     X509_REQ_free(rq);
+#ifndef OPENSSL_NO_SM2
+    OPENSSL_free(sm2_id);
+    OPENSSL_free(sig_sm2_id);
+#endif
     ASN1_INTEGER_free(sno);
     sk_ASN1_OBJECT_pop_free(trust, ASN1_OBJECT_free);
     sk_ASN1_OBJECT_pop_free(reject, ASN1_OBJECT_free);
Index: b/ssl/statem/statem_lib.c
===================================================================
--- a/ssl/statem/statem_lib.c
+++ b/ssl/statem/statem_lib.c
@@ -344,6 +344,27 @@ CON_FUNC_RETURN tls_construct_cert_verif
         goto err;
     }
 
+#ifndef OPENSSL_NO_SM2
+    if (EVP_PKEY_is_a(pkey, "SM2")) {
+        if (pkey != NULL) {
+            pctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, pkey,
+                                              sctx->propq);
+            if (pctx == NULL) {
+                SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+
+            if (EVP_PKEY_CTX_set1_id(pctx, HANDSHAKE_SM2_ID,
+                                     HANDSHAKE_SM2_ID_LEN) != 1) {
+                SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+
+            EVP_MD_CTX_set_pkey_ctx(mctx, pctx);
+        }
+    }
+#endif
+
     /* Get the data to be signed */
     if (!get_cert_verify_tbs_data(s, tls13tbs, &hdata, &hdatalen)) {
         /* SSLfatal() already called */
@@ -432,10 +453,20 @@ CON_FUNC_RETURN tls_construct_cert_verif
 
     OPENSSL_free(sig);
     EVP_MD_CTX_free(mctx);
+#ifndef OPENSSL_NO_SM2
+    /*other sig call EVP_PKEY_CTX_free there may cause segfault */
+    if (pkey != NULL && EVP_PKEY_is_a(pkey, "SM2"))
+        EVP_PKEY_CTX_free(pctx);
+#endif
     return CON_FUNC_SUCCESS;
  err:
     OPENSSL_free(sig);
     EVP_MD_CTX_free(mctx);
+#ifndef OPENSSL_NO_SM2
+    /*other sig call EVP_PKEY_CTX_free there may cause segfault */
+    if (pkey != NULL && EVP_PKEY_is_a(pkey, "SM2"))
+        EVP_PKEY_CTX_free(pctx);
+#endif
     return CON_FUNC_ERROR;
 }
 
@@ -467,7 +498,6 @@ MSG_PROCESS_RETURN tls_process_cert_veri
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
-
     if (ssl_cert_lookup_by_pkey(pkey, NULL, sctx) == NULL) {
         SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,
                  SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
@@ -537,6 +567,24 @@ MSG_PROCESS_RETURN tls_process_cert_veri
     OSSL_TRACE1(TLS, "Using client verify alg %s\n",
                 md == NULL ? "n/a" : EVP_MD_get0_name(md));
 
+#ifndef OPENSSL_NO_SM2
+    if (EVP_PKEY_is_a(pkey, "SM2"))  {
+        pctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, pkey, sctx->propq);
+        if (pctx == NULL) {
+            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+            goto err;
+        }
+
+        if (EVP_PKEY_CTX_set1_id(pctx, HANDSHAKE_SM2_ID,
+                                 HANDSHAKE_SM2_ID_LEN) != 1) {
+            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
+            goto err;
+        }
+
+        EVP_MD_CTX_set_pkey_ctx(mctx, pctx);
+    }
+#endif
+
     if (EVP_DigestVerifyInit_ex(mctx, &pctx,
                                 md == NULL ? NULL : EVP_MD_get0_name(md),
                                 sctx->libctx, sctx->propq, pkey,
@@ -607,6 +655,11 @@ MSG_PROCESS_RETURN tls_process_cert_veri
     BIO_free(s->s3.handshake_buffer);
     s->s3.handshake_buffer = NULL;
     EVP_MD_CTX_free(mctx);
+#ifndef OPENSSL_NO_SM2
+    /*other sig call EVP_PKEY_CTX_free there may cause segfault */
+    if (pkey != NULL && EVP_PKEY_is_a(pkey, "SM2"))
+        EVP_PKEY_CTX_free(pctx);
+#endif
 #ifndef OPENSSL_NO_GOST
     OPENSSL_free(gost_data);
 #endif
Index: b/ssl/statem/statem_local.h
===================================================================
--- a/ssl/statem/statem_local.h
+++ b/ssl/statem/statem_local.h
@@ -40,6 +40,17 @@
 /* Dummy message type */
 #define SSL3_MT_DUMMY   -1
 
+#ifndef OPENSSL_NO_SM2
+/*
+ * standard handshake sm2-id and cert verify id is defined in RFC 8998
+ */
+# define HANDSHAKE_SM2_ID "TLSv1.3+GM+Cipher+Suite"
+# define HANDSHAKE_SM2_ID_LEN sizeof(HANDSHAKE_SM2_ID) - 1
+# define CERTVRIFY_SM2_ID "1234567812345678"
+# define CERTVRIFY_SM2_ID_LEN sizeof(CERTVRIFY_SM2_ID) - 1
+
+#endif
+
 /* Invalid extension ID for non-supported extensions */
 #define TLSEXT_TYPE_invalid            0x10000
 #define TLSEXT_TYPE_out_of_range       0x10001
Index: b/include/openssl/obj_mac.h
===================================================================
--- a/include/openssl/obj_mac.h
+++ b/include/openssl/obj_mac.h
@@ -5753,6 +5753,20 @@
 #define LN_zstd         "Zstandard compression"
 #define NID_zstd                1289
 
+
+#define SN_kx_sm2               "KxSM2"
+#define LN_kx_sm2               "kx-sm2"
+#define NID_kx_sm2              1320
+
+#define SN_kx_sm2dhe            "KxSM2DHE"
+#define LN_kx_sm2dhe            "kx-sm2dhe"
+#define NID_kx_sm2dhe           1321
+
+#define SN_auth_sm2             "AuthSM2"
+#define LN_auth_sm2             "auth-sm2"
+#define NID_auth_sm2            1322
+
+
 #endif /* OPENSSL_OBJ_MAC_H */
 
 #ifndef OPENSSL_NO_DEPRECATED_3_0
Index: b/crypto/sm2/sm2_sign.c
===================================================================
--- a/crypto/sm2/sm2_sign.c
+++ b/crypto/sm2/sm2_sign.c
@@ -53,7 +53,7 @@ static int GMI_SM2_sign_preprocess1(cons
 int ossl_sm2_compute_z_digest(uint8_t *out,
                               const EVP_MD *digest,
                               const uint8_t *id,
-                              const size_t id_len,
+                              size_t id_len,
                               const EC_KEY *key)
 {
     int rc = 0;
@@ -122,6 +122,11 @@ int ossl_sm2_compute_z_digest(uint8_t *o
         goto done;
     }
 
+    if (id == NULL) {
+        id = (const uint8_t *)SM2_DEFAULT_USERID;
+        id_len = strlen(SM2_DEFAULT_USERID);
+    }
+
     entl = (uint16_t)(8 * id_len);
 
     e_byte = entl >> 8;
Index: b/ssl/record/methods/recmethod_local.h
===================================================================
--- a/ssl/record/methods/recmethod_local.h
+++ b/ssl/record/methods/recmethod_local.h
@@ -392,10 +392,16 @@ void ossl_rlayer_fatal(OSSL_RECORD_LAYER
     (ERR_new(),                                                    \
      ERR_set_debug(OPENSSL_FILE, OPENSSL_LINE, OPENSSL_FUNC),      \
      ossl_rlayer_fatal)
-
+#ifndef OPENSSL_NO_NTLS
+#define RLAYER_USE_EXPLICIT_IV(rl) ((rl)->version == TLS1_1_VERSION \
+                                    || (rl)->version == TLS1_2_VERSION \
+                                    || (rl)->version == NTLS1_1_VERSION \
+                                    || (rl)->isdtls)
+#else
 #define RLAYER_USE_EXPLICIT_IV(rl) ((rl)->version == TLS1_1_VERSION \
                                     || (rl)->version == TLS1_2_VERSION \
                                     || (rl)->isdtls)
+#endif
 
 void ossl_tls_rl_record_set_seq_num(TLS_RL_RECORD *r,
                                     const unsigned char *seq_num);
Index: b/providers/common/capabilities.c
===================================================================
--- a/providers/common/capabilities.c
+++ b/providers/common/capabilities.c
@@ -95,6 +95,9 @@ static const TLS_GROUP_CONSTANTS group_l
     { OSSL_TLS_GROUP_ID_ffdhe4096, 128, TLS1_3_VERSION, 0, -1, -1 },
     { OSSL_TLS_GROUP_ID_ffdhe6144, 128, TLS1_3_VERSION, 0, -1, -1 },
     { OSSL_TLS_GROUP_ID_ffdhe8192, 192, TLS1_3_VERSION, 0, -1, -1 },
+#if !defined(OPENSSL_NO_SM2) && !defined(FIPS_MODULE)
+    { OSSL_TLS_GROUP_ID_sm2, 128, NTLS1_1_VERSION, 0, -1, -1 },
+#endif
 };
 
 #define TLS_GROUP_ENTRY(tlsname, realname, algorithm, idx) \
@@ -206,6 +209,9 @@ static const OSSL_PARAM param_group_list
     TLS_GROUP_ENTRY("ffdhe6144", "ffdhe6144", "DH", 36),
     TLS_GROUP_ENTRY("ffdhe8192", "ffdhe8192", "DH", 37),
 # endif
+# if !defined(OPENSSL_NO_SM2) && !defined(FIPS_MODULE)
+    TLS_GROUP_ENTRY("curveSM2", "SM2", "SM2", 38),
+# endif
 };
 #endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 
Index: b/doc/man1/openssl-ca.pod.in
===================================================================
--- a/doc/man1/openssl-ca.pod.in
+++ b/doc/man1/openssl-ca.pod.in
@@ -65,6 +65,8 @@ B<openssl> B<ca>
 [B<-multivalue-rdn>]
 {- $OpenSSL::safe::opt_r_synopsis -}
 {- $OpenSSL::safe::opt_engine_synopsis -}{- $OpenSSL::safe::opt_provider_synopsis -}
+[B<-sm2-id> I<string>]
+[B<-sm2-hex-id> I<hex-string>]
 [I<certreq>...]
 
 =head1 DESCRIPTION
@@ -348,6 +350,21 @@ This option has been deprecated and has
 
 {- $OpenSSL::safe::opt_provider_item -}
 
+=item B<-sm2-id>
+
+Specify the ID string to use when verifying an SM2 certificate. The ID string is
+required by the SM2 signature algorithm for signing and verification.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+=item B<-sm2-hex-id>
+
+Specify a binary ID string to use when signing or verifying using an SM2
+certificate. The argument for this option is string of hexadecimal digits.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+
 =back
 
 =head1 CRL OPTIONS
Index: b/doc/man1/openssl-req.pod.in
===================================================================
--- a/doc/man1/openssl-req.pod.in
+++ b/doc/man1/openssl-req.pod.in
@@ -57,6 +57,8 @@ B<openssl> B<req>
 {- $OpenSSL::safe::opt_name_synopsis -}
 {- $OpenSSL::safe::opt_r_synopsis -}
 {- $OpenSSL::safe::opt_engine_synopsis -}{- $OpenSSL::safe::opt_provider_synopsis -}
+[B<-sm2-id> I<string>]
+[B<-sm2-hex-id> I<hex-string>]
 
 =head1 DESCRIPTION
 
@@ -422,6 +424,21 @@ for key generation operations.
 
 {- $OpenSSL::safe::opt_provider_item -}
 
+=item B<-sm2-id>
+
+Specify the ID string to use when verifying an SM2 certificate. The ID string is
+required by the SM2 signature algorithm for signing and verification.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+=item B<-sm2-hex-id>
+
+Specify a binary ID string to use when signing or verifying using an SM2
+certificate. The argument for this option is string of hexadecimal digits.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+
 =back
 
 =head1 CONFIGURATION FILE FORMAT
Index: b/doc/man1/openssl-verify.pod.in
===================================================================
--- a/doc/man1/openssl-verify.pod.in
+++ b/doc/man1/openssl-verify.pod.in
@@ -20,6 +20,8 @@ B<openssl> B<verify>
 {- $OpenSSL::safe::opt_trust_synopsis -}
 {- $OpenSSL::safe::opt_engine_synopsis -}{- $OpenSSL::safe::opt_v_synopsis -}
 {- $OpenSSL::safe::opt_provider_synopsis -}
+[B<-sm2-id> I<string>]
+[B<-sm2-hex-id> I<hex-string>]
 [B<-->]
 [I<certificate> ...]
 
@@ -102,6 +104,21 @@ One or more target certificates to verif
 given, this command will attempt to read a single certificate from standard
 input.
 
+=item B<-sm2-id>
+
+Specify the ID string to use when verifying an SM2 certificate. The ID string is
+required by the SM2 signature algorithm for signing and verification.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+=item B<-sm2-hex-id>
+
+Specify a binary ID string to use when signing or verifying using an SM2
+certificate. The argument for this option is string of hexadecimal digits.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+
 =back
 
 =head1 DIAGNOSTICS
Index: b/doc/man1/openssl-x509.pod.in
===================================================================
--- a/doc/man1/openssl-x509.pod.in
+++ b/doc/man1/openssl-x509.pod.in
@@ -78,6 +78,8 @@ B<openssl> B<x509>
 [B<-addreject> I<arg>]
 {- $OpenSSL::safe::opt_r_synopsis -}
 {- $OpenSSL::safe::opt_engine_synopsis -}{- $OpenSSL::safe::opt_provider_synopsis -}
+[B<-sm2-id> I<string>]
+[B<-sm2-hex-id> I<hex-string>]
 
 =head1 DESCRIPTION
 
@@ -208,6 +210,21 @@ Do not output a certificate (except for
 
 This option prevents output except for printing as requested by below options.
 
+=item B<-sm2-id>
+
+Specify the ID string to use when verifying an SM2 certificate. The ID string is
+required by the SM2 signature algorithm for signing and verification.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+=item B<-sm2-hex-id>
+
+Specify a binary ID string to use when signing or verifying using an SM2
+certificate. The argument for this option is string of hexadecimal digits.
+
+This is a compatible option for older Tongsuo/BabaSSL versions.
+
+
 =back
 
 =head2 Certificate Printing Options
Index: b/test/recipes/20-test_pkeyutl.t
===================================================================
--- a/test/recipes/20-test_pkeyutl.t
+++ b/test/recipes/20-test_pkeyutl.t
@@ -30,14 +30,14 @@ SKIP: {
                       '-in', srctop_file('test', 'certs', 'sm2.pem'),
                       '-inkey', srctop_file('test', 'certs', 'sm2.key'),
                       '-out', 'sm2.sig', '-rawin',
-                      '-digest', 'sm3', '-pkeyopt', 'distid:someid']))),
+                      '-digest', 'sm3', '-pkeyopt', 'sm2_id:someid']))),
                       "Sign a piece of data using SM2");
     ok_nofips(run(app(([ 'openssl', 'pkeyutl',
                       '-verify', '-certin',
                       '-in', srctop_file('test', 'certs', 'sm2.pem'),
                       '-inkey', srctop_file('test', 'certs', 'sm2.pem'),
                       '-sigfile', 'sm2.sig', '-rawin',
-                      '-digest', 'sm3', '-pkeyopt', 'distid:someid']))),
+                      '-digest', 'sm3', '-pkeyopt', 'sm2_id:someid']))),
                       "Verify an SM2 signature against a piece of data");
     ok_nofips(run(app(([ 'openssl', 'pkeyutl', '-encrypt',
                       '-in', srctop_file('test', 'data2.bin'),
Index: b/test/recipes/25-test_req.t
===================================================================
--- a/test/recipes/25-test_req.t
+++ b/test/recipes/25-test_req.t
@@ -327,28 +327,28 @@ subtest "generating SM2 certificate requ
         ok(run(app(["openssl", "req",
                     "-config", srctop_file("test", "test.cnf"),
                     "-new", "-key", srctop_file(@certs, "sm2.key"),
-                    "-sigopt", "distid:1234567812345678",
-                    "-out", "testreq-sm2.pem", "-sm3"])),
-           "Generating SM2 certificate request");
+                    "-sigopt", "sm2_id:1234567812345678",
+                    "-out", "testreq-sm2-cpt.pem", "-sm3"])),
+           "Generating SM2 certificate request (compat)");
 
         ok(run(app(["openssl", "req",
                     "-config", srctop_file("test", "test.cnf"),
-                    "-verify", "-in", "testreq-sm2.pem", "-noout",
-                    "-vfyopt", "distid:1234567812345678", "-sm3"])),
-           "Verifying signature on SM2 certificate request");
+                    "-verify", "-in", "testreq-sm2-cpt.pem", "-noout",
+                    "-sm2-id", "1234567812345678", "-sm3"])),
+           "Verifying signature on SM2 certificate request (compat)");
 
         ok(run(app(["openssl", "req",
                     "-config", srctop_file("test", "test.cnf"),
                     "-new", "-key", srctop_file(@certs, "sm2.key"),
-                    "-sigopt", "hexdistid:DEADBEEF",
-                    "-out", "testreq-sm2.pem", "-sm3"])),
-           "Generating SM2 certificate request with hex id");
+                    "-sigopt", "sm2_hex_id:DEADBEEF",
+                    "-out", "testreq-sm2-cpt.pem", "-sm3"])),
+           "Generating SM2 certificate request with hex id (compat)");
 
         ok(run(app(["openssl", "req",
                     "-config", srctop_file("test", "test.cnf"),
-                    "-verify", "-in", "testreq-sm2.pem", "-noout",
-                    "-vfyopt", "hexdistid:DEADBEEF", "-sm3"])),
-           "Verifying signature on SM2 certificate request");
+                    "-verify", "-in", "testreq-sm2-cpt.pem", "-noout",
+                    "-sm2-hex-id", "DEADBEEF", "-sm3"])),
+           "Verifying signature on SM2 certificate request (compat)");
     }
 };
 
Index: b/test/recipes/25-test_verify.t
===================================================================
--- a/test/recipes/25-test_verify.t
+++ b/test/recipes/25-test_verify.t
@@ -29,7 +29,7 @@ sub verify {
     run(app([@args]));
 }
 
-plan tests => 193;
+plan tests => 195;
 
 # Canonical success
 ok(verify("ee-cert", "sslserver", ["root-cert"], ["ca-cert"]),
@@ -545,6 +545,10 @@ SKIP: {
        "SM2 ID test");
    ok_nofips(verify("sm2", "", ["sm2-ca-cert"], [], "-vfyopt", "hexdistid:31323334353637383132333435363738"),
        "SM2 hex ID test");
+   ok_nofips(verify("sm2", "", ["sm2-ca-cert"], [], "-sm2-id", "1234567812345678"),
+       "SM2 ID test (compat)");
+   ok_nofips(verify("sm2", "", ["sm2-ca-cert"], [], "-sm2-hex-id", "31323334353637383132333435363738"),
+       "SM2 hex ID test (compat)");
 }
 
 # Mixed content tests
Index: b/test/recipes/80-test_ca.t
===================================================================
--- a/test/recipes/80-test_ca.t
+++ b/test/recipes/80-test_ca.t
@@ -31,7 +31,7 @@ sub src_file {
 
 rmtree("demoCA", { safe => 0 });
 
-plan tests => 20;
+plan tests => 22;
 
 require_ok(srctop_file("test", "recipes", "tconversion.pl"));
 
@@ -83,6 +83,33 @@ SKIP: {
        "Signing SM2 certificate request");
 }
 
+SKIP: {
+    skip "SM2 is not supported by this OpenSSL build", 2
+	      if disabled("sm2");
+
+    ok(
+        run(app(['openssl',
+                    'ca',
+                    '-config', $cnf,
+                    '-revoke', "sm2-test.crt",
+                ])),
+        'Revoke SM2 certificate'
+    );
+
+    is(yes(cmdstr(app(["openssl", "ca", "-config",
+                       $cnf,
+                       "-in", srctop_file("test", "certs", "sm2-csr.pem"),
+                       "-out", "sm2-test-cpt.crt",
+                       "-sigopt", "sm2_id:1234567812345678",
+                       "-sm2-id", "1234567812345678",
+                       "-md", "sm3",
+                       "-cert", srctop_file("test", "certs", "sm2-root.crt"),
+                       "-keyfile", srctop_file("test", "certs", "sm2-root.key")]))),
+       0,
+       "Signing SM2 certificate request (compat)");
+}
+
+
 my $v3_cert = "v3-test.crt";
 ok(run(app(["openssl", "ca", "-batch", "-config", $cnf, "-extensions", "empty",
             "-in", src_file("x509-check.csr"), "-out", $v3_cert])));
Index: b/test/recipes/25-test_x509.t
===================================================================
--- a/test/recipes/25-test_x509.t
+++ b/test/recipes/25-test_x509.t
@@ -16,7 +16,7 @@ use OpenSSL::Test qw/:DEFAULT srctop_fil
 
 setup("test_x509");
 
-plan tests => 44;
+plan tests => 47;
 
 # Prevent MSys2 filename munging for arguments that look like file paths but
 # aren't
@@ -81,6 +81,30 @@ ok(run(app(["openssl", "pkey", "-in", $p
 # not unlinking $pubkey
 # not unlinking $selfout
 
+SKIP: {
+    skip "SM2 is not supported by this OpenSSL build", 2 if disabled("sm2");
+    ok(run(app(["openssl", "x509",
+                "-req",
+                "-in", srctop_file(@certs, "sm2-csr.pem"),
+                "-signkey", srctop_file(@certs, "sm2.key"),
+                "-out", "sm2.crt",
+                "-sm3",
+                "-vfyopt", "distid:1234567812345678",
+                "-sigopt", "distid:1234567812345678"])),
+                "Generating self-signed SM2 certificate");
+
+    ok(run(app(["openssl", "x509",
+                "-req",
+                "-in", srctop_file(@certs, "sm2-csr.pem"),
+                "-signkey", srctop_file(@certs, "sm2.key"),
+                "-out", "sm2-compat.crt",
+                "-sm3",
+                "-sm2-id", "1234567812345678",
+                "-sigopt", "sm2_id:1234567812345678"])),
+                "Generating self-signed SM2 certificate (compat)");
+}
+
+
 # simple way of directly producing a CA-signed cert with private/pubkey input
 my $ca = srctop_file(@certs, "ca-cert.pem"); # issuer cert
 my $caout = "ca-issued.out";
@@ -167,6 +191,32 @@ SKIP: {
        "error loading unsupported sm2 cert");
 }
 
+subtest 'x509 -- sign sm2 cert' => sub {
+    plan tests => 2;
+
+    SKIP: {
+        skip "SM2 is not supported by this OpenSSL build", 2
+            if disabled("sm2");
+
+        # test x509 sign sm2 cert, should include X509v3 extensions
+        my $csr = srctop_file(@certs, "sm2-csr.pem");
+        my $key = srctop_file(@certs, "sm2-root.key");
+        my $cert = "sm2-root.tmp";
+        ok(run(app([ "openssl", "x509", "-req", "-in", $csr, "-extfile",
+            srctop_file("apps", "openssl.cnf"), "-extensions", "v3_ca", "-sm3",
+            "-vfyopt", "distid:1234567812345678",
+            "-signkey", $key, "-out", $cert ])));
+
+        my @output = run(app([ "openssl", "x509", "-in", $cert, "-text",
+            "-noout" ], stderr => undef), capture => 1);
+
+        unlink $cert;
+
+        my $count = grep /X509v3 Basic Constraints:/, @output;
+        ok($count == 1);
+    }
+};
+
 # 3 tests for -dateopts formats
 ok(run(app(["openssl", "x509", "-noout", "-dates", "-dateopt", "rfc_822",
 	     "-in", srctop_file("test/certs", "ca-cert.pem")])),
